var rb = Object.getPrototypeOf;
var ib = Reflect.get;
var Ou = (r, e, t) => ib(rb(r), t, e);
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const oo = globalThis, Kh = oo.ShadowRoot && (oo.ShadyCSS === void 0 || oo.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, Jh = Symbol(), mu = /* @__PURE__ */ new WeakMap();
let jf = class {
  constructor(e, t, i) {
    if (this._$cssResult$ = !0, i !== Jh)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = e, this.t = t;
  }
  get styleSheet() {
    let e = this.o;
    const t = this.t;
    if (Kh && e === void 0) {
      const i = t !== void 0 && t.length === 1;
      i && (e = mu.get(t)), e === void 0 && ((this.o = e = new CSSStyleSheet()).replaceSync(this.cssText), i && mu.set(t, e));
    }
    return e;
  }
  toString() {
    return this.cssText;
  }
};
const Zt = (r) => new jf(typeof r == "string" ? r : r + "", void 0, Jh), re = (r, ...e) => {
  const t = r.length === 1 ? r[0] : e.reduce((i, n, s) => i + ((o) => {
    if (o._$cssResult$ === !0)
      return o.cssText;
    if (typeof o == "number")
      return o;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + o + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(n) + r[s + 1], r[0]);
  return new jf(t, r, Jh);
}, nb = (r, e) => {
  if (Kh)
    r.adoptedStyleSheets = e.map((t) => t instanceof CSSStyleSheet ? t : t.styleSheet);
  else
    for (const t of e) {
      const i = document.createElement("style"), n = oo.litNonce;
      n !== void 0 && i.setAttribute("nonce", n), i.textContent = t.cssText, r.appendChild(i);
    }
}, gu = Kh ? (r) => r : (r) => r instanceof CSSStyleSheet ? ((e) => {
  let t = "";
  for (const i of e.cssRules)
    t += i.cssText;
  return Zt(t);
})(r) : r;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: sb, defineProperty: ob, getOwnPropertyDescriptor: lb, getOwnPropertyNames: ab, getOwnPropertySymbols: hb, getPrototypeOf: cb } = Object, $r = globalThis, bu = $r.trustedTypes, ub = bu ? bu.emptyScript : "", El = $r.reactiveElementPolyfillSupport, Zn = (r, e) => r, qi = { toAttribute(r, e) {
  switch (e) {
    case Boolean:
      r = r ? ub : null;
      break;
    case Object:
    case Array:
      r = r == null ? r : JSON.stringify(r);
  }
  return r;
}, fromAttribute(r, e) {
  let t = r;
  switch (e) {
    case Boolean:
      t = r !== null;
      break;
    case Number:
      t = r === null ? null : Number(r);
      break;
    case Object:
    case Array:
      try {
        t = JSON.parse(r);
      } catch {
        t = null;
      }
  }
  return t;
} }, ec = (r, e) => !sb(r, e), wu = { attribute: !0, type: String, converter: qi, reflect: !1, hasChanged: ec };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), $r.litPropertyMetadata ?? ($r.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
class vi extends HTMLElement {
  static addInitializer(e) {
    this._$Ei(), (this.l ?? (this.l = [])).push(e);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(e, t = wu) {
    if (t.state && (t.attribute = !1), this._$Ei(), this.elementProperties.set(e, t), !t.noAccessor) {
      const i = Symbol(), n = this.getPropertyDescriptor(e, i, t);
      n !== void 0 && ob(this.prototype, e, n);
    }
  }
  static getPropertyDescriptor(e, t, i) {
    const { get: n, set: s } = lb(this.prototype, e) ?? { get() {
      return this[t];
    }, set(o) {
      this[t] = o;
    } };
    return { get() {
      return n == null ? void 0 : n.call(this);
    }, set(o) {
      const l = n == null ? void 0 : n.call(this);
      s.call(this, o), this.requestUpdate(e, l, i);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(e) {
    return this.elementProperties.get(e) ?? wu;
  }
  static _$Ei() {
    if (this.hasOwnProperty(Zn("elementProperties")))
      return;
    const e = cb(this);
    e.finalize(), e.l !== void 0 && (this.l = [...e.l]), this.elementProperties = new Map(e.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(Zn("finalized")))
      return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(Zn("properties"))) {
      const t = this.properties, i = [...ab(t), ...hb(t)];
      for (const n of i)
        this.createProperty(n, t[n]);
    }
    const e = this[Symbol.metadata];
    if (e !== null) {
      const t = litPropertyMetadata.get(e);
      if (t !== void 0)
        for (const [i, n] of t)
          this.elementProperties.set(i, n);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t, i] of this.elementProperties) {
      const n = this._$Eu(t, i);
      n !== void 0 && this._$Eh.set(n, t);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(e) {
    const t = [];
    if (Array.isArray(e)) {
      const i = new Set(e.flat(1 / 0).reverse());
      for (const n of i)
        t.unshift(gu(n));
    } else
      e !== void 0 && t.push(gu(e));
    return t;
  }
  static _$Eu(e, t) {
    const i = t.attribute;
    return i === !1 ? void 0 : typeof i == "string" ? i : typeof e == "string" ? e.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var e;
    this._$Eg = new Promise((t) => this.enableUpdating = t), this._$AL = /* @__PURE__ */ new Map(), this._$ES(), this.requestUpdate(), (e = this.constructor.l) == null || e.forEach((t) => t(this));
  }
  addController(e) {
    var t;
    (this._$E_ ?? (this._$E_ = /* @__PURE__ */ new Set())).add(e), this.renderRoot !== void 0 && this.isConnected && ((t = e.hostConnected) == null || t.call(e));
  }
  removeController(e) {
    var t;
    (t = this._$E_) == null || t.delete(e);
  }
  _$ES() {
    const e = /* @__PURE__ */ new Map(), t = this.constructor.elementProperties;
    for (const i of t.keys())
      this.hasOwnProperty(i) && (e.set(i, this[i]), delete this[i]);
    e.size > 0 && (this._$Ep = e);
  }
  createRenderRoot() {
    const e = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return nb(e, this.constructor.elementStyles), e;
  }
  connectedCallback() {
    var e;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (e = this._$E_) == null || e.forEach((t) => {
      var i;
      return (i = t.hostConnected) == null ? void 0 : i.call(t);
    });
  }
  enableUpdating(e) {
  }
  disconnectedCallback() {
    var e;
    (e = this._$E_) == null || e.forEach((t) => {
      var i;
      return (i = t.hostDisconnected) == null ? void 0 : i.call(t);
    });
  }
  attributeChangedCallback(e, t, i) {
    this._$AK(e, i);
  }
  _$EO(e, t) {
    var s;
    const i = this.constructor.elementProperties.get(e), n = this.constructor._$Eu(e, i);
    if (n !== void 0 && i.reflect === !0) {
      const o = (((s = i.converter) == null ? void 0 : s.toAttribute) !== void 0 ? i.converter : qi).toAttribute(t, i.type);
      this._$Em = e, o == null ? this.removeAttribute(n) : this.setAttribute(n, o), this._$Em = null;
    }
  }
  _$AK(e, t) {
    var s;
    const i = this.constructor, n = i._$Eh.get(e);
    if (n !== void 0 && this._$Em !== n) {
      const o = i.getPropertyOptions(n), l = typeof o.converter == "function" ? { fromAttribute: o.converter } : ((s = o.converter) == null ? void 0 : s.fromAttribute) !== void 0 ? o.converter : qi;
      this._$Em = n, this[n] = l.fromAttribute(t, o.type), this._$Em = null;
    }
  }
  requestUpdate(e, t, i) {
    if (e !== void 0) {
      if (i ?? (i = this.constructor.getPropertyOptions(e)), !(i.hasChanged ?? ec)(this[e], t))
        return;
      this.C(e, t, i);
    }
    this.isUpdatePending === !1 && (this._$Eg = this._$EP());
  }
  C(e, t, i) {
    this._$AL.has(e) || this._$AL.set(e, t), i.reflect === !0 && this._$Em !== e && (this._$ET ?? (this._$ET = /* @__PURE__ */ new Set())).add(e);
  }
  async _$EP() {
    this.isUpdatePending = !0;
    try {
      await this._$Eg;
    } catch (t) {
      Promise.reject(t);
    }
    const e = this.scheduleUpdate();
    return e != null && await e, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var i;
    if (!this.isUpdatePending)
      return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [s, o] of this._$Ep)
          this[s] = o;
        this._$Ep = void 0;
      }
      const n = this.constructor.elementProperties;
      if (n.size > 0)
        for (const [s, o] of n)
          o.wrapped !== !0 || this._$AL.has(s) || this[s] === void 0 || this.C(s, this[s], o);
    }
    let e = !1;
    const t = this._$AL;
    try {
      e = this.shouldUpdate(t), e ? (this.willUpdate(t), (i = this._$E_) == null || i.forEach((n) => {
        var s;
        return (s = n.hostUpdate) == null ? void 0 : s.call(n);
      }), this.update(t)) : this._$Ej();
    } catch (n) {
      throw e = !1, this._$Ej(), n;
    }
    e && this._$AE(t);
  }
  willUpdate(e) {
  }
  _$AE(e) {
    var t;
    (t = this._$E_) == null || t.forEach((i) => {
      var n;
      return (n = i.hostUpdated) == null ? void 0 : n.call(i);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(e)), this.updated(e);
  }
  _$Ej() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$Eg;
  }
  shouldUpdate(e) {
    return !0;
  }
  update(e) {
    this._$ET && (this._$ET = this._$ET.forEach((t) => this._$EO(t, this[t]))), this._$Ej();
  }
  updated(e) {
  }
  firstUpdated(e) {
  }
}
vi.elementStyles = [], vi.shadowRootOptions = { mode: "open" }, vi[Zn("elementProperties")] = /* @__PURE__ */ new Map(), vi[Zn("finalized")] = /* @__PURE__ */ new Map(), El == null || El({ ReactiveElement: vi }), ($r.reactiveElementVersions ?? ($r.reactiveElementVersions = [])).push("2.0.3");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const _n = globalThis, So = _n.trustedTypes, yu = So ? So.createPolicy("lit-html", { createHTML: (r) => r }) : void 0, Lf = "$lit$", wr = `lit$${(Math.random() + "").slice(9)}$`, Bf = "?" + wr, db = `<${Bf}>`, ai = document, jn = () => ai.createComment(""), Ln = (r) => r === null || typeof r != "object" && typeof r != "function", Df = Array.isArray, pb = (r) => Df(r) || typeof (r == null ? void 0 : r[Symbol.iterator]) == "function", ql = `[ 	
\f\r]`, ln = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, vu = /-->/g, xu = />/g, Gr = RegExp(`>|${ql}(?:([^\\s"'>=/]+)(${ql}*=${ql}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), Su = /'/g, ku = /"/g, If = /^(?:script|style|textarea|title)$/i, fb = (r) => (e, ...t) => ({ _$litType$: r, strings: e, values: t }), X = fb(1), pt = Symbol.for("lit-noChange"), de = Symbol.for("lit-nothing"), $u = /* @__PURE__ */ new WeakMap(), ri = ai.createTreeWalker(ai, 129);
function Uf(r, e) {
  if (!Array.isArray(r) || !r.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return yu !== void 0 ? yu.createHTML(e) : e;
}
const Ob = (r, e) => {
  const t = r.length - 1, i = [];
  let n, s = e === 2 ? "<svg>" : "", o = ln;
  for (let l = 0; l < t; l++) {
    const a = r[l];
    let h, c, u = -1, d = 0;
    for (; d < a.length && (o.lastIndex = d, c = o.exec(a), c !== null); )
      d = o.lastIndex, o === ln ? c[1] === "!--" ? o = vu : c[1] !== void 0 ? o = xu : c[2] !== void 0 ? (If.test(c[2]) && (n = RegExp("</" + c[2], "g")), o = Gr) : c[3] !== void 0 && (o = Gr) : o === Gr ? c[0] === ">" ? (o = n ?? ln, u = -1) : c[1] === void 0 ? u = -2 : (u = o.lastIndex - c[2].length, h = c[1], o = c[3] === void 0 ? Gr : c[3] === '"' ? ku : Su) : o === ku || o === Su ? o = Gr : o === vu || o === xu ? o = ln : (o = Gr, n = void 0);
    const p = o === Gr && r[l + 1].startsWith("/>") ? " " : "";
    s += o === ln ? a + db : u >= 0 ? (i.push(h), a.slice(0, u) + Lf + a.slice(u) + wr + p) : a + wr + (u === -2 ? l : p);
  }
  return [Uf(r, s + (r[t] || "<?>") + (e === 2 ? "</svg>" : "")), i];
};
class Bn {
  constructor({ strings: e, _$litType$: t }, i) {
    let n;
    this.parts = [];
    let s = 0, o = 0;
    const l = e.length - 1, a = this.parts, [h, c] = Ob(e, t);
    if (this.el = Bn.createElement(h, i), ri.currentNode = this.el.content, t === 2) {
      const u = this.el.content.firstChild;
      u.replaceWith(...u.childNodes);
    }
    for (; (n = ri.nextNode()) !== null && a.length < l; ) {
      if (n.nodeType === 1) {
        if (n.hasAttributes())
          for (const u of n.getAttributeNames())
            if (u.endsWith(Lf)) {
              const d = c[o++], p = n.getAttribute(u).split(wr), f = /([.?@])?(.*)/.exec(d);
              a.push({ type: 1, index: s, name: f[2], strings: p, ctor: f[1] === "." ? gb : f[1] === "?" ? bb : f[1] === "@" ? wb : ol }), n.removeAttribute(u);
            } else
              u.startsWith(wr) && (a.push({ type: 6, index: s }), n.removeAttribute(u));
        if (If.test(n.tagName)) {
          const u = n.textContent.split(wr), d = u.length - 1;
          if (d > 0) {
            n.textContent = So ? So.emptyScript : "";
            for (let p = 0; p < d; p++)
              n.append(u[p], jn()), ri.nextNode(), a.push({ type: 2, index: ++s });
            n.append(u[d], jn());
          }
        }
      } else if (n.nodeType === 8)
        if (n.data === Bf)
          a.push({ type: 2, index: s });
        else {
          let u = -1;
          for (; (u = n.data.indexOf(wr, u + 1)) !== -1; )
            a.push({ type: 7, index: s }), u += wr.length - 1;
        }
      s++;
    }
  }
  static createElement(e, t) {
    const i = ai.createElement("template");
    return i.innerHTML = e, i;
  }
}
function zi(r, e, t = r, i) {
  var o, l;
  if (e === pt)
    return e;
  let n = i !== void 0 ? (o = t._$Co) == null ? void 0 : o[i] : t._$Cl;
  const s = Ln(e) ? void 0 : e._$litDirective$;
  return (n == null ? void 0 : n.constructor) !== s && ((l = n == null ? void 0 : n._$AO) == null || l.call(n, !1), s === void 0 ? n = void 0 : (n = new s(r), n._$AT(r, t, i)), i !== void 0 ? (t._$Co ?? (t._$Co = []))[i] = n : t._$Cl = n), n !== void 0 && (e = zi(r, n._$AS(r, e.values), n, i)), e;
}
let mb = class {
  constructor(e, t) {
    this._$AV = [], this._$AN = void 0, this._$AD = e, this._$AM = t;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(e) {
    const { el: { content: t }, parts: i } = this._$AD, n = ((e == null ? void 0 : e.creationScope) ?? ai).importNode(t, !0);
    ri.currentNode = n;
    let s = ri.nextNode(), o = 0, l = 0, a = i[0];
    for (; a !== void 0; ) {
      if (o === a.index) {
        let h;
        a.type === 2 ? h = new Os(s, s.nextSibling, this, e) : a.type === 1 ? h = new a.ctor(s, a.name, a.strings, this, e) : a.type === 6 && (h = new yb(s, this, e)), this._$AV.push(h), a = i[++l];
      }
      o !== (a == null ? void 0 : a.index) && (s = ri.nextNode(), o++);
    }
    return ri.currentNode = ai, n;
  }
  p(e) {
    let t = 0;
    for (const i of this._$AV)
      i !== void 0 && (i.strings !== void 0 ? (i._$AI(e, i, t), t += i.strings.length - 2) : i._$AI(e[t])), t++;
  }
};
class Os {
  get _$AU() {
    var e;
    return ((e = this._$AM) == null ? void 0 : e._$AU) ?? this._$Cv;
  }
  constructor(e, t, i, n) {
    this.type = 2, this._$AH = de, this._$AN = void 0, this._$AA = e, this._$AB = t, this._$AM = i, this.options = n, this._$Cv = (n == null ? void 0 : n.isConnected) ?? !0;
  }
  get parentNode() {
    let e = this._$AA.parentNode;
    const t = this._$AM;
    return t !== void 0 && (e == null ? void 0 : e.nodeType) === 11 && (e = t.parentNode), e;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(e, t = this) {
    e = zi(this, e, t), Ln(e) ? e === de || e == null || e === "" ? (this._$AH !== de && this._$AR(), this._$AH = de) : e !== this._$AH && e !== pt && this._(e) : e._$litType$ !== void 0 ? this.g(e) : e.nodeType !== void 0 ? this.$(e) : pb(e) ? this.T(e) : this._(e);
  }
  k(e) {
    return this._$AA.parentNode.insertBefore(e, this._$AB);
  }
  $(e) {
    this._$AH !== e && (this._$AR(), this._$AH = this.k(e));
  }
  _(e) {
    this._$AH !== de && Ln(this._$AH) ? this._$AA.nextSibling.data = e : this.$(ai.createTextNode(e)), this._$AH = e;
  }
  g(e) {
    var s;
    const { values: t, _$litType$: i } = e, n = typeof i == "number" ? this._$AC(e) : (i.el === void 0 && (i.el = Bn.createElement(Uf(i.h, i.h[0]), this.options)), i);
    if (((s = this._$AH) == null ? void 0 : s._$AD) === n)
      this._$AH.p(t);
    else {
      const o = new mb(n, this), l = o.u(this.options);
      o.p(t), this.$(l), this._$AH = o;
    }
  }
  _$AC(e) {
    let t = $u.get(e.strings);
    return t === void 0 && $u.set(e.strings, t = new Bn(e)), t;
  }
  T(e) {
    Df(this._$AH) || (this._$AH = [], this._$AR());
    const t = this._$AH;
    let i, n = 0;
    for (const s of e)
      n === t.length ? t.push(i = new Os(this.k(jn()), this.k(jn()), this, this.options)) : i = t[n], i._$AI(s), n++;
    n < t.length && (this._$AR(i && i._$AB.nextSibling, n), t.length = n);
  }
  _$AR(e = this._$AA.nextSibling, t) {
    var i;
    for ((i = this._$AP) == null ? void 0 : i.call(this, !1, !0, t); e && e !== this._$AB; ) {
      const n = e.nextSibling;
      e.remove(), e = n;
    }
  }
  setConnected(e) {
    var t;
    this._$AM === void 0 && (this._$Cv = e, (t = this._$AP) == null || t.call(this, e));
  }
}
class ol {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(e, t, i, n, s) {
    this.type = 1, this._$AH = de, this._$AN = void 0, this.element = e, this.name = t, this._$AM = n, this.options = s, i.length > 2 || i[0] !== "" || i[1] !== "" ? (this._$AH = Array(i.length - 1).fill(new String()), this.strings = i) : this._$AH = de;
  }
  _$AI(e, t = this, i, n) {
    const s = this.strings;
    let o = !1;
    if (s === void 0)
      e = zi(this, e, t, 0), o = !Ln(e) || e !== this._$AH && e !== pt, o && (this._$AH = e);
    else {
      const l = e;
      let a, h;
      for (e = s[0], a = 0; a < s.length - 1; a++)
        h = zi(this, l[i + a], t, a), h === pt && (h = this._$AH[a]), o || (o = !Ln(h) || h !== this._$AH[a]), h === de ? e = de : e !== de && (e += (h ?? "") + s[a + 1]), this._$AH[a] = h;
    }
    o && !n && this.O(e);
  }
  O(e) {
    e === de ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, e ?? "");
  }
}
class gb extends ol {
  constructor() {
    super(...arguments), this.type = 3;
  }
  O(e) {
    this.element[this.name] = e === de ? void 0 : e;
  }
}
class bb extends ol {
  constructor() {
    super(...arguments), this.type = 4;
  }
  O(e) {
    this.element.toggleAttribute(this.name, !!e && e !== de);
  }
}
class wb extends ol {
  constructor(e, t, i, n, s) {
    super(e, t, i, n, s), this.type = 5;
  }
  _$AI(e, t = this) {
    if ((e = zi(this, e, t, 0) ?? de) === pt)
      return;
    const i = this._$AH, n = e === de && i !== de || e.capture !== i.capture || e.once !== i.once || e.passive !== i.passive, s = e !== de && (i === de || n);
    n && this.element.removeEventListener(this.name, this, i), s && this.element.addEventListener(this.name, this, e), this._$AH = e;
  }
  handleEvent(e) {
    var t;
    typeof this._$AH == "function" ? this._$AH.call(((t = this.options) == null ? void 0 : t.host) ?? this.element, e) : this._$AH.handleEvent(e);
  }
}
class yb {
  constructor(e, t, i) {
    this.element = e, this.type = 6, this._$AN = void 0, this._$AM = t, this.options = i;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(e) {
    zi(this, e);
  }
}
const zl = _n.litHtmlPolyfillSupport;
zl == null || zl(Bn, Os), (_n.litHtmlVersions ?? (_n.litHtmlVersions = [])).push("3.1.1");
const vb = (r, e, t) => {
  const i = (t == null ? void 0 : t.renderBefore) ?? e;
  let n = i._$litPart$;
  if (n === void 0) {
    const s = (t == null ? void 0 : t.renderBefore) ?? null;
    i._$litPart$ = n = new Os(e.insertBefore(jn(), s), s, void 0, t ?? {});
  }
  return n._$AI(r), n;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let Pi = class extends vi {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var t;
    const e = super.createRenderRoot();
    return (t = this.renderOptions).renderBefore ?? (t.renderBefore = e.firstChild), e;
  }
  update(e) {
    const t = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(e), this._$Do = vb(t, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var e;
    super.connectedCallback(), (e = this._$Do) == null || e.setConnected(!0);
  }
  disconnectedCallback() {
    var e;
    super.disconnectedCallback(), (e = this._$Do) == null || e.setConnected(!1);
  }
  render() {
    return pt;
  }
};
var Mf;
Pi._$litElement$ = !0, Pi.finalized = !0, (Mf = globalThis.litElementHydrateSupport) == null || Mf.call(globalThis, { LitElement: Pi });
const Yl = globalThis.litElementPolyfillSupport;
Yl == null || Yl({ LitElement: Pi });
(globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push("4.0.3");
var We = re`
  :host {
    box-sizing: border-box;
  }

  :host *,
  :host *::before,
  :host *::after {
    box-sizing: inherit;
  }

  [hidden] {
    display: none !important;
  }
`, xb = re`
  ${We}

  :host {
    --track-width: 2px;
    --track-color: rgb(128 128 128 / 25%);
    --indicator-color: var(--sl-color-primary-600);
    --speed: 2s;

    display: inline-flex;
    width: 1em;
    height: 1em;
  }

  .spinner {
    flex: 1 1 auto;
    height: 100%;
    width: 100%;
  }

  .spinner__track,
  .spinner__indicator {
    fill: none;
    stroke-width: var(--track-width);
    r: calc(0.5em - var(--track-width) / 2);
    cx: 0.5em;
    cy: 0.5em;
    transform-origin: 50% 50%;
  }

  .spinner__track {
    stroke: var(--track-color);
    transform-origin: 0% 0%;
  }

  .spinner__indicator {
    stroke: var(--indicator-color);
    stroke-linecap: round;
    stroke-dasharray: 150% 75%;
    animation: spin var(--speed) linear infinite;
  }

  @keyframes spin {
    0% {
      transform: rotate(0deg);
      stroke-dasharray: 0.01em, 2.75em;
    }

    50% {
      transform: rotate(450deg);
      stroke-dasharray: 1.375em, 1.375em;
    }

    100% {
      transform: rotate(1080deg);
      stroke-dasharray: 0.01em, 2.75em;
    }
  }
`;
const Ra = /* @__PURE__ */ new Set(), Sb = new MutationObserver(Hf), ki = /* @__PURE__ */ new Map();
let Gf = document.documentElement.dir || "ltr", Nf = document.documentElement.lang || navigator.language, Jr;
Sb.observe(document.documentElement, {
  attributes: !0,
  attributeFilter: ["dir", "lang"]
});
function Ff(...r) {
  r.map((e) => {
    const t = e.$code.toLowerCase();
    ki.has(t) ? ki.set(t, Object.assign(Object.assign({}, ki.get(t)), e)) : ki.set(t, e), Jr || (Jr = e);
  }), Hf();
}
function Hf() {
  Gf = document.documentElement.dir || "ltr", Nf = document.documentElement.lang || navigator.language, [...Ra.keys()].map((r) => {
    typeof r.requestUpdate == "function" && r.requestUpdate();
  });
}
let kb = class {
  constructor(e) {
    this.host = e, this.host.addController(this);
  }
  hostConnected() {
    Ra.add(this.host);
  }
  hostDisconnected() {
    Ra.delete(this.host);
  }
  dir() {
    return `${this.host.dir || Gf}`.toLowerCase();
  }
  lang() {
    return `${this.host.lang || Nf}`.toLowerCase();
  }
  getTranslationData(e) {
    var t, i;
    const n = new Intl.Locale(e.replace(/_/g, "-")), s = n == null ? void 0 : n.language.toLowerCase(), o = (i = (t = n == null ? void 0 : n.region) === null || t === void 0 ? void 0 : t.toLowerCase()) !== null && i !== void 0 ? i : "", l = ki.get(`${s}-${o}`), a = ki.get(s);
    return { locale: n, language: s, region: o, primary: l, secondary: a };
  }
  exists(e, t) {
    var i;
    const { primary: n, secondary: s } = this.getTranslationData((i = t.lang) !== null && i !== void 0 ? i : this.lang());
    return t = Object.assign({ includeFallback: !1 }, t), !!(n && n[e] || s && s[e] || t.includeFallback && Jr && Jr[e]);
  }
  term(e, ...t) {
    const { primary: i, secondary: n } = this.getTranslationData(this.lang());
    let s;
    if (i && i[e])
      s = i[e];
    else if (n && n[e])
      s = n[e];
    else if (Jr && Jr[e])
      s = Jr[e];
    else
      return console.error(`No translation found for: ${String(e)}`), String(e);
    return typeof s == "function" ? s(...t) : s;
  }
  date(e, t) {
    return e = new Date(e), new Intl.DateTimeFormat(this.lang(), t).format(e);
  }
  number(e, t) {
    return e = Number(e), isNaN(e) ? "" : new Intl.NumberFormat(this.lang(), t).format(e);
  }
  relativeTime(e, t, i) {
    return new Intl.RelativeTimeFormat(this.lang(), i).format(e, t);
  }
};
var Kf = {
  $code: "en",
  $name: "English",
  $dir: "ltr",
  carousel: "Carousel",
  clearEntry: "Clear entry",
  close: "Close",
  copied: "Copied",
  copy: "Copy",
  currentValue: "Current value",
  error: "Error",
  goToSlide: (r, e) => `Go to slide ${r} of ${e}`,
  hidePassword: "Hide password",
  loading: "Loading",
  nextSlide: "Next slide",
  numOptionsSelected: (r) => r === 0 ? "No options selected" : r === 1 ? "1 option selected" : `${r} options selected`,
  previousSlide: "Previous slide",
  progress: "Progress",
  remove: "Remove",
  resize: "Resize",
  scrollToEnd: "Scroll to end",
  scrollToStart: "Scroll to start",
  selectAColorFromTheScreen: "Select a color from the screen",
  showPassword: "Show password",
  slideNum: (r) => `Slide ${r}`,
  toggleColorFormat: "Toggle color format"
};
Ff(Kf);
var $b = Kf, Vr = class extends kb {
};
Ff($b);
var Jf = Object.defineProperty, Qb = Object.defineProperties, Pb = Object.getOwnPropertyDescriptor, Tb = Object.getOwnPropertyDescriptors, Qu = Object.getOwnPropertySymbols, Cb = Object.prototype.hasOwnProperty, Xb = Object.prototype.propertyIsEnumerable, Pu = (r, e, t) => e in r ? Jf(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, gi = (r, e) => {
  for (var t in e || (e = {}))
    Cb.call(e, t) && Pu(r, t, e[t]);
  if (Qu)
    for (var t of Qu(e))
      Xb.call(e, t) && Pu(r, t, e[t]);
  return r;
}, ll = (r, e) => Qb(r, Tb(e)), w = (r, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? Pb(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (n = (i ? o(e, t, n) : o(n)) || n);
  return i && n && Jf(e, t, n), n;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Mr = (r) => (e, t) => {
  t !== void 0 ? t.addInitializer(() => {
    customElements.define(r, e);
  }) : customElements.define(r, e);
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Zb = { attribute: !0, type: String, converter: qi, reflect: !1, hasChanged: ec }, _b = (r = Zb, e, t) => {
  const { kind: i, metadata: n } = t;
  let s = globalThis.litPropertyMetadata.get(n);
  if (s === void 0 && globalThis.litPropertyMetadata.set(n, s = /* @__PURE__ */ new Map()), s.set(t.name, r), i === "accessor") {
    const { name: o } = t;
    return { set(l) {
      const a = e.get.call(this);
      e.set.call(this, l), this.requestUpdate(o, a, r);
    }, init(l) {
      return l !== void 0 && this.C(o, void 0, r), l;
    } };
  }
  if (i === "setter") {
    const { name: o } = t;
    return function(l) {
      const a = this[o];
      e.call(this, l), this.requestUpdate(o, a, r);
    };
  }
  throw Error("Unsupported decorator location: " + i);
};
function y(r) {
  return (e, t) => typeof t == "object" ? _b(r, e, t) : ((i, n, s) => {
    const o = n.hasOwnProperty(s);
    return n.constructor.createProperty(s, o ? { ...i, wrapped: !0 } : i), o ? Object.getOwnPropertyDescriptor(n, s) : void 0;
  })(r, e, t);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function De(r) {
  return y({ ...r, state: !0, attribute: !1 });
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function Rb(r) {
  return (e, t) => {
    const i = typeof e == "function" ? e : e[t];
    Object.assign(i, r);
  };
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Aa = (r, e, t) => (t.configurable = !0, t.enumerable = !0, Reflect.decorate && typeof e != "object" && Object.defineProperty(r, e, t), t);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function J(r, e) {
  return (t, i, n) => {
    const s = (o) => {
      var l;
      return ((l = o.renderRoot) == null ? void 0 : l.querySelector(r)) ?? null;
    };
    if (e) {
      const { get: o, set: l } = typeof i == "object" ? t : n ?? (() => {
        const a = Symbol();
        return { get() {
          return this[a];
        }, set(h) {
          this[a] = h;
        } };
      })();
      return Aa(t, i, { get() {
        let a = o.call(this);
        return a === void 0 && (a = s(this), (a !== null || this.hasUpdated) && l.call(this, a)), a;
      } });
    }
    return Aa(t, i, { get() {
      return s(this);
    } });
  };
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let Ab;
function Eb(r) {
  return (e, t) => Aa(e, t, { get() {
    return (this.renderRoot ?? Ab ?? (Ab = document.createDocumentFragment())).querySelectorAll(r);
  } });
}
var ve = class extends Pi {
  constructor() {
    super(), Object.entries(this.constructor.dependencies).forEach(([r, e]) => {
      this.constructor.define(r, e);
    });
  }
  emit(r, e) {
    const t = new CustomEvent(r, gi({
      bubbles: !0,
      cancelable: !1,
      composed: !0,
      detail: {}
    }, e));
    return this.dispatchEvent(t), t;
  }
  /* eslint-enable */
  static define(r, e = this, t = {}) {
    const i = customElements.get(r);
    if (!i) {
      customElements.define(r, class extends e {
      }, t);
      return;
    }
    let n = " (unknown version)", s = n;
    "version" in e && e.version && (n = " v" + e.version), "version" in i && i.version && (s = " v" + i.version), !(n && s && n === s) && console.warn(
      `Attempted to register <${r}>${n}, but <${r}>${s} has already been registered.`
    );
  }
};
ve.version = "2.12.0";
ve.dependencies = {};
w([
  y()
], ve.prototype, "dir", 2);
w([
  y()
], ve.prototype, "lang", 2);
var eO = class extends ve {
  constructor() {
    super(...arguments), this.localize = new Vr(this);
  }
  render() {
    return X`
      <svg part="base" class="spinner" role="progressbar" aria-label=${this.localize.term("loading")}>
        <circle class="spinner__track"></circle>
        <circle class="spinner__indicator"></circle>
      </svg>
    `;
  }
};
eO.styles = xb;
var an = /* @__PURE__ */ new WeakMap(), hn = /* @__PURE__ */ new WeakMap(), cn = /* @__PURE__ */ new WeakMap(), Wl = /* @__PURE__ */ new WeakSet(), Xs = /* @__PURE__ */ new WeakMap(), tc = class {
  constructor(r, e) {
    this.handleFormData = (t) => {
      const i = this.options.disabled(this.host), n = this.options.name(this.host), s = this.options.value(this.host), o = this.host.tagName.toLowerCase() === "sl-button";
      !i && !o && typeof n == "string" && n.length > 0 && typeof s < "u" && (Array.isArray(s) ? s.forEach((l) => {
        t.formData.append(n, l.toString());
      }) : t.formData.append(n, s.toString()));
    }, this.handleFormSubmit = (t) => {
      var i;
      const n = this.options.disabled(this.host), s = this.options.reportValidity;
      this.form && !this.form.noValidate && ((i = an.get(this.form)) == null || i.forEach((o) => {
        this.setUserInteracted(o, !0);
      })), this.form && !this.form.noValidate && !n && !s(this.host) && (t.preventDefault(), t.stopImmediatePropagation());
    }, this.handleFormReset = () => {
      this.options.setValue(this.host, this.options.defaultValue(this.host)), this.setUserInteracted(this.host, !1), Xs.set(this.host, []);
    }, this.handleInteraction = (t) => {
      const i = Xs.get(this.host);
      i.includes(t.type) || i.push(t.type), i.length === this.options.assumeInteractionOn.length && this.setUserInteracted(this.host, !0);
    }, this.checkFormValidity = () => {
      if (this.form && !this.form.noValidate) {
        const t = this.form.querySelectorAll("*");
        for (const i of t)
          if (typeof i.checkValidity == "function" && !i.checkValidity())
            return !1;
      }
      return !0;
    }, this.reportFormValidity = () => {
      if (this.form && !this.form.noValidate) {
        const t = this.form.querySelectorAll("*");
        for (const i of t)
          if (typeof i.reportValidity == "function" && !i.reportValidity())
            return !1;
      }
      return !0;
    }, (this.host = r).addController(this), this.options = gi({
      form: (t) => {
        const i = t.form;
        if (i) {
          const s = t.getRootNode().getElementById(i);
          if (s)
            return s;
        }
        return t.closest("form");
      },
      name: (t) => t.name,
      value: (t) => t.value,
      defaultValue: (t) => t.defaultValue,
      disabled: (t) => {
        var i;
        return (i = t.disabled) != null ? i : !1;
      },
      reportValidity: (t) => typeof t.reportValidity == "function" ? t.reportValidity() : !0,
      checkValidity: (t) => typeof t.checkValidity == "function" ? t.checkValidity() : !0,
      setValue: (t, i) => t.value = i,
      assumeInteractionOn: ["sl-input"]
    }, e);
  }
  hostConnected() {
    const r = this.options.form(this.host);
    r && this.attachForm(r), Xs.set(this.host, []), this.options.assumeInteractionOn.forEach((e) => {
      this.host.addEventListener(e, this.handleInteraction);
    });
  }
  hostDisconnected() {
    this.detachForm(), Xs.delete(this.host), this.options.assumeInteractionOn.forEach((r) => {
      this.host.removeEventListener(r, this.handleInteraction);
    });
  }
  hostUpdated() {
    const r = this.options.form(this.host);
    r || this.detachForm(), r && this.form !== r && (this.detachForm(), this.attachForm(r)), this.host.hasUpdated && this.setValidity(this.host.validity.valid);
  }
  attachForm(r) {
    r ? (this.form = r, an.has(this.form) ? an.get(this.form).add(this.host) : an.set(this.form, /* @__PURE__ */ new Set([this.host])), this.form.addEventListener("formdata", this.handleFormData), this.form.addEventListener("submit", this.handleFormSubmit), this.form.addEventListener("reset", this.handleFormReset), hn.has(this.form) || (hn.set(this.form, this.form.reportValidity), this.form.reportValidity = () => this.reportFormValidity()), cn.has(this.form) || (cn.set(this.form, this.form.checkValidity), this.form.checkValidity = () => this.checkFormValidity())) : this.form = void 0;
  }
  detachForm() {
    if (!this.form)
      return;
    const r = an.get(this.form);
    r && (r.delete(this.host), r.size <= 0 && (this.form.removeEventListener("formdata", this.handleFormData), this.form.removeEventListener("submit", this.handleFormSubmit), this.form.removeEventListener("reset", this.handleFormReset), hn.has(this.form) && (this.form.reportValidity = hn.get(this.form), hn.delete(this.form)), cn.has(this.form) && (this.form.checkValidity = cn.get(this.form), cn.delete(this.form)), this.form = void 0));
  }
  setUserInteracted(r, e) {
    e ? Wl.add(r) : Wl.delete(r), r.requestUpdate();
  }
  doAction(r, e) {
    if (this.form) {
      const t = document.createElement("button");
      t.type = r, t.style.position = "absolute", t.style.width = "0", t.style.height = "0", t.style.clipPath = "inset(50%)", t.style.overflow = "hidden", t.style.whiteSpace = "nowrap", e && (t.name = e.name, t.value = e.value, ["formaction", "formenctype", "formmethod", "formnovalidate", "formtarget"].forEach((i) => {
        e.hasAttribute(i) && t.setAttribute(i, e.getAttribute(i));
      })), this.form.append(t), t.click(), t.remove();
    }
  }
  /** Returns the associated `<form>` element, if one exists. */
  getForm() {
    var r;
    return (r = this.form) != null ? r : null;
  }
  /** Resets the form, restoring all the control to their default value */
  reset(r) {
    this.doAction("reset", r);
  }
  /** Submits the form, triggering validation and form data injection. */
  submit(r) {
    this.doAction("submit", r);
  }
  /**
   * Synchronously sets the form control's validity. Call this when you know the future validity but need to update
   * the host element immediately, i.e. before Lit updates the component in the next update.
   */
  setValidity(r) {
    const e = this.host, t = !!Wl.has(e), i = !!e.required;
    e.toggleAttribute("data-required", i), e.toggleAttribute("data-optional", !i), e.toggleAttribute("data-invalid", !r), e.toggleAttribute("data-valid", r), e.toggleAttribute("data-user-invalid", !r && t), e.toggleAttribute("data-user-valid", r && t);
  }
  /**
   * Updates the form control's validity based on the current value of `host.validity.valid`. Call this when anything
   * that affects constraint validation changes so the component receives the correct validity states.
   */
  updateValidity() {
    const r = this.host;
    this.setValidity(r.validity.valid);
  }
  /**
   * Dispatches a non-bubbling, cancelable custom event of type `sl-invalid`.
   * If the `sl-invalid` event will be cancelled then the original `invalid`
   * event (which may have been passed as argument) will also be cancelled.
   * If no original `invalid` event has been passed then the `sl-invalid`
   * event will be cancelled before being dispatched.
   */
  emitInvalidEvent(r) {
    const e = new CustomEvent("sl-invalid", {
      bubbles: !1,
      composed: !1,
      cancelable: !0,
      detail: {}
    });
    r || e.preventDefault(), this.host.dispatchEvent(e) || r == null || r.preventDefault();
  }
}, rc = Object.freeze({
  badInput: !1,
  customError: !1,
  patternMismatch: !1,
  rangeOverflow: !1,
  rangeUnderflow: !1,
  stepMismatch: !1,
  tooLong: !1,
  tooShort: !1,
  typeMismatch: !1,
  valid: !0,
  valueMissing: !1
});
Object.freeze(ll(gi({}, rc), {
  valid: !1,
  valueMissing: !0
}));
Object.freeze(ll(gi({}, rc), {
  valid: !1,
  customError: !0
}));
var qb = re`
  ${We}

  :host {
    display: inline-block;
    position: relative;
    width: auto;
    cursor: pointer;
  }

  .button {
    display: inline-flex;
    align-items: stretch;
    justify-content: center;
    width: 100%;
    border-style: solid;
    border-width: var(--sl-input-border-width);
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-font-weight-semibold);
    text-decoration: none;
    user-select: none;
    -webkit-user-select: none;
    white-space: nowrap;
    vertical-align: middle;
    padding: 0;
    transition:
      var(--sl-transition-x-fast) background-color,
      var(--sl-transition-x-fast) color,
      var(--sl-transition-x-fast) border,
      var(--sl-transition-x-fast) box-shadow;
    cursor: inherit;
  }

  .button::-moz-focus-inner {
    border: 0;
  }

  .button:focus {
    outline: none;
  }

  .button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* When disabled, prevent mouse events from bubbling up from children */
  .button--disabled * {
    pointer-events: none;
  }

  .button__prefix,
  .button__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    pointer-events: none;
  }

  .button__label {
    display: inline-block;
  }

  .button__label::slotted(sl-icon) {
    vertical-align: -2px;
  }

  /*
   * Standard buttons
   */

  /* Default */
  .button--standard.button--default {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-neutral-300);
    color: var(--sl-color-neutral-700);
  }

  .button--standard.button--default:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-50);
    border-color: var(--sl-color-primary-300);
    color: var(--sl-color-primary-700);
  }

  .button--standard.button--default:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-100);
    border-color: var(--sl-color-primary-400);
    color: var(--sl-color-primary-700);
  }

  /* Primary */
  .button--standard.button--primary {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--standard.button--success {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success:hover:not(.button--disabled) {
    background-color: var(--sl-color-success-500);
    border-color: var(--sl-color-success-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success:active:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--standard.button--neutral {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral:hover:not(.button--disabled) {
    background-color: var(--sl-color-neutral-500);
    border-color: var(--sl-color-neutral-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral:active:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--standard.button--warning {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }
  .button--standard.button--warning:hover:not(.button--disabled) {
    background-color: var(--sl-color-warning-500);
    border-color: var(--sl-color-warning-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--warning:active:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--standard.button--danger {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger:hover:not(.button--disabled) {
    background-color: var(--sl-color-danger-500);
    border-color: var(--sl-color-danger-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger:active:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  /*
   * Outline buttons
   */

  .button--outline {
    background: none;
    border: solid 1px;
  }

  /* Default */
  .button--outline.button--default {
    border-color: var(--sl-color-neutral-300);
    color: var(--sl-color-neutral-700);
  }

  .button--outline.button--default:hover:not(.button--disabled),
  .button--outline.button--default.button--checked:not(.button--disabled) {
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--default:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Primary */
  .button--outline.button--primary {
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-primary-600);
  }

  .button--outline.button--primary:hover:not(.button--disabled),
  .button--outline.button--primary.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--primary:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--outline.button--success {
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-success-600);
  }

  .button--outline.button--success:hover:not(.button--disabled),
  .button--outline.button--success.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--success:active:not(.button--disabled) {
    border-color: var(--sl-color-success-700);
    background-color: var(--sl-color-success-700);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--outline.button--neutral {
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-600);
  }

  .button--outline.button--neutral:hover:not(.button--disabled),
  .button--outline.button--neutral.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--neutral:active:not(.button--disabled) {
    border-color: var(--sl-color-neutral-700);
    background-color: var(--sl-color-neutral-700);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--outline.button--warning {
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-warning-600);
  }

  .button--outline.button--warning:hover:not(.button--disabled),
  .button--outline.button--warning.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--warning:active:not(.button--disabled) {
    border-color: var(--sl-color-warning-700);
    background-color: var(--sl-color-warning-700);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--outline.button--danger {
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-danger-600);
  }

  .button--outline.button--danger:hover:not(.button--disabled),
  .button--outline.button--danger.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--danger:active:not(.button--disabled) {
    border-color: var(--sl-color-danger-700);
    background-color: var(--sl-color-danger-700);
    color: var(--sl-color-neutral-0);
  }

  @media (forced-colors: active) {
    .button.button--outline.button--checked:not(.button--disabled) {
      outline: solid 2px transparent;
    }
  }

  /*
   * Text buttons
   */

  .button--text {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-600);
  }

  .button--text:hover:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
  }

  .button--text:focus-visible:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
  }

  .button--text:active:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-700);
  }

  /*
   * Size modifiers
   */

  .button--small {
    height: auto;
    min-height: var(--sl-input-height-small);
    font-size: var(--sl-button-font-size-small);
    line-height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-small);
  }

  .button--medium {
    height: auto;
    min-height: var(--sl-input-height-medium);
    font-size: var(--sl-button-font-size-medium);
    line-height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-medium);
  }

  .button--large {
    height: auto;
    min-height: var(--sl-input-height-large);
    font-size: var(--sl-button-font-size-large);
    line-height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-large);
  }

  /*
   * Pill modifier
   */

  .button--pill.button--small {
    border-radius: var(--sl-input-height-small);
  }

  .button--pill.button--medium {
    border-radius: var(--sl-input-height-medium);
  }

  .button--pill.button--large {
    border-radius: var(--sl-input-height-large);
  }

  /*
   * Circle modifier
   */

  .button--circle {
    padding-left: 0;
    padding-right: 0;
  }

  .button--circle.button--small {
    width: var(--sl-input-height-small);
    border-radius: 50%;
  }

  .button--circle.button--medium {
    width: var(--sl-input-height-medium);
    border-radius: 50%;
  }

  .button--circle.button--large {
    width: var(--sl-input-height-large);
    border-radius: 50%;
  }

  .button--circle .button__prefix,
  .button--circle .button__suffix,
  .button--circle .button__caret {
    display: none;
  }

  /*
   * Caret modifier
   */

  .button--caret .button__suffix {
    display: none;
  }

  .button--caret .button__caret {
    height: auto;
  }

  /*
   * Loading modifier
   */

  .button--loading {
    position: relative;
    cursor: wait;
  }

  .button--loading .button__prefix,
  .button--loading .button__label,
  .button--loading .button__suffix,
  .button--loading .button__caret {
    visibility: hidden;
  }

  .button--loading sl-spinner {
    --indicator-color: currentColor;
    position: absolute;
    font-size: 1em;
    height: 1em;
    width: 1em;
    top: calc(50% - 0.5em);
    left: calc(50% - 0.5em);
  }

  /*
   * Badges
   */

  .button ::slotted(sl-badge) {
    position: absolute;
    top: 0;
    right: 0;
    translate: 50% -50%;
    pointer-events: none;
  }

  .button--rtl ::slotted(sl-badge) {
    right: auto;
    left: 0;
    translate: -50% -50%;
  }

  /*
   * Button spacing
   */

  .button--has-label.button--small .button__label {
    padding: 0 var(--sl-spacing-small);
  }

  .button--has-label.button--medium .button__label {
    padding: 0 var(--sl-spacing-medium);
  }

  .button--has-label.button--large .button__label {
    padding: 0 var(--sl-spacing-large);
  }

  .button--has-prefix.button--small {
    padding-inline-start: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--small .button__label {
    padding-inline-start: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--medium {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--medium .button__label {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large .button__label {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-suffix.button--small,
  .button--caret.button--small {
    padding-inline-end: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--small .button__label,
  .button--caret.button--small .button__label {
    padding-inline-end: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--medium,
  .button--caret.button--medium {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--medium .button__label,
  .button--caret.button--medium .button__label {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large,
  .button--caret.button--large {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large .button__label,
  .button--caret.button--large .button__label {
    padding-inline-end: var(--sl-spacing-small);
  }

  /*
   * Button groups support a variety of button types (e.g. buttons with tooltips, buttons as dropdown triggers, etc.).
   * This means buttons aren't always direct descendants of the button group, thus we can't target them with the
   * ::slotted selector. To work around this, the button group component does some magic to add these special classes to
   * buttons and we style them here instead.
   */

  :host(.sl-button-group__button--first:not(.sl-button-group__button--last)) .button {
    border-start-end-radius: 0;
    border-end-end-radius: 0;
  }

  :host(.sl-button-group__button--inner) .button {
    border-radius: 0;
  }

  :host(.sl-button-group__button--last:not(.sl-button-group__button--first)) .button {
    border-start-start-radius: 0;
    border-end-start-radius: 0;
  }

  /* All except the first */
  :host(.sl-button-group__button:not(.sl-button-group__button--first)) {
    margin-inline-start: calc(-1 * var(--sl-input-border-width));
  }

  /* Add a visual separator between solid buttons */
  :host(
      .sl-button-group__button:not(
          .sl-button-group__button--first,
          .sl-button-group__button--radio,
          [variant='default']
        ):not(:hover)
    )
    .button:after {
    content: '';
    position: absolute;
    top: 0;
    inset-inline-start: 0;
    bottom: 0;
    border-left: solid 1px rgb(128 128 128 / 33%);
    mix-blend-mode: multiply;
  }

  /* Bump hovered, focused, and checked buttons up so their focus ring isn't clipped */
  :host(.sl-button-group__button--hover) {
    z-index: 1;
  }

  /* Focus and checked are always on top */
  :host(.sl-button-group__button--focus),
  :host(.sl-button-group__button[checked]) {
    z-index: 2;
  }
`, ms = class {
  constructor(r, ...e) {
    this.slotNames = [], this.handleSlotChange = (t) => {
      const i = t.target;
      (this.slotNames.includes("[default]") && !i.name || i.name && this.slotNames.includes(i.name)) && this.host.requestUpdate();
    }, (this.host = r).addController(this), this.slotNames = e;
  }
  hasDefaultSlot() {
    return [...this.host.childNodes].some((r) => {
      if (r.nodeType === r.TEXT_NODE && r.textContent.trim() !== "")
        return !0;
      if (r.nodeType === r.ELEMENT_NODE) {
        const e = r;
        if (e.tagName.toLowerCase() === "sl-visually-hidden")
          return !1;
        if (!e.hasAttribute("slot"))
          return !0;
      }
      return !1;
    });
  }
  hasNamedSlot(r) {
    return this.host.querySelector(`:scope > [slot="${r}"]`) !== null;
  }
  test(r) {
    return r === "[default]" ? this.hasDefaultSlot() : this.hasNamedSlot(r);
  }
  hostConnected() {
    this.host.shadowRoot.addEventListener("slotchange", this.handleSlotChange);
  }
  hostDisconnected() {
    this.host.shadowRoot.removeEventListener("slotchange", this.handleSlotChange);
  }
};
function zb(r) {
  if (!r)
    return "";
  const e = r.assignedNodes({ flatten: !0 });
  let t = "";
  return [...e].forEach((i) => {
    i.nodeType === Node.TEXT_NODE && (t += i.textContent);
  }), t;
}
var Yb = re`
  ${We}

  :host {
    display: inline-block;
    width: 1em;
    height: 1em;
    box-sizing: content-box !important;
  }

  svg {
    display: block;
    height: 100%;
    width: 100%;
  }
`, Ea = "";
function Tu(r) {
  Ea = r;
}
function Wb(r = "") {
  if (!Ea) {
    const e = [...document.getElementsByTagName("script")], t = e.find((i) => i.hasAttribute("data-shoelace"));
    if (t)
      Tu(t.getAttribute("data-shoelace"));
    else {
      const i = e.find((s) => /shoelace(\.min)?\.js($|\?)/.test(s.src) || /shoelace-autoloader(\.min)?\.js($|\?)/.test(s.src));
      let n = "";
      i && (n = i.getAttribute("src")), Tu(n.split("/").slice(0, -1).join("/"));
    }
  }
  return Ea.replace(/\/$/, "") + (r ? `/${r.replace(/^\//, "")}` : "");
}
var Vb = {
  name: "default",
  resolver: (r) => Wb(`assets/icons/${r}.svg`)
}, Mb = Vb, Cu = {
  caret: `
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="6 9 12 15 18 9"></polyline>
    </svg>
  `,
  check: `
    <svg part="checked-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor">
          <g transform="translate(3.428571, 3.428571)">
            <path d="M0,5.71428571 L3.42857143,9.14285714"></path>
            <path d="M9.14285714,0 L3.42857143,9.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  "chevron-down": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-down" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  "chevron-left": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-left" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/>
    </svg>
  `,
  "chevron-right": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-right" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  copy: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-copy" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V2Zm2-1a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H6ZM2 5a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-1h1v1a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h1v1H2Z"/>
    </svg>
  `,
  eye: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye" viewBox="0 0 16 16">
      <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/>
      <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
    </svg>
  `,
  "eye-slash": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye-slash" viewBox="0 0 16 16">
      <path d="M13.359 11.238C15.06 9.72 16 8 16 8s-3-5.5-8-5.5a7.028 7.028 0 0 0-2.79.588l.77.771A5.944 5.944 0 0 1 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.134 13.134 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755-.165.165-.337.328-.517.486l.708.709z"/>
      <path d="M11.297 9.176a3.5 3.5 0 0 0-4.474-4.474l.823.823a2.5 2.5 0 0 1 2.829 2.829l.822.822zm-2.943 1.299.822.822a3.5 3.5 0 0 1-4.474-4.474l.823.823a2.5 2.5 0 0 0 2.829 2.829z"/>
      <path d="M3.35 5.47c-.18.16-.353.322-.518.487A13.134 13.134 0 0 0 1.172 8l.195.288c.335.48.83 1.12 1.465 1.755C4.121 11.332 5.881 12.5 8 12.5c.716 0 1.39-.133 2.02-.36l.77.772A7.029 7.029 0 0 1 8 13.5C3 13.5 0 8 0 8s.939-1.721 2.641-3.238l.708.709zm10.296 8.884-12-12 .708-.708 12 12-.708.708z"/>
    </svg>
  `,
  eyedropper: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eyedropper" viewBox="0 0 16 16">
      <path d="M13.354.646a1.207 1.207 0 0 0-1.708 0L8.5 3.793l-.646-.647a.5.5 0 1 0-.708.708L8.293 5l-7.147 7.146A.5.5 0 0 0 1 12.5v1.793l-.854.853a.5.5 0 1 0 .708.707L1.707 15H3.5a.5.5 0 0 0 .354-.146L11 7.707l1.146 1.147a.5.5 0 0 0 .708-.708l-.647-.646 3.147-3.146a1.207 1.207 0 0 0 0-1.708l-2-2zM2 12.707l7-7L10.293 7l-7 7H2v-1.293z"></path>
    </svg>
  `,
  "grip-vertical": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-grip-vertical" viewBox="0 0 16 16">
      <path d="M7 2a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 5a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 8a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"></path>
    </svg>
  `,
  indeterminate: `
    <svg part="indeterminate-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor" stroke-width="2">
          <g transform="translate(2.285714, 6.857143)">
            <path d="M10.2857143,1.14285714 L1.14285714,1.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  "person-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-person-fill" viewBox="0 0 16 16">
      <path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/>
    </svg>
  `,
  "play-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-play-fill" viewBox="0 0 16 16">
      <path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"></path>
    </svg>
  `,
  "pause-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-pause-fill" viewBox="0 0 16 16">
      <path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"></path>
    </svg>
  `,
  radio: `
    <svg part="checked-icon" class="radio__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g fill="currentColor">
          <circle cx="8" cy="8" r="3.42857143"></circle>
        </g>
      </g>
    </svg>
  `,
  "star-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-star-fill" viewBox="0 0 16 16">
      <path d="M3.612 15.443c-.386.198-.824-.149-.746-.592l.83-4.73L.173 6.765c-.329-.314-.158-.888.283-.95l4.898-.696L7.538.792c.197-.39.73-.39.927 0l2.184 4.327 4.898.696c.441.062.612.636.282.95l-3.522 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256z"/>
    </svg>
  `,
  "x-lg": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-lg" viewBox="0 0 16 16">
      <path d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z"/>
    </svg>
  `,
  "x-circle-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-circle-fill" viewBox="0 0 16 16">
      <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM5.354 4.646a.5.5 0 1 0-.708.708L7.293 8l-2.647 2.646a.5.5 0 0 0 .708.708L8 8.707l2.646 2.647a.5.5 0 0 0 .708-.708L8.707 8l2.647-2.646a.5.5 0 0 0-.708-.708L8 7.293 5.354 4.646z"></path>
    </svg>
  `
}, jb = {
  name: "system",
  resolver: (r) => r in Cu ? `data:image/svg+xml,${encodeURIComponent(Cu[r])}` : ""
}, Lb = jb, Bb = [Mb, Lb], qa = [];
function Db(r) {
  qa.push(r);
}
function Ib(r) {
  qa = qa.filter((e) => e !== r);
}
function Xu(r) {
  return Bb.find((e) => e.name === r);
}
function $e(r, e) {
  const t = gi({
    waitUntilFirstUpdate: !1
  }, e);
  return (i, n) => {
    const { update: s } = i, o = Array.isArray(r) ? r : [r];
    i.update = function(l) {
      o.forEach((a) => {
        const h = a;
        if (l.has(h)) {
          const c = l.get(h), u = this[h];
          c !== u && (!t.waitUntilFirstUpdate || this.hasUpdated) && this[n](c, u);
        }
      }), s.call(this, l);
    };
  };
}
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Ub = (r, e) => e === void 0 ? (r == null ? void 0 : r._$litType$) !== void 0 : (r == null ? void 0 : r._$litType$) === e, tO = (r) => r.strings === void 0, Gb = {}, Nb = (r, e = Gb) => r._$AH = e;
var un = Symbol(), Zs = Symbol(), Vl, Ml = /* @__PURE__ */ new Map(), vt = class extends ve {
  constructor() {
    super(...arguments), this.initialRender = !1, this.svg = null, this.label = "", this.library = "default";
  }
  /** Given a URL, this function returns the resulting SVG element or an appropriate error symbol. */
  async resolveIcon(r, e) {
    var t;
    let i;
    if (e != null && e.spriteSheet)
      return X`<svg part="svg">
        <use part="use" href="${r}"></use>
      </svg>`;
    try {
      if (i = await fetch(r, { mode: "cors" }), !i.ok)
        return i.status === 410 ? un : Zs;
    } catch {
      return Zs;
    }
    try {
      const n = document.createElement("div");
      n.innerHTML = await i.text();
      const s = n.firstElementChild;
      if (((t = s == null ? void 0 : s.tagName) == null ? void 0 : t.toLowerCase()) !== "svg")
        return un;
      Vl || (Vl = new DOMParser());
      const l = Vl.parseFromString(s.outerHTML, "text/html").body.querySelector("svg");
      return l ? (l.part.add("svg"), document.adoptNode(l)) : un;
    } catch {
      return un;
    }
  }
  connectedCallback() {
    super.connectedCallback(), Db(this);
  }
  firstUpdated() {
    this.initialRender = !0, this.setIcon();
  }
  disconnectedCallback() {
    super.disconnectedCallback(), Ib(this);
  }
  getIconSource() {
    const r = Xu(this.library);
    return this.name && r ? {
      url: r.resolver(this.name),
      fromLibrary: !0
    } : {
      url: this.src,
      fromLibrary: !1
    };
  }
  handleLabelChange() {
    typeof this.label == "string" && this.label.length > 0 ? (this.setAttribute("role", "img"), this.setAttribute("aria-label", this.label), this.removeAttribute("aria-hidden")) : (this.removeAttribute("role"), this.removeAttribute("aria-label"), this.setAttribute("aria-hidden", "true"));
  }
  async setIcon() {
    var r;
    const { url: e, fromLibrary: t } = this.getIconSource(), i = t ? Xu(this.library) : void 0;
    if (!e) {
      this.svg = null;
      return;
    }
    let n = Ml.get(e);
    if (n || (n = this.resolveIcon(e, i), Ml.set(e, n)), !this.initialRender)
      return;
    const s = await n;
    if (s === Zs && Ml.delete(e), e === this.getIconSource().url) {
      if (Ub(s)) {
        this.svg = s;
        return;
      }
      switch (s) {
        case Zs:
        case un:
          this.svg = null, this.emit("sl-error");
          break;
        default:
          this.svg = s.cloneNode(!0), (r = i == null ? void 0 : i.mutator) == null || r.call(i, this.svg), this.emit("sl-load");
      }
    }
  }
  render() {
    return this.svg;
  }
};
vt.styles = Yb;
w([
  De()
], vt.prototype, "svg", 2);
w([
  y({ reflect: !0 })
], vt.prototype, "name", 2);
w([
  y()
], vt.prototype, "src", 2);
w([
  y()
], vt.prototype, "label", 2);
w([
  y({ reflect: !0 })
], vt.prototype, "library", 2);
w([
  $e("label")
], vt.prototype, "handleLabelChange", 1);
w([
  $e(["name", "src", "library"])
], vt.prototype, "setIcon", 1);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const tr = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 }, al = (r) => (...e) => ({ _$litDirective$: r, values: e });
let hl = class {
  constructor(e) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(e, t, i) {
    this._$Ct = e, this._$AM = t, this._$Ci = i;
  }
  _$AS(e, t) {
    return this.update(e, t);
  }
  update(e, t) {
    return this.render(...t);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const je = al(class extends hl {
  constructor(r) {
    var e;
    if (super(r), r.type !== tr.ATTRIBUTE || r.name !== "class" || ((e = r.strings) == null ? void 0 : e.length) > 2)
      throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(r) {
    return " " + Object.keys(r).filter((e) => r[e]).join(" ") + " ";
  }
  update(r, [e]) {
    var i, n;
    if (this.it === void 0) {
      this.it = /* @__PURE__ */ new Set(), r.strings !== void 0 && (this.st = new Set(r.strings.join(" ").split(/\s/).filter((s) => s !== "")));
      for (const s in e)
        e[s] && !((i = this.st) != null && i.has(s)) && this.it.add(s);
      return this.render(e);
    }
    const t = r.element.classList;
    for (const s of this.it)
      s in e || (t.remove(s), this.it.delete(s));
    for (const s in e) {
      const o = !!e[s];
      o === this.it.has(s) || (n = this.st) != null && n.has(s) || (o ? (t.add(s), this.it.add(s)) : (t.remove(s), this.it.delete(s)));
    }
    return pt;
  }
});
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const rO = Symbol.for(""), Fb = (r) => {
  if ((r == null ? void 0 : r.r) === rO)
    return r == null ? void 0 : r._$litStatic$;
}, ko = (r, ...e) => ({ _$litStatic$: e.reduce((t, i, n) => t + ((s) => {
  if (s._$litStatic$ !== void 0)
    return s._$litStatic$;
  throw Error(`Value passed to 'literal' function must be a 'literal' result: ${s}. Use 'unsafeStatic' to pass non-literal values, but
            take care to ensure page security.`);
})(i) + r[n + 1], r[0]), r: rO }), Zu = /* @__PURE__ */ new Map(), Hb = (r) => (e, ...t) => {
  const i = t.length;
  let n, s;
  const o = [], l = [];
  let a, h = 0, c = !1;
  for (; h < i; ) {
    for (a = e[h]; h < i && (s = t[h], (n = Fb(s)) !== void 0); )
      a += n + e[++h], c = !0;
    h !== i && l.push(s), o.push(a), h++;
  }
  if (h === i && o.push(e[i]), c) {
    const u = o.join("$$lit$$");
    (e = Zu.get(u)) === void 0 && (o.raw = o, Zu.set(u, e = o)), t = l;
  }
  return r(e, ...t);
}, lo = Hb(X);
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const I = (r) => r ?? de;
var ee = class extends ve {
  constructor() {
    super(...arguments), this.formControlController = new tc(this, {
      assumeInteractionOn: ["click"]
    }), this.hasSlotController = new ms(this, "[default]", "prefix", "suffix"), this.localize = new Vr(this), this.hasFocus = !1, this.invalid = !1, this.title = "", this.variant = "default", this.size = "medium", this.caret = !1, this.disabled = !1, this.loading = !1, this.outline = !1, this.pill = !1, this.circle = !1, this.type = "button", this.name = "", this.value = "", this.href = "", this.rel = "noreferrer noopener";
  }
  /** Gets the validity state object */
  get validity() {
    return this.isButton() ? this.button.validity : rc;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.isButton() ? this.button.validationMessage : "";
  }
  firstUpdated() {
    this.isButton() && this.formControlController.updateValidity();
  }
  handleBlur() {
    this.hasFocus = !1, this.emit("sl-blur");
  }
  handleFocus() {
    this.hasFocus = !0, this.emit("sl-focus");
  }
  handleClick() {
    this.type === "submit" && this.formControlController.submit(this), this.type === "reset" && this.formControlController.reset(this);
  }
  handleInvalid(r) {
    this.formControlController.setValidity(!1), this.formControlController.emitInvalidEvent(r);
  }
  isButton() {
    return !this.href;
  }
  isLink() {
    return !!this.href;
  }
  handleDisabledChange() {
    this.isButton() && this.formControlController.setValidity(this.disabled);
  }
  /** Simulates a click on the button. */
  click() {
    this.button.click();
  }
  /** Sets focus on the button. */
  focus(r) {
    this.button.focus(r);
  }
  /** Removes focus from the button. */
  blur() {
    this.button.blur();
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.isButton() ? this.button.checkValidity() : !0;
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.isButton() ? this.button.reportValidity() : !0;
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(r) {
    this.isButton() && (this.button.setCustomValidity(r), this.formControlController.updateValidity());
  }
  render() {
    const r = this.isLink(), e = r ? ko`a` : ko`button`;
    return lo`
      <${e}
        part="base"
        class=${je({
      button: !0,
      "button--default": this.variant === "default",
      "button--primary": this.variant === "primary",
      "button--success": this.variant === "success",
      "button--neutral": this.variant === "neutral",
      "button--warning": this.variant === "warning",
      "button--danger": this.variant === "danger",
      "button--text": this.variant === "text",
      "button--small": this.size === "small",
      "button--medium": this.size === "medium",
      "button--large": this.size === "large",
      "button--caret": this.caret,
      "button--circle": this.circle,
      "button--disabled": this.disabled,
      "button--focused": this.hasFocus,
      "button--loading": this.loading,
      "button--standard": !this.outline,
      "button--outline": this.outline,
      "button--pill": this.pill,
      "button--rtl": this.localize.dir() === "rtl",
      "button--has-label": this.hasSlotController.test("[default]"),
      "button--has-prefix": this.hasSlotController.test("prefix"),
      "button--has-suffix": this.hasSlotController.test("suffix")
    })}
        ?disabled=${I(r ? void 0 : this.disabled)}
        type=${I(r ? void 0 : this.type)}
        title=${this.title}
        name=${I(r ? void 0 : this.name)}
        value=${I(r ? void 0 : this.value)}
        href=${I(r ? this.href : void 0)}
        target=${I(r ? this.target : void 0)}
        download=${I(r ? this.download : void 0)}
        rel=${I(r ? this.rel : void 0)}
        role=${I(r ? void 0 : "button")}
        aria-disabled=${this.disabled ? "true" : "false"}
        tabindex=${this.disabled ? "-1" : "0"}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @invalid=${this.isButton() ? this.handleInvalid : null}
        @click=${this.handleClick}
      >
        <slot name="prefix" part="prefix" class="button__prefix"></slot>
        <slot part="label" class="button__label"></slot>
        <slot name="suffix" part="suffix" class="button__suffix"></slot>
        ${this.caret ? lo` <sl-icon part="caret" class="button__caret" library="system" name="caret"></sl-icon> ` : ""}
        ${this.loading ? lo`<sl-spinner part="spinner"></sl-spinner>` : ""}
      </${e}>
    `;
  }
};
ee.styles = qb;
ee.dependencies = {
  "sl-icon": vt,
  "sl-spinner": eO
};
w([
  J(".button")
], ee.prototype, "button", 2);
w([
  De()
], ee.prototype, "hasFocus", 2);
w([
  De()
], ee.prototype, "invalid", 2);
w([
  y()
], ee.prototype, "title", 2);
w([
  y({ reflect: !0 })
], ee.prototype, "variant", 2);
w([
  y({ reflect: !0 })
], ee.prototype, "size", 2);
w([
  y({ type: Boolean, reflect: !0 })
], ee.prototype, "caret", 2);
w([
  y({ type: Boolean, reflect: !0 })
], ee.prototype, "disabled", 2);
w([
  y({ type: Boolean, reflect: !0 })
], ee.prototype, "loading", 2);
w([
  y({ type: Boolean, reflect: !0 })
], ee.prototype, "outline", 2);
w([
  y({ type: Boolean, reflect: !0 })
], ee.prototype, "pill", 2);
w([
  y({ type: Boolean, reflect: !0 })
], ee.prototype, "circle", 2);
w([
  y()
], ee.prototype, "type", 2);
w([
  y()
], ee.prototype, "name", 2);
w([
  y()
], ee.prototype, "value", 2);
w([
  y()
], ee.prototype, "href", 2);
w([
  y()
], ee.prototype, "target", 2);
w([
  y()
], ee.prototype, "rel", 2);
w([
  y()
], ee.prototype, "download", 2);
w([
  y()
], ee.prototype, "form", 2);
w([
  y({ attribute: "formaction" })
], ee.prototype, "formAction", 2);
w([
  y({ attribute: "formenctype" })
], ee.prototype, "formEnctype", 2);
w([
  y({ attribute: "formmethod" })
], ee.prototype, "formMethod", 2);
w([
  y({ attribute: "formnovalidate", type: Boolean })
], ee.prototype, "formNoValidate", 2);
w([
  y({ attribute: "formtarget" })
], ee.prototype, "formTarget", 2);
w([
  $e("disabled", { waitUntilFirstUpdate: !0 })
], ee.prototype, "handleDisabledChange", 1);
var SZ = ee;
ee.define("sl-button");
var Kb = re`
  ${We}

  :host {
    display: inline-block;
  }

  .dropdown::part(popup) {
    z-index: var(--sl-z-index-dropdown);
  }

  .dropdown[data-current-placement^='top']::part(popup) {
    transform-origin: bottom;
  }

  .dropdown[data-current-placement^='bottom']::part(popup) {
    transform-origin: top;
  }

  .dropdown[data-current-placement^='left']::part(popup) {
    transform-origin: right;
  }

  .dropdown[data-current-placement^='right']::part(popup) {
    transform-origin: left;
  }

  .dropdown__trigger {
    display: block;
  }

  .dropdown__panel {
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    box-shadow: var(--sl-shadow-large);
    border-radius: var(--sl-border-radius-medium);
    pointer-events: none;
  }

  .dropdown--open .dropdown__panel {
    display: block;
    pointer-events: all;
  }

  /* When users slot a menu, make sure it conforms to the popup's auto-size */
  ::slotted(sl-menu) {
    max-width: var(--auto-size-available-width) !important;
    max-height: var(--auto-size-available-height) !important;
  }
`;
function Jb(r) {
  return !!(r.offsetParent || r.offsetWidth || r.offsetHeight || r.getClientRects().length);
}
function ew(r) {
  const e = r.tagName.toLowerCase();
  return r.getAttribute("tabindex") === "-1" || r.hasAttribute("disabled") || e === "input" && r.getAttribute("type") === "radio" && !r.hasAttribute("checked") || !Jb(r) || window.getComputedStyle(r).visibility === "hidden" ? !1 : (e === "audio" || e === "video") && r.hasAttribute("controls") || r.hasAttribute("tabindex") || r.hasAttribute("contenteditable") && r.getAttribute("contenteditable") !== "false" ? !0 : ["button", "input", "select", "textarea", "a", "audio", "video", "summary"].includes(e);
}
function tw(r) {
  var e, t;
  const i = rw(r), n = (e = i[0]) != null ? e : null, s = (t = i[i.length - 1]) != null ? t : null;
  return { start: n, end: s };
}
function rw(r) {
  const e = [];
  function t(i) {
    if (i instanceof Element) {
      if (i.hasAttribute("inert"))
        return;
      !e.includes(i) && ew(i) && e.push(i);
      const n = (s) => {
        var o;
        return ((o = s.getRootNode({ composed: !0 })) == null ? void 0 : o.host) !== r;
      };
      i instanceof HTMLSlotElement && n(i) && i.assignedElements({ flatten: !0 }).forEach((s) => {
        t(s);
      }), i.shadowRoot !== null && i.shadowRoot.mode === "open" && t(i.shadowRoot);
    }
    [...i.children].forEach((n) => t(n));
  }
  return t(r), e.sort((i, n) => {
    const s = Number(i.getAttribute("tabindex")) || 0;
    return (Number(n.getAttribute("tabindex")) || 0) - s;
  });
}
var iw = re`
  ${We}

  :host {
    --arrow-color: var(--sl-color-neutral-1000);
    --arrow-size: 6px;

    /*
     * These properties are computed to account for the arrow's dimensions after being rotated 45º. The constant
     * 0.7071 is derived from sin(45), which is the diagonal size of the arrow's container after rotating.
     */
    --arrow-size-diagonal: calc(var(--arrow-size) * 0.7071);
    --arrow-padding-offset: calc(var(--arrow-size-diagonal) - var(--arrow-size));

    display: contents;
  }

  .popup {
    position: absolute;
    isolation: isolate;
    max-width: var(--auto-size-available-width, none);
    max-height: var(--auto-size-available-height, none);
  }

  .popup--fixed {
    position: fixed;
  }

  .popup:not(.popup--active) {
    display: none;
  }

  .popup__arrow {
    position: absolute;
    width: calc(var(--arrow-size-diagonal) * 2);
    height: calc(var(--arrow-size-diagonal) * 2);
    rotate: 45deg;
    background: var(--arrow-color);
    z-index: -1;
  }
`;
const Zr = Math.min, tt = Math.max, $o = Math.round, _s = Math.floor, _r = (r) => ({
  x: r,
  y: r
}), nw = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, sw = {
  start: "end",
  end: "start"
};
function za(r, e, t) {
  return tt(r, Zr(e, t));
}
function Ki(r, e) {
  return typeof r == "function" ? r(e) : r;
}
function Rr(r) {
  return r.split("-")[0];
}
function Ji(r) {
  return r.split("-")[1];
}
function iO(r) {
  return r === "x" ? "y" : "x";
}
function ic(r) {
  return r === "y" ? "height" : "width";
}
function gs(r) {
  return ["top", "bottom"].includes(Rr(r)) ? "y" : "x";
}
function nc(r) {
  return iO(gs(r));
}
function ow(r, e, t) {
  t === void 0 && (t = !1);
  const i = Ji(r), n = nc(r), s = ic(n);
  let o = n === "x" ? i === (t ? "end" : "start") ? "right" : "left" : i === "start" ? "bottom" : "top";
  return e.reference[s] > e.floating[s] && (o = Qo(o)), [o, Qo(o)];
}
function lw(r) {
  const e = Qo(r);
  return [Ya(r), e, Ya(e)];
}
function Ya(r) {
  return r.replace(/start|end/g, (e) => sw[e]);
}
function aw(r, e, t) {
  const i = ["left", "right"], n = ["right", "left"], s = ["top", "bottom"], o = ["bottom", "top"];
  switch (r) {
    case "top":
    case "bottom":
      return t ? e ? n : i : e ? i : n;
    case "left":
    case "right":
      return e ? s : o;
    default:
      return [];
  }
}
function hw(r, e, t, i) {
  const n = Ji(r);
  let s = aw(Rr(r), t === "start", i);
  return n && (s = s.map((o) => o + "-" + n), e && (s = s.concat(s.map(Ya)))), s;
}
function Qo(r) {
  return r.replace(/left|right|bottom|top/g, (e) => nw[e]);
}
function cw(r) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...r
  };
}
function nO(r) {
  return typeof r != "number" ? cw(r) : {
    top: r,
    right: r,
    bottom: r,
    left: r
  };
}
function Po(r) {
  return {
    ...r,
    top: r.y,
    left: r.x,
    right: r.x + r.width,
    bottom: r.y + r.height
  };
}
function _u(r, e, t) {
  let {
    reference: i,
    floating: n
  } = r;
  const s = gs(e), o = nc(e), l = ic(o), a = Rr(e), h = s === "y", c = i.x + i.width / 2 - n.width / 2, u = i.y + i.height / 2 - n.height / 2, d = i[l] / 2 - n[l] / 2;
  let p;
  switch (a) {
    case "top":
      p = {
        x: c,
        y: i.y - n.height
      };
      break;
    case "bottom":
      p = {
        x: c,
        y: i.y + i.height
      };
      break;
    case "right":
      p = {
        x: i.x + i.width,
        y: u
      };
      break;
    case "left":
      p = {
        x: i.x - n.width,
        y: u
      };
      break;
    default:
      p = {
        x: i.x,
        y: i.y
      };
  }
  switch (Ji(e)) {
    case "start":
      p[o] -= d * (t && h ? -1 : 1);
      break;
    case "end":
      p[o] += d * (t && h ? -1 : 1);
      break;
  }
  return p;
}
const uw = async (r, e, t) => {
  const {
    placement: i = "bottom",
    strategy: n = "absolute",
    middleware: s = [],
    platform: o
  } = t, l = s.filter(Boolean), a = await (o.isRTL == null ? void 0 : o.isRTL(e));
  let h = await o.getElementRects({
    reference: r,
    floating: e,
    strategy: n
  }), {
    x: c,
    y: u
  } = _u(h, i, a), d = i, p = {}, f = 0;
  for (let m = 0; m < l.length; m++) {
    const {
      name: g,
      fn: b
    } = l[m], {
      x: v,
      y: k,
      data: $,
      reset: x
    } = await b({
      x: c,
      y: u,
      initialPlacement: i,
      placement: d,
      strategy: n,
      middlewareData: p,
      rects: h,
      platform: o,
      elements: {
        reference: r,
        floating: e
      }
    });
    if (c = v ?? c, u = k ?? u, p = {
      ...p,
      [g]: {
        ...p[g],
        ...$
      }
    }, x && f <= 50) {
      f++, typeof x == "object" && (x.placement && (d = x.placement), x.rects && (h = x.rects === !0 ? await o.getElementRects({
        reference: r,
        floating: e,
        strategy: n
      }) : x.rects), {
        x: c,
        y: u
      } = _u(h, d, a)), m = -1;
      continue;
    }
  }
  return {
    x: c,
    y: u,
    placement: d,
    strategy: n,
    middlewareData: p
  };
};
async function sc(r, e) {
  var t;
  e === void 0 && (e = {});
  const {
    x: i,
    y: n,
    platform: s,
    rects: o,
    elements: l,
    strategy: a
  } = r, {
    boundary: h = "clippingAncestors",
    rootBoundary: c = "viewport",
    elementContext: u = "floating",
    altBoundary: d = !1,
    padding: p = 0
  } = Ki(e, r), f = nO(p), g = l[d ? u === "floating" ? "reference" : "floating" : u], b = Po(await s.getClippingRect({
    element: (t = await (s.isElement == null ? void 0 : s.isElement(g))) == null || t ? g : g.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(l.floating)),
    boundary: h,
    rootBoundary: c,
    strategy: a
  })), v = u === "floating" ? {
    ...o.floating,
    x: i,
    y: n
  } : o.reference, k = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(l.floating)), $ = await (s.isElement == null ? void 0 : s.isElement(k)) ? await (s.getScale == null ? void 0 : s.getScale(k)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, x = Po(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect: v,
    offsetParent: k,
    strategy: a
  }) : v);
  return {
    top: (b.top - x.top + f.top) / $.y,
    bottom: (x.bottom - b.bottom + f.bottom) / $.y,
    left: (b.left - x.left + f.left) / $.x,
    right: (x.right - b.right + f.right) / $.x
  };
}
const dw = (r) => ({
  name: "arrow",
  options: r,
  async fn(e) {
    const {
      x: t,
      y: i,
      placement: n,
      rects: s,
      platform: o,
      elements: l,
      middlewareData: a
    } = e, {
      element: h,
      padding: c = 0
    } = Ki(r, e) || {};
    if (h == null)
      return {};
    const u = nO(c), d = {
      x: t,
      y: i
    }, p = nc(n), f = ic(p), m = await o.getDimensions(h), g = p === "y", b = g ? "top" : "left", v = g ? "bottom" : "right", k = g ? "clientHeight" : "clientWidth", $ = s.reference[f] + s.reference[p] - d[p] - s.floating[f], x = d[p] - s.reference[p], Q = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(h));
    let P = Q ? Q[k] : 0;
    (!P || !await (o.isElement == null ? void 0 : o.isElement(Q))) && (P = l.floating[k] || s.floating[f]);
    const z = $ / 2 - x / 2, V = P / 2 - m[f] / 2 - 1, L = Zr(u[b], V), M = Zr(u[v], V), q = L, F = P - m[f] - M, W = P / 2 - m[f] / 2 + z, G = za(q, W, F), le = !a.arrow && Ji(n) != null && W != G && s.reference[f] / 2 - (W < q ? L : M) - m[f] / 2 < 0, ue = le ? W < q ? W - q : W - F : 0;
    return {
      [p]: d[p] + ue,
      data: {
        [p]: G,
        centerOffset: W - G - ue,
        ...le && {
          alignmentOffset: ue
        }
      },
      reset: le
    };
  }
}), pw = function(r) {
  return r === void 0 && (r = {}), {
    name: "flip",
    options: r,
    async fn(e) {
      var t, i;
      const {
        placement: n,
        middlewareData: s,
        rects: o,
        initialPlacement: l,
        platform: a,
        elements: h
      } = e, {
        mainAxis: c = !0,
        crossAxis: u = !0,
        fallbackPlacements: d,
        fallbackStrategy: p = "bestFit",
        fallbackAxisSideDirection: f = "none",
        flipAlignment: m = !0,
        ...g
      } = Ki(r, e);
      if ((t = s.arrow) != null && t.alignmentOffset)
        return {};
      const b = Rr(n), v = Rr(l) === l, k = await (a.isRTL == null ? void 0 : a.isRTL(h.floating)), $ = d || (v || !m ? [Qo(l)] : lw(l));
      !d && f !== "none" && $.push(...hw(l, m, f, k));
      const x = [l, ...$], Q = await sc(e, g), P = [];
      let z = ((i = s.flip) == null ? void 0 : i.overflows) || [];
      if (c && P.push(Q[b]), u) {
        const q = ow(n, o, k);
        P.push(Q[q[0]], Q[q[1]]);
      }
      if (z = [...z, {
        placement: n,
        overflows: P
      }], !P.every((q) => q <= 0)) {
        var V, L;
        const q = (((V = s.flip) == null ? void 0 : V.index) || 0) + 1, F = x[q];
        if (F)
          return {
            data: {
              index: q,
              overflows: z
            },
            reset: {
              placement: F
            }
          };
        let W = (L = z.filter((G) => G.overflows[0] <= 0).sort((G, le) => G.overflows[1] - le.overflows[1])[0]) == null ? void 0 : L.placement;
        if (!W)
          switch (p) {
            case "bestFit": {
              var M;
              const G = (M = z.map((le) => [le.placement, le.overflows.filter((ue) => ue > 0).reduce((ue, Me) => ue + Me, 0)]).sort((le, ue) => le[1] - ue[1])[0]) == null ? void 0 : M[0];
              G && (W = G);
              break;
            }
            case "initialPlacement":
              W = l;
              break;
          }
        if (n !== W)
          return {
            reset: {
              placement: W
            }
          };
      }
      return {};
    }
  };
};
async function fw(r, e) {
  const {
    placement: t,
    platform: i,
    elements: n
  } = r, s = await (i.isRTL == null ? void 0 : i.isRTL(n.floating)), o = Rr(t), l = Ji(t), a = gs(t) === "y", h = ["left", "top"].includes(o) ? -1 : 1, c = s && a ? -1 : 1, u = Ki(e, r);
  let {
    mainAxis: d,
    crossAxis: p,
    alignmentAxis: f
  } = typeof u == "number" ? {
    mainAxis: u,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...u
  };
  return l && typeof f == "number" && (p = l === "end" ? f * -1 : f), a ? {
    x: p * c,
    y: d * h
  } : {
    x: d * h,
    y: p * c
  };
}
const Ow = function(r) {
  return r === void 0 && (r = 0), {
    name: "offset",
    options: r,
    async fn(e) {
      var t, i;
      const {
        x: n,
        y: s,
        placement: o,
        middlewareData: l
      } = e, a = await fw(e, r);
      return o === ((t = l.offset) == null ? void 0 : t.placement) && (i = l.arrow) != null && i.alignmentOffset ? {} : {
        x: n + a.x,
        y: s + a.y,
        data: {
          ...a,
          placement: o
        }
      };
    }
  };
}, mw = function(r) {
  return r === void 0 && (r = {}), {
    name: "shift",
    options: r,
    async fn(e) {
      const {
        x: t,
        y: i,
        placement: n
      } = e, {
        mainAxis: s = !0,
        crossAxis: o = !1,
        limiter: l = {
          fn: (g) => {
            let {
              x: b,
              y: v
            } = g;
            return {
              x: b,
              y: v
            };
          }
        },
        ...a
      } = Ki(r, e), h = {
        x: t,
        y: i
      }, c = await sc(e, a), u = gs(Rr(n)), d = iO(u);
      let p = h[d], f = h[u];
      if (s) {
        const g = d === "y" ? "top" : "left", b = d === "y" ? "bottom" : "right", v = p + c[g], k = p - c[b];
        p = za(v, p, k);
      }
      if (o) {
        const g = u === "y" ? "top" : "left", b = u === "y" ? "bottom" : "right", v = f + c[g], k = f - c[b];
        f = za(v, f, k);
      }
      const m = l.fn({
        ...e,
        [d]: p,
        [u]: f
      });
      return {
        ...m,
        data: {
          x: m.x - t,
          y: m.y - i
        }
      };
    }
  };
}, gw = function(r) {
  return r === void 0 && (r = {}), {
    name: "size",
    options: r,
    async fn(e) {
      const {
        placement: t,
        rects: i,
        platform: n,
        elements: s
      } = e, {
        apply: o = () => {
        },
        ...l
      } = Ki(r, e), a = await sc(e, l), h = Rr(t), c = Ji(t), u = gs(t) === "y", {
        width: d,
        height: p
      } = i.floating;
      let f, m;
      h === "top" || h === "bottom" ? (f = h, m = c === (await (n.isRTL == null ? void 0 : n.isRTL(s.floating)) ? "start" : "end") ? "left" : "right") : (m = h, f = c === "end" ? "top" : "bottom");
      const g = p - a[f], b = d - a[m], v = !e.middlewareData.shift;
      let k = g, $ = b;
      if (u) {
        const Q = d - a.left - a.right;
        $ = c || v ? Zr(b, Q) : Q;
      } else {
        const Q = p - a.top - a.bottom;
        k = c || v ? Zr(g, Q) : Q;
      }
      if (v && !c) {
        const Q = tt(a.left, 0), P = tt(a.right, 0), z = tt(a.top, 0), V = tt(a.bottom, 0);
        u ? $ = d - 2 * (Q !== 0 || P !== 0 ? Q + P : tt(a.left, a.right)) : k = p - 2 * (z !== 0 || V !== 0 ? z + V : tt(a.top, a.bottom));
      }
      await o({
        ...e,
        availableWidth: $,
        availableHeight: k
      });
      const x = await n.getDimensions(s.floating);
      return d !== x.width || p !== x.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function Ar(r) {
  return sO(r) ? (r.nodeName || "").toLowerCase() : "#document";
}
function ot(r) {
  var e;
  return (r == null || (e = r.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function dr(r) {
  var e;
  return (e = (sO(r) ? r.ownerDocument : r.document) || window.document) == null ? void 0 : e.documentElement;
}
function sO(r) {
  return r instanceof Node || r instanceof ot(r).Node;
}
function nr(r) {
  return r instanceof Element || r instanceof ot(r).Element;
}
function Gt(r) {
  return r instanceof HTMLElement || r instanceof ot(r).HTMLElement;
}
function Ru(r) {
  return typeof ShadowRoot > "u" ? !1 : r instanceof ShadowRoot || r instanceof ot(r).ShadowRoot;
}
function bs(r) {
  const {
    overflow: e,
    overflowX: t,
    overflowY: i,
    display: n
  } = yt(r);
  return /auto|scroll|overlay|hidden|clip/.test(e + i + t) && !["inline", "contents"].includes(n);
}
function bw(r) {
  return ["table", "td", "th"].includes(Ar(r));
}
function oc(r) {
  const e = lc(), t = yt(r);
  return t.transform !== "none" || t.perspective !== "none" || (t.containerType ? t.containerType !== "normal" : !1) || !e && (t.backdropFilter ? t.backdropFilter !== "none" : !1) || !e && (t.filter ? t.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((i) => (t.willChange || "").includes(i)) || ["paint", "layout", "strict", "content"].some((i) => (t.contain || "").includes(i));
}
function ww(r) {
  let e = Yi(r);
  for (; Gt(e) && !cl(e); ) {
    if (oc(e))
      return e;
    e = Yi(e);
  }
  return null;
}
function lc() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function cl(r) {
  return ["html", "body", "#document"].includes(Ar(r));
}
function yt(r) {
  return ot(r).getComputedStyle(r);
}
function ul(r) {
  return nr(r) ? {
    scrollLeft: r.scrollLeft,
    scrollTop: r.scrollTop
  } : {
    scrollLeft: r.pageXOffset,
    scrollTop: r.pageYOffset
  };
}
function Yi(r) {
  if (Ar(r) === "html")
    return r;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    r.assignedSlot || // DOM Element detected.
    r.parentNode || // ShadowRoot detected.
    Ru(r) && r.host || // Fallback.
    dr(r)
  );
  return Ru(e) ? e.host : e;
}
function oO(r) {
  const e = Yi(r);
  return cl(e) ? r.ownerDocument ? r.ownerDocument.body : r.body : Gt(e) && bs(e) ? e : oO(e);
}
function Dn(r, e, t) {
  var i;
  e === void 0 && (e = []), t === void 0 && (t = !0);
  const n = oO(r), s = n === ((i = r.ownerDocument) == null ? void 0 : i.body), o = ot(n);
  return s ? e.concat(o, o.visualViewport || [], bs(n) ? n : [], o.frameElement && t ? Dn(o.frameElement) : []) : e.concat(n, Dn(n, [], t));
}
function lO(r) {
  const e = yt(r);
  let t = parseFloat(e.width) || 0, i = parseFloat(e.height) || 0;
  const n = Gt(r), s = n ? r.offsetWidth : t, o = n ? r.offsetHeight : i, l = $o(t) !== s || $o(i) !== o;
  return l && (t = s, i = o), {
    width: t,
    height: i,
    $: l
  };
}
function ac(r) {
  return nr(r) ? r : r.contextElement;
}
function Ti(r) {
  const e = ac(r);
  if (!Gt(e))
    return _r(1);
  const t = e.getBoundingClientRect(), {
    width: i,
    height: n,
    $: s
  } = lO(e);
  let o = (s ? $o(t.width) : t.width) / i, l = (s ? $o(t.height) : t.height) / n;
  return (!o || !Number.isFinite(o)) && (o = 1), (!l || !Number.isFinite(l)) && (l = 1), {
    x: o,
    y: l
  };
}
const yw = /* @__PURE__ */ _r(0);
function aO(r) {
  const e = ot(r);
  return !lc() || !e.visualViewport ? yw : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function vw(r, e, t) {
  return e === void 0 && (e = !1), !t || e && t !== ot(r) ? !1 : e;
}
function hi(r, e, t, i) {
  e === void 0 && (e = !1), t === void 0 && (t = !1);
  const n = r.getBoundingClientRect(), s = ac(r);
  let o = _r(1);
  e && (i ? nr(i) && (o = Ti(i)) : o = Ti(r));
  const l = vw(s, t, i) ? aO(s) : _r(0);
  let a = (n.left + l.x) / o.x, h = (n.top + l.y) / o.y, c = n.width / o.x, u = n.height / o.y;
  if (s) {
    const d = ot(s), p = i && nr(i) ? ot(i) : i;
    let f = d.frameElement;
    for (; f && i && p !== d; ) {
      const m = Ti(f), g = f.getBoundingClientRect(), b = yt(f), v = g.left + (f.clientLeft + parseFloat(b.paddingLeft)) * m.x, k = g.top + (f.clientTop + parseFloat(b.paddingTop)) * m.y;
      a *= m.x, h *= m.y, c *= m.x, u *= m.y, a += v, h += k, f = ot(f).frameElement;
    }
  }
  return Po({
    width: c,
    height: u,
    x: a,
    y: h
  });
}
function xw(r) {
  let {
    rect: e,
    offsetParent: t,
    strategy: i
  } = r;
  const n = Gt(t), s = dr(t);
  if (t === s)
    return e;
  let o = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = _r(1);
  const a = _r(0);
  if ((n || !n && i !== "fixed") && ((Ar(t) !== "body" || bs(s)) && (o = ul(t)), Gt(t))) {
    const h = hi(t);
    l = Ti(t), a.x = h.x + t.clientLeft, a.y = h.y + t.clientTop;
  }
  return {
    width: e.width * l.x,
    height: e.height * l.y,
    x: e.x * l.x - o.scrollLeft * l.x + a.x,
    y: e.y * l.y - o.scrollTop * l.y + a.y
  };
}
function Sw(r) {
  return Array.from(r.getClientRects());
}
function hO(r) {
  return hi(dr(r)).left + ul(r).scrollLeft;
}
function kw(r) {
  const e = dr(r), t = ul(r), i = r.ownerDocument.body, n = tt(e.scrollWidth, e.clientWidth, i.scrollWidth, i.clientWidth), s = tt(e.scrollHeight, e.clientHeight, i.scrollHeight, i.clientHeight);
  let o = -t.scrollLeft + hO(r);
  const l = -t.scrollTop;
  return yt(i).direction === "rtl" && (o += tt(e.clientWidth, i.clientWidth) - n), {
    width: n,
    height: s,
    x: o,
    y: l
  };
}
function $w(r, e) {
  const t = ot(r), i = dr(r), n = t.visualViewport;
  let s = i.clientWidth, o = i.clientHeight, l = 0, a = 0;
  if (n) {
    s = n.width, o = n.height;
    const h = lc();
    (!h || h && e === "fixed") && (l = n.offsetLeft, a = n.offsetTop);
  }
  return {
    width: s,
    height: o,
    x: l,
    y: a
  };
}
function Qw(r, e) {
  const t = hi(r, !0, e === "fixed"), i = t.top + r.clientTop, n = t.left + r.clientLeft, s = Gt(r) ? Ti(r) : _r(1), o = r.clientWidth * s.x, l = r.clientHeight * s.y, a = n * s.x, h = i * s.y;
  return {
    width: o,
    height: l,
    x: a,
    y: h
  };
}
function Au(r, e, t) {
  let i;
  if (e === "viewport")
    i = $w(r, t);
  else if (e === "document")
    i = kw(dr(r));
  else if (nr(e))
    i = Qw(e, t);
  else {
    const n = aO(r);
    i = {
      ...e,
      x: e.x - n.x,
      y: e.y - n.y
    };
  }
  return Po(i);
}
function cO(r, e) {
  const t = Yi(r);
  return t === e || !nr(t) || cl(t) ? !1 : yt(t).position === "fixed" || cO(t, e);
}
function Pw(r, e) {
  const t = e.get(r);
  if (t)
    return t;
  let i = Dn(r, [], !1).filter((l) => nr(l) && Ar(l) !== "body"), n = null;
  const s = yt(r).position === "fixed";
  let o = s ? Yi(r) : r;
  for (; nr(o) && !cl(o); ) {
    const l = yt(o), a = oc(o);
    !a && l.position === "fixed" && (n = null), (s ? !a && !n : !a && l.position === "static" && !!n && ["absolute", "fixed"].includes(n.position) || bs(o) && !a && cO(r, o)) ? i = i.filter((c) => c !== o) : n = l, o = Yi(o);
  }
  return e.set(r, i), i;
}
function Tw(r) {
  let {
    element: e,
    boundary: t,
    rootBoundary: i,
    strategy: n
  } = r;
  const o = [...t === "clippingAncestors" ? Pw(e, this._c) : [].concat(t), i], l = o[0], a = o.reduce((h, c) => {
    const u = Au(e, c, n);
    return h.top = tt(u.top, h.top), h.right = Zr(u.right, h.right), h.bottom = Zr(u.bottom, h.bottom), h.left = tt(u.left, h.left), h;
  }, Au(e, l, n));
  return {
    width: a.right - a.left,
    height: a.bottom - a.top,
    x: a.left,
    y: a.top
  };
}
function Cw(r) {
  const {
    width: e,
    height: t
  } = lO(r);
  return {
    width: e,
    height: t
  };
}
function Xw(r, e, t) {
  const i = Gt(e), n = dr(e), s = t === "fixed", o = hi(r, !0, s, e);
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const a = _r(0);
  if (i || !i && !s)
    if ((Ar(e) !== "body" || bs(n)) && (l = ul(e)), i) {
      const h = hi(e, !0, s, e);
      a.x = h.x + e.clientLeft, a.y = h.y + e.clientTop;
    } else
      n && (a.x = hO(n));
  return {
    x: o.left + l.scrollLeft - a.x,
    y: o.top + l.scrollTop - a.y,
    width: o.width,
    height: o.height
  };
}
function Eu(r, e) {
  return !Gt(r) || yt(r).position === "fixed" ? null : e ? e(r) : r.offsetParent;
}
function uO(r, e) {
  const t = ot(r);
  if (!Gt(r))
    return t;
  let i = Eu(r, e);
  for (; i && bw(i) && yt(i).position === "static"; )
    i = Eu(i, e);
  return i && (Ar(i) === "html" || Ar(i) === "body" && yt(i).position === "static" && !oc(i)) ? t : i || ww(r) || t;
}
const Zw = async function(r) {
  let {
    reference: e,
    floating: t,
    strategy: i
  } = r;
  const n = this.getOffsetParent || uO, s = this.getDimensions;
  return {
    reference: Xw(e, await n(t), i),
    floating: {
      x: 0,
      y: 0,
      ...await s(t)
    }
  };
};
function _w(r) {
  return yt(r).direction === "rtl";
}
const ao = {
  convertOffsetParentRelativeRectToViewportRelativeRect: xw,
  getDocumentElement: dr,
  getClippingRect: Tw,
  getOffsetParent: uO,
  getElementRects: Zw,
  getClientRects: Sw,
  getDimensions: Cw,
  getScale: Ti,
  isElement: nr,
  isRTL: _w
};
function Rw(r, e) {
  let t = null, i;
  const n = dr(r);
  function s() {
    clearTimeout(i), t && t.disconnect(), t = null;
  }
  function o(l, a) {
    l === void 0 && (l = !1), a === void 0 && (a = 1), s();
    const {
      left: h,
      top: c,
      width: u,
      height: d
    } = r.getBoundingClientRect();
    if (l || e(), !u || !d)
      return;
    const p = _s(c), f = _s(n.clientWidth - (h + u)), m = _s(n.clientHeight - (c + d)), g = _s(h), v = {
      rootMargin: -p + "px " + -f + "px " + -m + "px " + -g + "px",
      threshold: tt(0, Zr(1, a)) || 1
    };
    let k = !0;
    function $(x) {
      const Q = x[0].intersectionRatio;
      if (Q !== a) {
        if (!k)
          return o();
        Q ? o(!1, Q) : i = setTimeout(() => {
          o(!1, 1e-7);
        }, 100);
      }
      k = !1;
    }
    try {
      t = new IntersectionObserver($, {
        ...v,
        // Handle <iframe>s
        root: n.ownerDocument
      });
    } catch {
      t = new IntersectionObserver($, v);
    }
    t.observe(r);
  }
  return o(!0), s;
}
function Aw(r, e, t, i) {
  i === void 0 && (i = {});
  const {
    ancestorScroll: n = !0,
    ancestorResize: s = !0,
    elementResize: o = typeof ResizeObserver == "function",
    layoutShift: l = typeof IntersectionObserver == "function",
    animationFrame: a = !1
  } = i, h = ac(r), c = n || s ? [...h ? Dn(h) : [], ...Dn(e)] : [];
  c.forEach((b) => {
    n && b.addEventListener("scroll", t, {
      passive: !0
    }), s && b.addEventListener("resize", t);
  });
  const u = h && l ? Rw(h, t) : null;
  let d = -1, p = null;
  o && (p = new ResizeObserver((b) => {
    let [v] = b;
    v && v.target === h && p && (p.unobserve(e), cancelAnimationFrame(d), d = requestAnimationFrame(() => {
      p && p.observe(e);
    })), t();
  }), h && !a && p.observe(h), p.observe(e));
  let f, m = a ? hi(r) : null;
  a && g();
  function g() {
    const b = hi(r);
    m && (b.x !== m.x || b.y !== m.y || b.width !== m.width || b.height !== m.height) && t(), m = b, f = requestAnimationFrame(g);
  }
  return t(), () => {
    c.forEach((b) => {
      n && b.removeEventListener("scroll", t), s && b.removeEventListener("resize", t);
    }), u && u(), p && p.disconnect(), p = null, a && cancelAnimationFrame(f);
  };
}
const Ew = mw, qw = pw, qu = gw, zw = dw, Yw = (r, e, t) => {
  const i = /* @__PURE__ */ new Map(), n = {
    platform: ao,
    ...t
  }, s = {
    ...n.platform,
    _c: i
  };
  return uw(r, e, {
    ...n,
    platform: s
  });
};
function Ww(r) {
  return Vw(r);
}
function jl(r) {
  return r.assignedSlot ? r.assignedSlot : r.parentNode instanceof ShadowRoot ? r.parentNode.host : r.parentNode;
}
function Vw(r) {
  for (let e = r; e; e = jl(e))
    if (e instanceof Element && getComputedStyle(e).display === "none")
      return null;
  for (let e = jl(r); e; e = jl(e)) {
    if (!(e instanceof Element))
      continue;
    const t = getComputedStyle(e);
    if (t.display !== "contents" && (t.position !== "static" || t.filter !== "none" || e.tagName === "BODY"))
      return e;
  }
  return null;
}
function Mw(r) {
  return r !== null && typeof r == "object" && "getBoundingClientRect" in r;
}
var se = class extends ve {
  constructor() {
    super(...arguments), this.active = !1, this.placement = "top", this.strategy = "absolute", this.distance = 0, this.skidding = 0, this.arrow = !1, this.arrowPlacement = "anchor", this.arrowPadding = 10, this.flip = !1, this.flipFallbackPlacements = "", this.flipFallbackStrategy = "best-fit", this.flipPadding = 0, this.shift = !1, this.shiftPadding = 0, this.autoSizePadding = 0;
  }
  async connectedCallback() {
    super.connectedCallback(), await this.updateComplete, this.start();
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.stop();
  }
  async updated(r) {
    super.updated(r), r.has("active") && (this.active ? this.start() : this.stop()), r.has("anchor") && this.handleAnchorChange(), this.active && (await this.updateComplete, this.reposition());
  }
  async handleAnchorChange() {
    if (await this.stop(), this.anchor && typeof this.anchor == "string") {
      const r = this.getRootNode();
      this.anchorEl = r.getElementById(this.anchor);
    } else
      this.anchor instanceof Element || Mw(this.anchor) ? this.anchorEl = this.anchor : this.anchorEl = this.querySelector('[slot="anchor"]');
    this.anchorEl instanceof HTMLSlotElement && (this.anchorEl = this.anchorEl.assignedElements({ flatten: !0 })[0]), this.anchorEl && this.start();
  }
  start() {
    this.anchorEl && (this.cleanup = Aw(this.anchorEl, this.popup, () => {
      this.reposition();
    }));
  }
  async stop() {
    return new Promise((r) => {
      this.cleanup ? (this.cleanup(), this.cleanup = void 0, this.removeAttribute("data-current-placement"), this.style.removeProperty("--auto-size-available-width"), this.style.removeProperty("--auto-size-available-height"), requestAnimationFrame(() => r())) : r();
    });
  }
  /** Forces the popup to recalculate and reposition itself. */
  reposition() {
    if (!this.active || !this.anchorEl)
      return;
    const r = [
      // The offset middleware goes first
      Ow({ mainAxis: this.distance, crossAxis: this.skidding })
    ];
    this.sync ? r.push(
      qu({
        apply: ({ rects: t }) => {
          const i = this.sync === "width" || this.sync === "both", n = this.sync === "height" || this.sync === "both";
          this.popup.style.width = i ? `${t.reference.width}px` : "", this.popup.style.height = n ? `${t.reference.height}px` : "";
        }
      })
    ) : (this.popup.style.width = "", this.popup.style.height = ""), this.flip && r.push(
      qw({
        boundary: this.flipBoundary,
        // @ts-expect-error - We're converting a string attribute to an array here
        fallbackPlacements: this.flipFallbackPlacements,
        fallbackStrategy: this.flipFallbackStrategy === "best-fit" ? "bestFit" : "initialPlacement",
        padding: this.flipPadding
      })
    ), this.shift && r.push(
      Ew({
        boundary: this.shiftBoundary,
        padding: this.shiftPadding
      })
    ), this.autoSize ? r.push(
      qu({
        boundary: this.autoSizeBoundary,
        padding: this.autoSizePadding,
        apply: ({ availableWidth: t, availableHeight: i }) => {
          this.autoSize === "vertical" || this.autoSize === "both" ? this.style.setProperty("--auto-size-available-height", `${i}px`) : this.style.removeProperty("--auto-size-available-height"), this.autoSize === "horizontal" || this.autoSize === "both" ? this.style.setProperty("--auto-size-available-width", `${t}px`) : this.style.removeProperty("--auto-size-available-width");
        }
      })
    ) : (this.style.removeProperty("--auto-size-available-width"), this.style.removeProperty("--auto-size-available-height")), this.arrow && r.push(
      zw({
        element: this.arrowEl,
        padding: this.arrowPadding
      })
    );
    const e = this.strategy === "absolute" ? (t) => ao.getOffsetParent(t, Ww) : ao.getOffsetParent;
    Yw(this.anchorEl, this.popup, {
      placement: this.placement,
      middleware: r,
      strategy: this.strategy,
      platform: ll(gi({}, ao), {
        getOffsetParent: e
      })
    }).then(({ x: t, y: i, middlewareData: n, placement: s }) => {
      const o = getComputedStyle(this).direction === "rtl", l = { top: "bottom", right: "left", bottom: "top", left: "right" }[s.split("-")[0]];
      if (this.setAttribute("data-current-placement", s), Object.assign(this.popup.style, {
        left: `${t}px`,
        top: `${i}px`
      }), this.arrow) {
        const a = n.arrow.x, h = n.arrow.y;
        let c = "", u = "", d = "", p = "";
        if (this.arrowPlacement === "start") {
          const f = typeof a == "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          c = typeof h == "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "", u = o ? f : "", p = o ? "" : f;
        } else if (this.arrowPlacement === "end") {
          const f = typeof a == "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          u = o ? "" : f, p = o ? f : "", d = typeof h == "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
        } else
          this.arrowPlacement === "center" ? (p = typeof a == "number" ? "calc(50% - var(--arrow-size-diagonal))" : "", c = typeof h == "number" ? "calc(50% - var(--arrow-size-diagonal))" : "") : (p = typeof a == "number" ? `${a}px` : "", c = typeof h == "number" ? `${h}px` : "");
        Object.assign(this.arrowEl.style, {
          top: c,
          right: u,
          bottom: d,
          left: p,
          [l]: "calc(var(--arrow-size-diagonal) * -1)"
        });
      }
    }), this.emit("sl-reposition");
  }
  render() {
    return X`
      <slot name="anchor" @slotchange=${this.handleAnchorChange}></slot>

      <div
        part="popup"
        class=${je({
      popup: !0,
      "popup--active": this.active,
      "popup--fixed": this.strategy === "fixed",
      "popup--has-arrow": this.arrow
    })}
      >
        <slot></slot>
        ${this.arrow ? X`<div part="arrow" class="popup__arrow" role="presentation"></div>` : ""}
      </div>
    `;
  }
};
se.styles = iw;
w([
  J(".popup")
], se.prototype, "popup", 2);
w([
  J(".popup__arrow")
], se.prototype, "arrowEl", 2);
w([
  y()
], se.prototype, "anchor", 2);
w([
  y({ type: Boolean, reflect: !0 })
], se.prototype, "active", 2);
w([
  y({ reflect: !0 })
], se.prototype, "placement", 2);
w([
  y({ reflect: !0 })
], se.prototype, "strategy", 2);
w([
  y({ type: Number })
], se.prototype, "distance", 2);
w([
  y({ type: Number })
], se.prototype, "skidding", 2);
w([
  y({ type: Boolean })
], se.prototype, "arrow", 2);
w([
  y({ attribute: "arrow-placement" })
], se.prototype, "arrowPlacement", 2);
w([
  y({ attribute: "arrow-padding", type: Number })
], se.prototype, "arrowPadding", 2);
w([
  y({ type: Boolean })
], se.prototype, "flip", 2);
w([
  y({
    attribute: "flip-fallback-placements",
    converter: {
      fromAttribute: (r) => r.split(" ").map((e) => e.trim()).filter((e) => e !== ""),
      toAttribute: (r) => r.join(" ")
    }
  })
], se.prototype, "flipFallbackPlacements", 2);
w([
  y({ attribute: "flip-fallback-strategy" })
], se.prototype, "flipFallbackStrategy", 2);
w([
  y({ type: Object })
], se.prototype, "flipBoundary", 2);
w([
  y({ attribute: "flip-padding", type: Number })
], se.prototype, "flipPadding", 2);
w([
  y({ type: Boolean })
], se.prototype, "shift", 2);
w([
  y({ type: Object })
], se.prototype, "shiftBoundary", 2);
w([
  y({ attribute: "shift-padding", type: Number })
], se.prototype, "shiftPadding", 2);
w([
  y({ attribute: "auto-size" })
], se.prototype, "autoSize", 2);
w([
  y()
], se.prototype, "sync", 2);
w([
  y({ type: Object })
], se.prototype, "autoSizeBoundary", 2);
w([
  y({ attribute: "auto-size-padding", type: Number })
], se.prototype, "autoSizePadding", 2);
var dO = /* @__PURE__ */ new Map(), jw = /* @__PURE__ */ new WeakMap();
function Lw(r) {
  return r ?? { keyframes: [], options: { duration: 0 } };
}
function zu(r, e) {
  return e.toLowerCase() === "rtl" ? {
    keyframes: r.rtlKeyframes || r.keyframes,
    options: r.options
  } : r;
}
function en(r, e) {
  dO.set(r, Lw(e));
}
function Wi(r, e, t) {
  const i = jw.get(r);
  if (i != null && i[e])
    return zu(i[e], t.dir);
  const n = dO.get(e);
  return n ? zu(n, t.dir) : {
    keyframes: [],
    options: { duration: 0 }
  };
}
function Vi(r, e) {
  return new Promise((t) => {
    function i(n) {
      n.target === r && (r.removeEventListener(e, i), t());
    }
    r.addEventListener(e, i);
  });
}
function Mi(r, e, t) {
  return new Promise((i) => {
    if ((t == null ? void 0 : t.duration) === 1 / 0)
      throw new Error("Promise-based animations must be finite.");
    const n = r.animate(e, ll(gi({}, t), {
      duration: Bw() ? 0 : t.duration
    }));
    n.addEventListener("cancel", i, { once: !0 }), n.addEventListener("finish", i, { once: !0 });
  });
}
function Yu(r) {
  return r = r.toString().toLowerCase(), r.indexOf("ms") > -1 ? parseFloat(r) : r.indexOf("s") > -1 ? parseFloat(r) * 1e3 : parseFloat(r);
}
function Bw() {
  return window.matchMedia("(prefers-reduced-motion: reduce)").matches;
}
function ji(r) {
  return Promise.all(
    r.getAnimations().map((e) => new Promise((t) => {
      const i = requestAnimationFrame(t);
      e.addEventListener("cancel", () => i, { once: !0 }), e.addEventListener("finish", () => i, { once: !0 }), e.cancel();
    }))
  );
}
var Ie = class extends ve {
  constructor() {
    super(...arguments), this.localize = new Vr(this), this.open = !1, this.placement = "bottom-start", this.disabled = !1, this.stayOpenOnSelect = !1, this.distance = 0, this.skidding = 0, this.hoist = !1, this.handleKeyDown = (r) => {
      this.open && r.key === "Escape" && (r.stopPropagation(), this.hide(), this.focusOnTrigger());
    }, this.handleDocumentKeyDown = (r) => {
      var e;
      if (r.key === "Escape" && this.open) {
        r.stopPropagation(), this.focusOnTrigger(), this.hide();
        return;
      }
      if (r.key === "Tab") {
        if (this.open && ((e = document.activeElement) == null ? void 0 : e.tagName.toLowerCase()) === "sl-menu-item") {
          r.preventDefault(), this.hide(), this.focusOnTrigger();
          return;
        }
        setTimeout(() => {
          var t, i, n;
          const s = ((t = this.containingElement) == null ? void 0 : t.getRootNode()) instanceof ShadowRoot ? (n = (i = document.activeElement) == null ? void 0 : i.shadowRoot) == null ? void 0 : n.activeElement : document.activeElement;
          (!this.containingElement || (s == null ? void 0 : s.closest(this.containingElement.tagName.toLowerCase())) !== this.containingElement) && this.hide();
        });
      }
    }, this.handleDocumentMouseDown = (r) => {
      const e = r.composedPath();
      this.containingElement && !e.includes(this.containingElement) && this.hide();
    }, this.handlePanelSelect = (r) => {
      const e = r.target;
      !this.stayOpenOnSelect && e.tagName.toLowerCase() === "sl-menu" && (this.hide(), this.focusOnTrigger());
    };
  }
  connectedCallback() {
    super.connectedCallback(), this.containingElement || (this.containingElement = this);
  }
  firstUpdated() {
    this.panel.hidden = !this.open, this.open && (this.addOpenListeners(), this.popup.active = !0);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.removeOpenListeners(), this.hide();
  }
  focusOnTrigger() {
    const r = this.trigger.assignedElements({ flatten: !0 })[0];
    typeof (r == null ? void 0 : r.focus) == "function" && r.focus();
  }
  getMenu() {
    return this.panel.assignedElements({ flatten: !0 }).find((r) => r.tagName.toLowerCase() === "sl-menu");
  }
  handleTriggerClick() {
    this.open ? this.hide() : (this.show(), this.focusOnTrigger());
  }
  async handleTriggerKeyDown(r) {
    if ([" ", "Enter"].includes(r.key)) {
      r.preventDefault(), this.handleTriggerClick();
      return;
    }
    const e = this.getMenu();
    if (e) {
      const t = e.getAllItems(), i = t[0], n = t[t.length - 1];
      ["ArrowDown", "ArrowUp", "Home", "End"].includes(r.key) && (r.preventDefault(), this.open || (this.show(), await this.updateComplete), t.length > 0 && this.updateComplete.then(() => {
        (r.key === "ArrowDown" || r.key === "Home") && (e.setCurrentItem(i), i.focus()), (r.key === "ArrowUp" || r.key === "End") && (e.setCurrentItem(n), n.focus());
      }));
    }
  }
  handleTriggerKeyUp(r) {
    r.key === " " && r.preventDefault();
  }
  handleTriggerSlotChange() {
    this.updateAccessibleTrigger();
  }
  //
  // Slotted triggers can be arbitrary content, but we need to link them to the dropdown panel with `aria-haspopup` and
  // `aria-expanded`. These must be applied to the "accessible trigger" (the tabbable portion of the trigger element
  // that gets slotted in) so screen readers will understand them. The accessible trigger could be the slotted element,
  // a child of the slotted element, or an element in the slotted element's shadow root.
  //
  // For example, the accessible trigger of an <sl-button> is a <button> located inside its shadow root.
  //
  // To determine this, we assume the first tabbable element in the trigger slot is the "accessible trigger."
  //
  updateAccessibleTrigger() {
    const e = this.trigger.assignedElements({ flatten: !0 }).find((i) => tw(i).start);
    let t;
    if (e) {
      switch (e.tagName.toLowerCase()) {
        case "sl-button":
        case "sl-icon-button":
          t = e.button;
          break;
        default:
          t = e;
      }
      t.setAttribute("aria-haspopup", "true"), t.setAttribute("aria-expanded", this.open ? "true" : "false");
    }
  }
  /** Shows the dropdown panel. */
  async show() {
    if (!this.open)
      return this.open = !0, Vi(this, "sl-after-show");
  }
  /** Hides the dropdown panel */
  async hide() {
    if (this.open)
      return this.open = !1, Vi(this, "sl-after-hide");
  }
  /**
   * Instructs the dropdown menu to reposition. Useful when the position or size of the trigger changes when the menu
   * is activated.
   */
  reposition() {
    this.popup.reposition();
  }
  addOpenListeners() {
    this.panel.addEventListener("sl-select", this.handlePanelSelect), this.panel.addEventListener("keydown", this.handleKeyDown), document.addEventListener("keydown", this.handleDocumentKeyDown), document.addEventListener("mousedown", this.handleDocumentMouseDown);
  }
  removeOpenListeners() {
    this.panel && (this.panel.removeEventListener("sl-select", this.handlePanelSelect), this.panel.removeEventListener("keydown", this.handleKeyDown)), document.removeEventListener("keydown", this.handleDocumentKeyDown), document.removeEventListener("mousedown", this.handleDocumentMouseDown);
  }
  async handleOpenChange() {
    if (this.disabled) {
      this.open = !1;
      return;
    }
    if (this.updateAccessibleTrigger(), this.open) {
      this.emit("sl-show"), this.addOpenListeners(), await ji(this), this.panel.hidden = !1, this.popup.active = !0;
      const { keyframes: r, options: e } = Wi(this, "dropdown.show", { dir: this.localize.dir() });
      await Mi(this.popup.popup, r, e), this.emit("sl-after-show");
    } else {
      this.emit("sl-hide"), this.removeOpenListeners(), await ji(this);
      const { keyframes: r, options: e } = Wi(this, "dropdown.hide", { dir: this.localize.dir() });
      await Mi(this.popup.popup, r, e), this.panel.hidden = !0, this.popup.active = !1, this.emit("sl-after-hide");
    }
  }
  render() {
    return X`
      <sl-popup
        part="base"
        id="dropdown"
        placement=${this.placement}
        distance=${this.distance}
        skidding=${this.skidding}
        strategy=${this.hoist ? "fixed" : "absolute"}
        flip
        shift
        auto-size="vertical"
        auto-size-padding="10"
        class=${je({
      dropdown: !0,
      "dropdown--open": this.open
    })}
      >
        <slot
          name="trigger"
          slot="anchor"
          part="trigger"
          class="dropdown__trigger"
          @click=${this.handleTriggerClick}
          @keydown=${this.handleTriggerKeyDown}
          @keyup=${this.handleTriggerKeyUp}
          @slotchange=${this.handleTriggerSlotChange}
        ></slot>

        <div aria-hidden=${this.open ? "false" : "true"} aria-labelledby="dropdown">
          <slot part="panel" class="dropdown__panel"></slot>
        </div>
      </sl-popup>
    `;
  }
};
Ie.styles = Kb;
Ie.dependencies = { "sl-popup": se };
w([
  J(".dropdown")
], Ie.prototype, "popup", 2);
w([
  J(".dropdown__trigger")
], Ie.prototype, "trigger", 2);
w([
  J(".dropdown__panel")
], Ie.prototype, "panel", 2);
w([
  y({ type: Boolean, reflect: !0 })
], Ie.prototype, "open", 2);
w([
  y({ reflect: !0 })
], Ie.prototype, "placement", 2);
w([
  y({ type: Boolean, reflect: !0 })
], Ie.prototype, "disabled", 2);
w([
  y({ attribute: "stay-open-on-select", type: Boolean, reflect: !0 })
], Ie.prototype, "stayOpenOnSelect", 2);
w([
  y({ attribute: !1 })
], Ie.prototype, "containingElement", 2);
w([
  y({ type: Number })
], Ie.prototype, "distance", 2);
w([
  y({ type: Number })
], Ie.prototype, "skidding", 2);
w([
  y({ type: Boolean })
], Ie.prototype, "hoist", 2);
w([
  $e("open", { waitUntilFirstUpdate: !0 })
], Ie.prototype, "handleOpenChange", 1);
en("dropdown.show", {
  keyframes: [
    { opacity: 0, scale: 0.9 },
    { opacity: 1, scale: 1 }
  ],
  options: { duration: 100, easing: "ease" }
});
en("dropdown.hide", {
  keyframes: [
    { opacity: 1, scale: 1 },
    { opacity: 0, scale: 0.9 }
  ],
  options: { duration: 100, easing: "ease" }
});
Ie.define("sl-dropdown");
var Dw = re`
  ${We}

  :host {
    --submenu-offset: -2px;

    /* Private */
    --safe-triangle-cursor-x: 0;
    --safe-triangle-cursor-y: 0;
    --safe-triangle-submenu-start-x: 0;
    --safe-triangle-submenu-start-y: 0;
    --safe-triangle-submenu-end-x: 0;
    --safe-triangle-submenu-end-y: 0;

    display: block;
  }

  :host([inert]) {
    display: none;
  }

  .menu-item {
    position: relative;
    display: flex;
    align-items: stretch;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    line-height: var(--sl-line-height-normal);
    letter-spacing: var(--sl-letter-spacing-normal);
    color: var(--sl-color-neutral-700);
    padding: var(--sl-spacing-2x-small) var(--sl-spacing-2x-small);
    transition: var(--sl-transition-fast) fill;
    user-select: none;
    -webkit-user-select: none;
    white-space: nowrap;
    cursor: pointer;
  }

  .menu-item.menu-item--disabled {
    outline: none;
    opacity: 0.5;
    cursor: not-allowed;
  }

  .menu-item .menu-item__label {
    flex: 1 1 auto;
    display: inline-block;
    text-overflow: ellipsis;
    overflow: hidden;
  }

  .menu-item .menu-item__prefix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .menu-item .menu-item__prefix::slotted(*) {
    margin-inline-end: var(--sl-spacing-x-small);
  }

  .menu-item .menu-item__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .menu-item .menu-item__suffix::slotted(*) {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  /* Safe triangle */
  .menu-item--submenu-expanded::after {
    content: '';
    position: fixed;
    z-index: calc(var(--sl-z-index-dropdown) - 1);
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    clip-path: polygon(
      var(--safe-triangle-cursor-x) var(--safe-triangle-cursor-y),
      var(--safe-triangle-submenu-start-x) var(--safe-triangle-submenu-start-y),
      var(--safe-triangle-submenu-end-x) var(--safe-triangle-submenu-end-y)
    );
  }

  :host(:focus-visible) {
    outline: none;
  }

  :host(:hover:not([aria-disabled='true'], :focus-visible)) .menu-item,
  .menu-item--submenu-expanded {
    background-color: var(--sl-color-neutral-100);
    color: var(--sl-color-neutral-1000);
  }

  :host(:focus-visible) .menu-item {
    outline: none;
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
    opacity: 1;
  }

  .menu-item .menu-item__check,
  .menu-item .menu-item__chevron {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 1.5em;
    visibility: hidden;
  }

  .menu-item--checked .menu-item__check,
  .menu-item--has-submenu .menu-item__chevron {
    visibility: visible;
  }

  /* Add elevation and z-index to submenus */
  sl-popup::part(popup) {
    box-shadow: var(--sl-shadow-large);
    z-index: var(--sl-z-index-dropdown);
    margin-left: var(--submenu-offset);
  }

  .menu-item--rtl sl-popup::part(popup) {
    margin-left: calc(-1 * var(--submenu-offset));
  }

  @media (forced-colors: active) {
    :host(:hover:not([aria-disabled='true'])) .menu-item,
    :host(:focus-visible) .menu-item {
      outline: dashed 1px SelectedItem;
      outline-offset: -1px;
    }
  }
`;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Rn = (r, e) => {
  var i;
  const t = r._$AN;
  if (t === void 0)
    return !1;
  for (const n of t)
    (i = n._$AO) == null || i.call(n, e, !1), Rn(n, e);
  return !0;
}, To = (r) => {
  let e, t;
  do {
    if ((e = r._$AM) === void 0)
      break;
    t = e._$AN, t.delete(r), r = e;
  } while ((t == null ? void 0 : t.size) === 0);
}, pO = (r) => {
  for (let e; e = r._$AM; r = e) {
    let t = e._$AN;
    if (t === void 0)
      e._$AN = t = /* @__PURE__ */ new Set();
    else if (t.has(r))
      break;
    t.add(r), Gw(e);
  }
};
function Iw(r) {
  this._$AN !== void 0 ? (To(this), this._$AM = r, pO(this)) : this._$AM = r;
}
function Uw(r, e = !1, t = 0) {
  const i = this._$AH, n = this._$AN;
  if (n !== void 0 && n.size !== 0)
    if (e)
      if (Array.isArray(i))
        for (let s = t; s < i.length; s++)
          Rn(i[s], !1), To(i[s]);
      else
        i != null && (Rn(i, !1), To(i));
    else
      Rn(this, r);
}
const Gw = (r) => {
  r.type == tr.CHILD && (r._$AP ?? (r._$AP = Uw), r._$AQ ?? (r._$AQ = Iw));
};
class Nw extends hl {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(e, t, i) {
    super._$AT(e, t, i), pO(this), this.isConnected = e._$AU;
  }
  _$AO(e, t = !0) {
    var i, n;
    e !== this.isConnected && (this.isConnected = e, e ? (i = this.reconnected) == null || i.call(this) : (n = this.disconnected) == null || n.call(this)), t && (Rn(this, e), To(this));
  }
  setValue(e) {
    if (tO(this._$Ct))
      this._$Ct._$AI(e, this);
    else {
      const t = [...this._$Ct._$AH];
      t[this._$Ci] = e, this._$Ct._$AI(t, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Fw = () => new Hw();
class Hw {
}
const Ll = /* @__PURE__ */ new WeakMap(), Kw = al(class extends Nw {
  render(r) {
    return de;
  }
  update(r, [e]) {
    var i;
    const t = e !== this.G;
    return t && this.G !== void 0 && this.ot(void 0), (t || this.rt !== this.lt) && (this.G = e, this.ct = (i = r.options) == null ? void 0 : i.host, this.ot(this.lt = r.element)), de;
  }
  ot(r) {
    if (typeof this.G == "function") {
      const e = this.ct ?? globalThis;
      let t = Ll.get(e);
      t === void 0 && (t = /* @__PURE__ */ new WeakMap(), Ll.set(e, t)), t.get(this.G) !== void 0 && this.G.call(this.ct, void 0), t.set(this.G, r), r !== void 0 && this.G.call(this.ct, r);
    } else
      this.G.value = r;
  }
  get rt() {
    var r, e;
    return typeof this.G == "function" ? (r = Ll.get(this.ct ?? globalThis)) == null ? void 0 : r.get(this.G) : (e = this.G) == null ? void 0 : e.value;
  }
  disconnected() {
    this.rt === this.lt && this.ot(void 0);
  }
  reconnected() {
    this.ot(this.lt);
  }
});
var Jw = class {
  constructor(r, e, t) {
    this.popupRef = Fw(), this.enableSubmenuTimer = -1, this.isConnected = !1, this.isPopupConnected = !1, this.skidding = 0, this.submenuOpenDelay = 100, this.handleMouseMove = (i) => {
      this.host.style.setProperty("--safe-triangle-cursor-x", `${i.clientX}px`), this.host.style.setProperty("--safe-triangle-cursor-y", `${i.clientY}px`);
    }, this.handleMouseOver = () => {
      this.hasSlotController.test("submenu") && this.enableSubmenu();
    }, this.handleKeyDown = (i) => {
      switch (i.key) {
        case "Escape":
        case "Tab":
          this.disableSubmenu();
          break;
        case "ArrowLeft":
          i.target !== this.host && (i.preventDefault(), i.stopPropagation(), this.host.focus(), this.disableSubmenu());
          break;
        case "ArrowRight":
        case "Enter":
        case " ":
          this.handleSubmenuEntry(i);
          break;
      }
    }, this.handleClick = (i) => {
      var n;
      i.target === this.host ? (i.preventDefault(), i.stopPropagation()) : i.target instanceof Element && (i.target.tagName === "sl-menu-item" || (n = i.target.role) != null && n.startsWith("menuitem")) && this.disableSubmenu();
    }, this.handleFocusOut = (i) => {
      i.relatedTarget && i.relatedTarget instanceof Element && this.host.contains(i.relatedTarget) || this.disableSubmenu();
    }, this.handlePopupMouseover = (i) => {
      i.stopPropagation();
    }, this.handlePopupReposition = () => {
      const i = this.host.renderRoot.querySelector("slot[name='submenu']"), n = i == null ? void 0 : i.assignedElements({ flatten: !0 }).filter((c) => c.localName === "sl-menu")[0], s = this.localize.dir() === "rtl";
      if (!n)
        return;
      const { left: o, top: l, width: a, height: h } = n.getBoundingClientRect();
      this.host.style.setProperty("--safe-triangle-submenu-start-x", `${s ? o + a : o}px`), this.host.style.setProperty("--safe-triangle-submenu-start-y", `${l}px`), this.host.style.setProperty("--safe-triangle-submenu-end-x", `${s ? o + a : o}px`), this.host.style.setProperty("--safe-triangle-submenu-end-y", `${l + h}px`);
    }, (this.host = r).addController(this), this.hasSlotController = e, this.localize = t;
  }
  hostConnected() {
    this.hasSlotController.test("submenu") && !this.host.disabled && this.addListeners();
  }
  hostDisconnected() {
    this.removeListeners();
  }
  hostUpdated() {
    this.hasSlotController.test("submenu") && !this.host.disabled ? (this.addListeners(), this.updateSkidding()) : this.removeListeners();
  }
  addListeners() {
    this.isConnected || (this.host.addEventListener("mousemove", this.handleMouseMove), this.host.addEventListener("mouseover", this.handleMouseOver), this.host.addEventListener("keydown", this.handleKeyDown), this.host.addEventListener("click", this.handleClick), this.host.addEventListener("focusout", this.handleFocusOut), this.isConnected = !0), this.isPopupConnected || this.popupRef.value && (this.popupRef.value.addEventListener("mouseover", this.handlePopupMouseover), this.popupRef.value.addEventListener("sl-reposition", this.handlePopupReposition), this.isPopupConnected = !0);
  }
  removeListeners() {
    this.isConnected && (this.host.removeEventListener("mousemove", this.handleMouseMove), this.host.removeEventListener("mouseover", this.handleMouseOver), this.host.removeEventListener("keydown", this.handleKeyDown), this.host.removeEventListener("click", this.handleClick), this.host.removeEventListener("focusout", this.handleFocusOut), this.isConnected = !1), this.isPopupConnected && this.popupRef.value && (this.popupRef.value.removeEventListener("mouseover", this.handlePopupMouseover), this.popupRef.value.removeEventListener("sl-reposition", this.handlePopupReposition), this.isPopupConnected = !1);
  }
  handleSubmenuEntry(r) {
    const e = this.host.renderRoot.querySelector("slot[name='submenu']");
    if (!e) {
      console.error("Cannot activate a submenu if no corresponding menuitem can be found.", this);
      return;
    }
    let t = null;
    for (const i of e.assignedElements())
      if (t = i.querySelectorAll("sl-menu-item, [role^='menuitem']"), t.length !== 0)
        break;
    if (!(!t || t.length === 0)) {
      t[0].setAttribute("tabindex", "0");
      for (let i = 1; i !== t.length; ++i)
        t[i].setAttribute("tabindex", "-1");
      this.popupRef.value && (r.preventDefault(), r.stopPropagation(), this.popupRef.value.active ? t[0] instanceof HTMLElement && t[0].focus() : (this.enableSubmenu(!1), this.host.updateComplete.then(() => {
        t[0] instanceof HTMLElement && t[0].focus();
      }), this.host.requestUpdate()));
    }
  }
  setSubmenuState(r) {
    this.popupRef.value && this.popupRef.value.active !== r && (this.popupRef.value.active = r, this.host.requestUpdate());
  }
  // Shows the submenu. Supports disabling the opening delay, e.g. for keyboard events that want to set the focus to the
  // newly opened menu.
  enableSubmenu(r = !0) {
    r ? this.enableSubmenuTimer = window.setTimeout(() => {
      this.setSubmenuState(!0);
    }, this.submenuOpenDelay) : this.setSubmenuState(!0);
  }
  disableSubmenu() {
    clearTimeout(this.enableSubmenuTimer), this.setSubmenuState(!1);
  }
  // Calculate the space the top of a menu takes-up, for aligning the popup menu-item with the activating element.
  updateSkidding() {
    var r;
    if (!((r = this.host.parentElement) != null && r.computedStyleMap))
      return;
    const e = this.host.parentElement.computedStyleMap(), i = ["padding-top", "border-top-width", "margin-top"].reduce((n, s) => {
      var o;
      const l = (o = e.get(s)) != null ? o : new CSSUnitValue(0, "px"), h = (l instanceof CSSUnitValue ? l : new CSSUnitValue(0, "px")).to("px");
      return n - h.value;
    }, 0);
    this.skidding = i;
  }
  isExpanded() {
    return this.popupRef.value ? this.popupRef.value.active : !1;
  }
  renderSubmenu() {
    const r = this.localize.dir() === "ltr";
    return this.isConnected ? X`
      <sl-popup
        ${Kw(this.popupRef)}
        placement=${r ? "right-start" : "left-start"}
        anchor="anchor"
        flip
        flip-fallback-strategy="best-fit"
        skidding="${this.skidding}"
        strategy="fixed"
      >
        <slot name="submenu"></slot>
      </sl-popup>
    ` : X` <slot name="submenu" hidden></slot> `;
  }
}, xt = class extends ve {
  constructor() {
    super(...arguments), this.type = "normal", this.checked = !1, this.value = "", this.disabled = !1, this.localize = new Vr(this), this.hasSlotController = new ms(this, "submenu"), this.submenuController = new Jw(this, this.hasSlotController, this.localize), this.handleHostClick = (r) => {
      this.disabled && (r.preventDefault(), r.stopImmediatePropagation());
    }, this.handleMouseOver = (r) => {
      this.focus(), r.stopPropagation();
    };
  }
  connectedCallback() {
    super.connectedCallback(), this.addEventListener("click", this.handleHostClick), this.addEventListener("mouseover", this.handleMouseOver);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.removeEventListener("click", this.handleHostClick), this.removeEventListener("mouseover", this.handleMouseOver);
  }
  handleDefaultSlotChange() {
    const r = this.getTextLabel();
    if (typeof this.cachedTextLabel > "u") {
      this.cachedTextLabel = r;
      return;
    }
    r !== this.cachedTextLabel && (this.cachedTextLabel = r, this.emit("slotchange", { bubbles: !0, composed: !1, cancelable: !1 }));
  }
  handleCheckedChange() {
    if (this.checked && this.type !== "checkbox") {
      this.checked = !1, console.error('The checked attribute can only be used on menu items with type="checkbox"', this);
      return;
    }
    this.type === "checkbox" ? this.setAttribute("aria-checked", this.checked ? "true" : "false") : this.removeAttribute("aria-checked");
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  handleTypeChange() {
    this.type === "checkbox" ? (this.setAttribute("role", "menuitemcheckbox"), this.setAttribute("aria-checked", this.checked ? "true" : "false")) : (this.setAttribute("role", "menuitem"), this.removeAttribute("aria-checked"));
  }
  /** Returns a text label based on the contents of the menu item's default slot. */
  getTextLabel() {
    return zb(this.defaultSlot);
  }
  isSubmenu() {
    return this.hasSlotController.test("submenu");
  }
  render() {
    const r = this.localize.dir() === "rtl", e = this.submenuController.isExpanded();
    return X`
      <div
        id="anchor"
        part="base"
        class=${je({
      "menu-item": !0,
      "menu-item--rtl": r,
      "menu-item--checked": this.checked,
      "menu-item--disabled": this.disabled,
      "menu-item--has-submenu": this.isSubmenu(),
      "menu-item--submenu-expanded": e
    })}
        ?aria-haspopup="${this.isSubmenu()}"
        ?aria-expanded="${!!e}"
      >
        <span part="checked-icon" class="menu-item__check">
          <sl-icon name="check" library="system" aria-hidden="true"></sl-icon>
        </span>

        <slot name="prefix" part="prefix" class="menu-item__prefix"></slot>

        <slot part="label" class="menu-item__label" @slotchange=${this.handleDefaultSlotChange}></slot>

        <slot name="suffix" part="suffix" class="menu-item__suffix"></slot>

        <span part="submenu-icon" class="menu-item__chevron">
          <sl-icon name=${r ? "chevron-left" : "chevron-right"} library="system" aria-hidden="true"></sl-icon>
        </span>

        ${this.submenuController.renderSubmenu()}
      </div>
    `;
  }
};
xt.styles = Dw;
xt.dependencies = {
  "sl-icon": vt,
  "sl-popup": se
};
w([
  J("slot:not([name])")
], xt.prototype, "defaultSlot", 2);
w([
  J(".menu-item")
], xt.prototype, "menuItem", 2);
w([
  y()
], xt.prototype, "type", 2);
w([
  y({ type: Boolean, reflect: !0 })
], xt.prototype, "checked", 2);
w([
  y()
], xt.prototype, "value", 2);
w([
  y({ type: Boolean, reflect: !0 })
], xt.prototype, "disabled", 2);
w([
  $e("checked")
], xt.prototype, "handleCheckedChange", 1);
w([
  $e("disabled")
], xt.prototype, "handleDisabledChange", 1);
w([
  $e("type")
], xt.prototype, "handleTypeChange", 1);
xt.define("sl-menu-item");
var ey = re`
  ${We}

  :host {
    display: block;
    position: relative;
    background: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-radius: var(--sl-border-radius-medium);
    padding: var(--sl-spacing-x-small) 0;
    overflow: auto;
    overscroll-behavior: none;
  }

  ::slotted(sl-divider) {
    --spacing: var(--sl-spacing-x-small);
  }
`, hc = class extends ve {
  connectedCallback() {
    super.connectedCallback(), this.setAttribute("role", "menu");
  }
  handleClick(r) {
    const e = ["menuitem", "menuitemcheckbox"], t = r.composedPath().find((n) => {
      var s;
      return e.includes(((s = n == null ? void 0 : n.getAttribute) == null ? void 0 : s.call(n, "role")) || "");
    });
    if (!t)
      return;
    const i = t;
    i.type === "checkbox" && (i.checked = !i.checked), this.emit("sl-select", { detail: { item: i } });
  }
  handleKeyDown(r) {
    if (r.key === "Enter" || r.key === " ") {
      const e = this.getCurrentItem();
      r.preventDefault(), r.stopPropagation(), e == null || e.click();
    } else if (["ArrowDown", "ArrowUp", "Home", "End"].includes(r.key)) {
      const e = this.getAllItems(), t = this.getCurrentItem();
      let i = t ? e.indexOf(t) : 0;
      e.length > 0 && (r.preventDefault(), r.stopPropagation(), r.key === "ArrowDown" ? i++ : r.key === "ArrowUp" ? i-- : r.key === "Home" ? i = 0 : r.key === "End" && (i = e.length - 1), i < 0 && (i = e.length - 1), i > e.length - 1 && (i = 0), this.setCurrentItem(e[i]), e[i].focus());
    }
  }
  handleMouseDown(r) {
    const e = r.target;
    this.isMenuItem(e) && this.setCurrentItem(e);
  }
  handleSlotChange() {
    const r = this.getAllItems();
    r.length > 0 && this.setCurrentItem(r[0]);
  }
  isMenuItem(r) {
    var e;
    return r.tagName.toLowerCase() === "sl-menu-item" || ["menuitem", "menuitemcheckbox", "menuitemradio"].includes((e = r.getAttribute("role")) != null ? e : "");
  }
  /** @internal Gets all slotted menu items, ignoring dividers, headers, and other elements. */
  getAllItems() {
    return [...this.defaultSlot.assignedElements({ flatten: !0 })].filter((r) => !(r.inert || !this.isMenuItem(r)));
  }
  /**
   * @internal Gets the current menu item, which is the menu item that has `tabindex="0"` within the roving tab index.
   * The menu item may or may not have focus, but for keyboard interaction purposes it's considered the "active" item.
   */
  getCurrentItem() {
    return this.getAllItems().find((r) => r.getAttribute("tabindex") === "0");
  }
  /**
   * @internal Sets the current menu item to the specified element. This sets `tabindex="0"` on the target element and
   * `tabindex="-1"` to all other items. This method must be called prior to setting focus on a menu item.
   */
  setCurrentItem(r) {
    this.getAllItems().forEach((t) => {
      t.setAttribute("tabindex", t === r ? "0" : "-1");
    });
  }
  render() {
    return X`
      <slot
        @slotchange=${this.handleSlotChange}
        @click=${this.handleClick}
        @keydown=${this.handleKeyDown}
        @mousedown=${this.handleMouseDown}
      ></slot>
    `;
  }
};
hc.styles = ey;
w([
  J("slot")
], hc.prototype, "defaultSlot", 2);
hc.define("sl-menu");
var Je = {
  fullscreenEnabled: 0,
  fullscreenElement: 1,
  requestFullscreen: 2,
  exitFullscreen: 3,
  fullscreenchange: 4,
  fullscreenerror: 5,
  fullscreen: 6
}, Wu = [
  "webkitFullscreenEnabled",
  "webkitFullscreenElement",
  "webkitRequestFullscreen",
  "webkitExitFullscreen",
  "webkitfullscreenchange",
  "webkitfullscreenerror",
  "-webkit-full-screen"
], Vu = [
  "mozFullScreenEnabled",
  "mozFullScreenElement",
  "mozRequestFullScreen",
  "mozCancelFullScreen",
  "mozfullscreenchange",
  "mozfullscreenerror",
  "-moz-full-screen"
], Mu = [
  "msFullscreenEnabled",
  "msFullscreenElement",
  "msRequestFullscreen",
  "msExitFullscreen",
  "MSFullscreenChange",
  "MSFullscreenError",
  "-ms-fullscreen"
], Ue = typeof window < "u" && typeof window.document < "u" ? window.document : {}, ut = "fullscreenEnabled" in Ue && Object.keys(Je) || Wu[0] in Ue && Wu || Vu[0] in Ue && Vu || Mu[0] in Ue && Mu || [], Bl = {
  requestFullscreen: function(r) {
    return r[ut[Je.requestFullscreen]]();
  },
  requestFullscreenFunction: function(r) {
    return r[ut[Je.requestFullscreen]];
  },
  get exitFullscreen() {
    return Ue[ut[Je.exitFullscreen]].bind(Ue);
  },
  get fullscreenPseudoClass() {
    return ":" + ut[Je.fullscreen];
  },
  addEventListener: function(r, e, t) {
    return Ue.addEventListener(ut[Je[r]], e, t);
  },
  removeEventListener: function(r, e, t) {
    return Ue.removeEventListener(ut[Je[r]], e, t);
  },
  get fullscreenEnabled() {
    return !!Ue[ut[Je.fullscreenEnabled]];
  },
  set fullscreenEnabled(r) {
  },
  get fullscreenElement() {
    return Ue[ut[Je.fullscreenElement]];
  },
  set fullscreenElement(r) {
  },
  get onfullscreenchange() {
    return Ue[("on" + ut[Je.fullscreenchange]).toLowerCase()];
  },
  set onfullscreenchange(r) {
    return Ue[("on" + ut[Je.fullscreenchange]).toLowerCase()] = r;
  },
  get onfullscreenerror() {
    return Ue[("on" + ut[Je.fullscreenerror]).toLowerCase()];
  },
  set onfullscreenerror(r) {
    return Ue[("on" + ut[Je.fullscreenerror]).toLowerCase()] = r;
  }
};
const ty = ":host{box-sizing:border-box}:host *,:host *:before,:host *:after{box-sizing:inherit}.hidden,[hidden]{display:none!important}.rtl{direction:rtl}.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}:host{display:block}";
var ry = Object.defineProperty, iy = Object.getOwnPropertyDescriptor, ny = (r, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? iy(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (n = (i ? o(e, t, n) : o(n)) || n);
  return i && n && ry(e, t, n), n;
};
const pu = class pu extends Pi {
  constructor() {
    super(...arguments), this.fullscreen = !1;
  }
  /**
   * Emission d'un événement `CustomEvent` par l'élément.
   *
   * Par défaut, l'événement se propage dans le DOM (`bubbles: true`);
   * il traverse également la frontière du DOM fantôme (_Shadow DOM_, `composed:true`)
   * et ne peut être empêché de le faire (`cancelable: false`).
   *
   */
  emit(e, t) {
    const i = new CustomEvent(e, {
      bubbles: !0,
      cancelable: !1,
      composed: !0,
      detail: {},
      ...t
    });
    return this.dispatchEvent(i), i;
  }
  /**
   * Passe en mode plein écran ou sort du mode plein écran.
   *
   * On peut utiliser la touche <kbd>Esc</kbd> ou <kbd>F11</kbd> pour sortir du mode plein écran.
   */
  toggleFullscreen() {
    this.fullscreen = !this.fullscreen, Bl.fullscreenElement ? Bl.exitFullscreen() : Bl.requestFullscreen(this);
  }
  /**
   * Crée une alerte qui affiche le message associé pendant une durée donnée.
   *
   * @param {string} message - le message d'alerte
   * @param {string} [variant="primary"] - apparence du message
   * @param {string} [icon="it-mdi-information-variant-circle-outline"] - icône associé au message.
   * @param {string} [duration="3000"] - durée d'affichage de l'alerte en millisecondes.
   * @returns
   * @memberof EnibookElement
   */
  notify(e, t = "primary", i = "it-mdi-information-variant-circle-outline", n = "3000") {
    const s = Object.assign(document.createElement("sl-alert"), {
      variant: t,
      closable: !0,
      duration: n,
      innerHTML: `
          <div slot="icon"><${i}></${i}</div>
          ${this.wrap(e)}
        `
    });
    return document.body.append(s), s.toast();
  }
  wrap(e) {
    const t = document.createElement("div");
    return t.textContent = e, t.innerHTML;
  }
};
pu.styles = [
  Zt(ty),
  re`/* layer: preflights */
*,::before,::after{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-pan-x: ;--un-pan-y: ;--un-pinch-zoom: ;--un-scroll-snap-strictness:proximity;--un-ordinal: ;--un-slashed-zero: ;--un-numeric-figure: ;--un-numeric-spacing: ;--un-numeric-fraction: ;--un-border-spacing-x:0;--un-border-spacing-y:0;--un-ring-offset-shadow:0 0 rgb(0 0 0 / 0);--un-ring-shadow:0 0 rgb(0 0 0 / 0);--un-shadow-inset: ;--un-shadow:0 0 rgb(0 0 0 / 0);--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgb(147 197 253 / 0.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: ;}::backdrop{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-pan-x: ;--un-pan-y: ;--un-pinch-zoom: ;--un-scroll-snap-strictness:proximity;--un-ordinal: ;--un-slashed-zero: ;--un-numeric-figure: ;--un-numeric-spacing: ;--un-numeric-fraction: ;--un-border-spacing-x:0;--un-border-spacing-y:0;--un-ring-offset-shadow:0 0 rgb(0 0 0 / 0);--un-ring-shadow:0 0 rgb(0 0 0 / 0);--un-shadow-inset: ;--un-shadow:0 0 rgb(0 0 0 / 0);--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgb(147 197 253 / 0.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: ;}
/* layer: icons */
.it-mdi-information-variant-circle-outline{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M12.3 7.29c.2-.18.44-.29.7-.29c.27 0 .5.11.71.29c.19.21.29.45.29.71c0 .27-.1.5-.29.71c-.21.19-.44.29-.71.29c-.26 0-.5-.1-.7-.29c-.19-.21-.3-.44-.3-.71c0-.26.11-.5.3-.71m-2.5 4.68s2.17-1.72 2.96-1.79c.74-.06.59.79.52 1.23l-.01.06c-.14.53-.31 1.17-.48 1.78c-.38 1.39-.75 2.75-.66 3c.1.34.72-.09 1.17-.39c.06-.04.11-.08.16-.11c0 0 .08-.08.16.03c.02.03.04.06.06.08c.09.14.14.19.02.27l-.04.02c-.22.15-1.16.81-1.54 1.05c-.41.27-1.98 1.17-1.74-.58c.21-1.23.49-2.29.71-3.12c.41-1.5.59-2.18-.33-1.59c-.37.22-.59.36-.72.45c-.11.08-.12.08-.19-.05l-.03-.06l-.05-.08c-.07-.1-.07-.11.03-.2M22 12c0 5.5-4.5 10-10 10S2 17.5 2 12S6.5 2 12 2s10 4.5 10 10m-2 0c0-4.42-3.58-8-8-8s-8 3.58-8 8s3.58 8 8 8s8-3.58 8-8'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
/* layer: typography */
:is([prose=""],.prose) :where(h1,h2,h3,h4,h5,h6):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-headings);font-weight:600;line-height:1.25;}:is([prose=""],.prose) :where(a):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-links);text-decoration:underline;font-weight:500;}:is([prose=""],.prose) :where(a code):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-links);}:is([prose=""],.prose) :where(p,ul,ol,pre):not(:where(.not-prose,.not-prose *)){margin:1em 0;line-height:1.75;}:is([prose=""],.prose) :where(blockquote):not(:where(.not-prose,.not-prose *)){margin:1em 0;padding-left:1em;font-style:italic;border-left:.25em solid var(--un-prose-borders);}:is([prose=""],.prose) :where(h1):not(:where(.not-prose,.not-prose *)){margin:1rem 0;font-size:2.25em;}:is([prose=""],.prose) :where(h2):not(:where(.not-prose,.not-prose *)){margin:1.75em 0 .5em;font-size:1.75em;}:is([prose=""],.prose) :where(h3):not(:where(.not-prose,.not-prose *)){margin:1.5em 0 .5em;font-size:1.375em;}:is([prose=""],.prose) :where(h4):not(:where(.not-prose,.not-prose *)){margin:1em 0;font-size:1.125em;}:is([prose=""],.prose) :where(img,video):not(:where(.not-prose,.not-prose *)){max-width:100%;}:is([prose=""],.prose) :where(figure,picture):not(:where(.not-prose,.not-prose *)){margin:1em 0;}:is([prose=""],.prose) :where(figcaption):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-captions);font-size:.875em;}:is([prose=""],.prose) :where(code):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-code);font-size:.875em;font-weight:600;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;}:is([prose=""],.prose) :where(:not(pre) > code):not(:where(.not-prose,.not-prose *))::before,:is([prose=""],.prose) :where(:not(pre) > code):not(:where(.not-prose,.not-prose *))::after{content:"\`";}:is([prose=""],.prose) :where(pre):not(:where(.not-prose,.not-prose *)){padding:1.25rem 1.5rem;overflow-x:auto;border-radius:.375rem;}:is([prose=""],.prose) :where(pre,code):not(:where(.not-prose,.not-prose *)){white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;hyphens:none;background:transparent;}:is([prose=""],.prose) :where(pre code):not(:where(.not-prose,.not-prose *)){font-weight:inherit;}:is([prose=""],.prose) :where(ol,ul):not(:where(.not-prose,.not-prose *)){padding-left:1.25em;}:is([prose=""],.prose) :where(ol):not(:where(.not-prose,.not-prose *)){list-style-type:decimal;}:is([prose=""],.prose) :where(ol[type="A"]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-alpha;}:is([prose=""],.prose) :where(ol[type="a"]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-alpha;}:is([prose=""],.prose) :where(ol[type="A" s]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-alpha;}:is([prose=""],.prose) :where(ol[type="a" s]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-alpha;}:is([prose=""],.prose) :where(ol[type="I"]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-roman;}:is([prose=""],.prose) :where(ol[type="i"]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-roman;}:is([prose=""],.prose) :where(ol[type="I" s]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-roman;}:is([prose=""],.prose) :where(ol[type="i" s]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-roman;}:is([prose=""],.prose) :where(ol[type="1"]):not(:where(.not-prose,.not-prose *)){list-style-type:decimal;}:is([prose=""],.prose) :where(ul):not(:where(.not-prose,.not-prose *)){list-style-type:disc;}:is([prose=""],.prose) :where(ol > li):not(:where(.not-prose,.not-prose *))::marker,:is([prose=""],.prose) :where(ul > li):not(:where(.not-prose,.not-prose *))::marker,:is([prose=""],.prose) :where(summary):not(:where(.not-prose,.not-prose *))::marker{color:var(--un-prose-lists);}:is([prose=""],.prose) :where(hr):not(:where(.not-prose,.not-prose *)){margin:2em 0;border:1px solid var(--un-prose-hr);}:is([prose=""],.prose) :where(table):not(:where(.not-prose,.not-prose *)){display:block;margin:1em 0;border-collapse:collapse;overflow-x:auto;}:is([prose=""],.prose) :where(tr):not(:where(.not-prose,.not-prose *)):nth-child(2n){background:var(--un-prose-bg-soft);}:is([prose=""],.prose) :where(td,th):not(:where(.not-prose,.not-prose *)){border:1px solid var(--un-prose-borders);padding:.625em 1em;}:is([prose=""],.prose) :where(abbr):not(:where(.not-prose,.not-prose *)){cursor:help;}:is([prose=""],.prose) :where(kbd):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-code);border:1px solid;padding:.25rem .5rem;font-size:.875em;border-radius:.25rem;}:is([prose=""],.prose) :where(details):not(:where(.not-prose,.not-prose *)){margin:1em 0;padding:1.25rem 1.5rem;background:var(--un-prose-bg-soft);}:is([prose=""],.prose) :where(summary):not(:where(.not-prose,.not-prose *)){cursor:pointer;font-weight:600;}
/* layer: default */
.static{position:static;}`
];
let Pt = pu;
ny([
  De()
], Pt.prototype, "fullscreen", 2);
const sy = ":host{display:inline-block}.time.clock__time{margin:0 var(--sl-spacing-large)}sl-dropdown:not(.control)::part(panel){padding:var(--sl-spacing-small);background:var(--sl-panel-background-color);border:solid var(--sl-panel-border-width) var(--sl-panel-border-color);border-radius:var(--sl-border-radius-medium)}", fO = new Intl.DateTimeFormat().resolvedOptions().locale;
function oy(r = fO) {
  return (/* @__PURE__ */ new Date()).toLocaleDateString(r, {
    weekday: "long",
    year: "numeric",
    month: "long",
    day: "numeric"
  });
}
function ju(r = fO) {
  return (/* @__PURE__ */ new Date()).toLocaleTimeString(r, {
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit"
  });
}
var ly = Object.defineProperty, ay = Object.getOwnPropertyDescriptor, hy = Object.getPrototypeOf, cy = Reflect.get, jr = (r, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? ay(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (n = (i ? o(e, t, n) : o(n)) || n);
  return i && n && ly(e, t, n), n;
}, uy = (r, e, t) => cy(hy(r), t, e);
let mt = class extends Pt {
  constructor() {
    super(...arguments), this._state = 3, this._time = ju(), this.date = !1, this.time = !1, this.size = "small";
  }
  /**
   * Le nom courant de l'élément : `Horloge`.
   */
  get tagTitle() {
    return "Horloge";
  }
  firstUpdated(r) {
    const e = this;
    setInterval(() => e.setClock(), 1e3);
  }
  handleClickButton() {
    switch (this._state = (this._state + 1) % 4, this._state) {
      case 0:
        this.date = !1, this.time = !0;
        break;
      case 1:
        this.date = !0, this.time = !0;
        break;
      case 2:
        this.date = !0, this.time = !1;
        break;
      case 3:
        this.date = !1, this.time = !1;
        break;
    }
  }
  render() {
    const r = ["small", "medium", "large"].includes(this.size) ? this.size : "small";
    return X`
      <sl-button part="base" size=${r} @click=${() => this.handleClickButton()}>
        <span class="clock__date">${this.date ? X`${oy()}` : X``}</span>
        <it-mdi-calendar-clock-outline></it-mdi-calendar-clock-outline>
        <span class="clock__time">${this.time ? X`${this._time}` : X``}</span>
      </sl-button>
    `;
  }
  setClock() {
    this._time = ju();
  }
  /**
   * Syntaxe `asciidoc` équivalente :
   *
   * ```
   * name:target[attributes]
   * ```
   *
   * - `name` : `clock-it` (la macro `asciidoc` a le même nom que l'élément `html` correspondant);
   * - `target` : la macro `clock-it` n'a pas de cible (_target_);
   * - `attributes` : `hide-date`, `hide-time`, `size`.
   *
   * Voir la documentation Asciidoc sur les <a href="https://docs.asciidoctor.org/asciidoc/latest/key-concepts/#macros">macros de type _inline_</a>
   * 
   * @examples
   * `clock-it:[]`, 
   * `clock-it:[date]`, 
   * `clock-it:[date, size=medium]`
   */
  toAsciidoc() {
    const r = {
      date: this.date,
      time: this.time
    }, e = [`size=${this.size}`];
    for (const t of Object.keys(r))
      r[t] && e.push(t);
    return `clock-it:[${e.join(",")}]`;
  }
};
mt.styles = [
  uy(mt, mt, "styles"),
  Zt(sy),
  re`/* layer: preflights */
*,::before,::after{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-pan-x: ;--un-pan-y: ;--un-pinch-zoom: ;--un-scroll-snap-strictness:proximity;--un-ordinal: ;--un-slashed-zero: ;--un-numeric-figure: ;--un-numeric-spacing: ;--un-numeric-fraction: ;--un-border-spacing-x:0;--un-border-spacing-y:0;--un-ring-offset-shadow:0 0 rgb(0 0 0 / 0);--un-ring-shadow:0 0 rgb(0 0 0 / 0);--un-shadow-inset: ;--un-shadow:0 0 rgb(0 0 0 / 0);--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgb(147 197 253 / 0.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: ;}::backdrop{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-pan-x: ;--un-pan-y: ;--un-pinch-zoom: ;--un-scroll-snap-strictness:proximity;--un-ordinal: ;--un-slashed-zero: ;--un-numeric-figure: ;--un-numeric-spacing: ;--un-numeric-fraction: ;--un-border-spacing-x:0;--un-border-spacing-y:0;--un-ring-offset-shadow:0 0 rgb(0 0 0 / 0);--un-ring-shadow:0 0 rgb(0 0 0 / 0);--un-shadow-inset: ;--un-shadow:0 0 rgb(0 0 0 / 0);--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgb(147 197 253 / 0.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: ;}
/* layer: icons */
it-mdi-calendar-clock-outline{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M6 1v2H5c-1.11 0-2 .89-2 2v14a2 2 0 0 0 2 2h6.1c1.26 1.24 2.99 2 4.9 2c3.87 0 7-3.13 7-7c0-1.91-.76-3.64-2-4.9V5a2 2 0 0 0-2-2h-1V1h-2v2H8V1M5 5h14v2H5m0 2h14v.67c-.91-.43-1.93-.67-3-.67c-3.87 0-7 3.13-7 7c0 1.07.24 2.09.67 3H5m11-7.85c2.68 0 4.85 2.17 4.85 4.85c0 2.68-2.17 4.85-4.85 4.85c-2.68 0-4.85-2.17-4.85-4.85c0-2.68 2.17-4.85 4.85-4.85M15 13v3.69l3.19 1.84l.75-1.3l-2.44-1.41V13Z'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
/* layer: typography */
:is([prose=""],.prose) :where(h1,h2,h3,h4,h5,h6):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-headings);font-weight:600;line-height:1.25;}:is([prose=""],.prose) :where(a):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-links);text-decoration:underline;font-weight:500;}:is([prose=""],.prose) :where(a code):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-links);}:is([prose=""],.prose) :where(p,ul,ol,pre):not(:where(.not-prose,.not-prose *)){margin:1em 0;line-height:1.75;}:is([prose=""],.prose) :where(blockquote):not(:where(.not-prose,.not-prose *)){margin:1em 0;padding-left:1em;font-style:italic;border-left:.25em solid var(--un-prose-borders);}:is([prose=""],.prose) :where(h1):not(:where(.not-prose,.not-prose *)){margin:1rem 0;font-size:2.25em;}:is([prose=""],.prose) :where(h2):not(:where(.not-prose,.not-prose *)){margin:1.75em 0 .5em;font-size:1.75em;}:is([prose=""],.prose) :where(h3):not(:where(.not-prose,.not-prose *)){margin:1.5em 0 .5em;font-size:1.375em;}:is([prose=""],.prose) :where(h4):not(:where(.not-prose,.not-prose *)){margin:1em 0;font-size:1.125em;}:is([prose=""],.prose) :where(img,video):not(:where(.not-prose,.not-prose *)){max-width:100%;}:is([prose=""],.prose) :where(figure,picture):not(:where(.not-prose,.not-prose *)){margin:1em 0;}:is([prose=""],.prose) :where(figcaption):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-captions);font-size:.875em;}:is([prose=""],.prose) :where(code):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-code);font-size:.875em;font-weight:600;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;}:is([prose=""],.prose) :where(:not(pre) > code):not(:where(.not-prose,.not-prose *))::before,:is([prose=""],.prose) :where(:not(pre) > code):not(:where(.not-prose,.not-prose *))::after{content:"\`";}:is([prose=""],.prose) :where(pre):not(:where(.not-prose,.not-prose *)){padding:1.25rem 1.5rem;overflow-x:auto;border-radius:.375rem;}:is([prose=""],.prose) :where(pre,code):not(:where(.not-prose,.not-prose *)){white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;hyphens:none;background:transparent;}:is([prose=""],.prose) :where(pre code):not(:where(.not-prose,.not-prose *)){font-weight:inherit;}:is([prose=""],.prose) :where(ol,ul):not(:where(.not-prose,.not-prose *)){padding-left:1.25em;}:is([prose=""],.prose) :where(ol):not(:where(.not-prose,.not-prose *)){list-style-type:decimal;}:is([prose=""],.prose) :where(ol[type="A"]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-alpha;}:is([prose=""],.prose) :where(ol[type="a"]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-alpha;}:is([prose=""],.prose) :where(ol[type="A" s]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-alpha;}:is([prose=""],.prose) :where(ol[type="a" s]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-alpha;}:is([prose=""],.prose) :where(ol[type="I"]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-roman;}:is([prose=""],.prose) :where(ol[type="i"]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-roman;}:is([prose=""],.prose) :where(ol[type="I" s]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-roman;}:is([prose=""],.prose) :where(ol[type="i" s]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-roman;}:is([prose=""],.prose) :where(ol[type="1"]):not(:where(.not-prose,.not-prose *)){list-style-type:decimal;}:is([prose=""],.prose) :where(ul):not(:where(.not-prose,.not-prose *)){list-style-type:disc;}:is([prose=""],.prose) :where(ol > li):not(:where(.not-prose,.not-prose *))::marker,:is([prose=""],.prose) :where(ul > li):not(:where(.not-prose,.not-prose *))::marker,:is([prose=""],.prose) :where(summary):not(:where(.not-prose,.not-prose *))::marker{color:var(--un-prose-lists);}:is([prose=""],.prose) :where(hr):not(:where(.not-prose,.not-prose *)){margin:2em 0;border:1px solid var(--un-prose-hr);}:is([prose=""],.prose) :where(table):not(:where(.not-prose,.not-prose *)){display:block;margin:1em 0;border-collapse:collapse;overflow-x:auto;}:is([prose=""],.prose) :where(tr):not(:where(.not-prose,.not-prose *)):nth-child(2n){background:var(--un-prose-bg-soft);}:is([prose=""],.prose) :where(td,th):not(:where(.not-prose,.not-prose *)){border:1px solid var(--un-prose-borders);padding:.625em 1em;}:is([prose=""],.prose) :where(abbr):not(:where(.not-prose,.not-prose *)){cursor:help;}:is([prose=""],.prose) :where(kbd):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-code);border:1px solid;padding:.25rem .5rem;font-size:.875em;border-radius:.25rem;}:is([prose=""],.prose) :where(details):not(:where(.not-prose,.not-prose *)){margin:1em 0;padding:1.25rem 1.5rem;background:var(--un-prose-bg-soft);}:is([prose=""],.prose) :where(summary):not(:where(.not-prose,.not-prose *)){cursor:pointer;font-weight:600;}
/* layer: default */
.static{position:static;}`
];
jr([
  De()
], mt.prototype, "_time", 2);
jr([
  J(".clock__date")
], mt.prototype, "clockElement", 2);
jr([
  J(".clock__time")
], mt.prototype, "timeElement", 2);
jr([
  J(".dropdown-icon")
], mt.prototype, "icon", 2);
jr([
  y({ type: Boolean, reflect: !0 })
], mt.prototype, "date", 2);
jr([
  y({ type: Boolean, reflect: !0 })
], mt.prototype, "time", 2);
jr([
  y({ type: String, reflect: !0 })
], mt.prototype, "size", 2);
mt = jr([
  Mr("clock-it")
], mt);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
class Wa extends hl {
  constructor(e) {
    if (super(e), this.et = de, e.type !== tr.CHILD)
      throw Error(this.constructor.directiveName + "() can only be used in child bindings");
  }
  render(e) {
    if (e === de || e == null)
      return this.vt = void 0, this.et = e;
    if (e === pt)
      return e;
    if (typeof e != "string")
      throw Error(this.constructor.directiveName + "() called with a non-string value");
    if (e === this.et)
      return this.vt;
    this.et = e;
    const t = [e];
    return t.raw = t, this.vt = { _$litType$: this.constructor.resultType, strings: t, values: [] };
  }
}
Wa.directiveName = "unsafeHTML", Wa.resultType = 1;
const Va = al(Wa);
var dy = re`
  ${We}

  :host {
    display: inline-block;
    color: var(--sl-color-neutral-600);
  }

  .icon-button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    background: none;
    border: none;
    border-radius: var(--sl-border-radius-medium);
    font-size: inherit;
    color: inherit;
    padding: var(--sl-spacing-x-small);
    cursor: pointer;
    transition: var(--sl-transition-x-fast) color;
    -webkit-appearance: none;
  }

  .icon-button:hover:not(.icon-button--disabled),
  .icon-button:focus-visible:not(.icon-button--disabled) {
    color: var(--sl-color-primary-600);
  }

  .icon-button:active:not(.icon-button--disabled) {
    color: var(--sl-color-primary-700);
  }

  .icon-button:focus {
    outline: none;
  }

  .icon-button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .icon-button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .icon-button__icon {
    pointer-events: none;
  }
`, at = class extends ve {
  constructor() {
    super(...arguments), this.hasFocus = !1, this.label = "", this.disabled = !1;
  }
  handleBlur() {
    this.hasFocus = !1, this.emit("sl-blur");
  }
  handleFocus() {
    this.hasFocus = !0, this.emit("sl-focus");
  }
  handleClick(r) {
    this.disabled && (r.preventDefault(), r.stopPropagation());
  }
  /** Simulates a click on the icon button. */
  click() {
    this.button.click();
  }
  /** Sets focus on the icon button. */
  focus(r) {
    this.button.focus(r);
  }
  /** Removes focus from the icon button. */
  blur() {
    this.button.blur();
  }
  render() {
    const r = !!this.href, e = r ? ko`a` : ko`button`;
    return lo`
      <${e}
        part="base"
        class=${je({
      "icon-button": !0,
      "icon-button--disabled": !r && this.disabled,
      "icon-button--focused": this.hasFocus
    })}
        ?disabled=${I(r ? void 0 : this.disabled)}
        type=${I(r ? void 0 : "button")}
        href=${I(r ? this.href : void 0)}
        target=${I(r ? this.target : void 0)}
        download=${I(r ? this.download : void 0)}
        rel=${I(r && this.target ? "noreferrer noopener" : void 0)}
        role=${I(r ? void 0 : "button")}
        aria-disabled=${this.disabled ? "true" : "false"}
        aria-label="${this.label}"
        tabindex=${this.disabled ? "-1" : "0"}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @click=${this.handleClick}
      >
        <sl-icon
          class="icon-button__icon"
          name=${I(this.name)}
          library=${I(this.library)}
          src=${I(this.src)}
          aria-hidden="true"
        ></sl-icon>
      </${e}>
    `;
  }
};
at.styles = dy;
at.dependencies = { "sl-icon": vt };
w([
  J(".icon-button")
], at.prototype, "button", 2);
w([
  De()
], at.prototype, "hasFocus", 2);
w([
  y()
], at.prototype, "name", 2);
w([
  y()
], at.prototype, "library", 2);
w([
  y()
], at.prototype, "src", 2);
w([
  y()
], at.prototype, "href", 2);
w([
  y()
], at.prototype, "target", 2);
w([
  y()
], at.prototype, "download", 2);
w([
  y()
], at.prototype, "label", 2);
w([
  y({ type: Boolean, reflect: !0 })
], at.prototype, "disabled", 2);
var py = re`
  ${We}

  :host {
    display: contents;

    /* For better DX, we'll reset the margin here so the base part can inherit it */
    margin: 0;
  }

  .alert {
    position: relative;
    display: flex;
    align-items: stretch;
    background-color: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-top-width: calc(var(--sl-panel-border-width) * 3);
    border-radius: var(--sl-border-radius-medium);
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-normal);
    line-height: 1.6;
    color: var(--sl-color-neutral-700);
    margin: inherit;
  }

  .alert:not(.alert--has-icon) .alert__icon,
  .alert:not(.alert--closable) .alert__close-button {
    display: none;
  }

  .alert__icon {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    font-size: var(--sl-font-size-large);
    padding-inline-start: var(--sl-spacing-large);
  }

  .alert--primary {
    border-top-color: var(--sl-color-primary-600);
  }

  .alert--primary .alert__icon {
    color: var(--sl-color-primary-600);
  }

  .alert--success {
    border-top-color: var(--sl-color-success-600);
  }

  .alert--success .alert__icon {
    color: var(--sl-color-success-600);
  }

  .alert--neutral {
    border-top-color: var(--sl-color-neutral-600);
  }

  .alert--neutral .alert__icon {
    color: var(--sl-color-neutral-600);
  }

  .alert--warning {
    border-top-color: var(--sl-color-warning-600);
  }

  .alert--warning .alert__icon {
    color: var(--sl-color-warning-600);
  }

  .alert--danger {
    border-top-color: var(--sl-color-danger-600);
  }

  .alert--danger .alert__icon {
    color: var(--sl-color-danger-600);
  }

  .alert__message {
    flex: 1 1 auto;
    display: block;
    padding: var(--sl-spacing-large);
    overflow: hidden;
  }

  .alert__close-button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    font-size: var(--sl-font-size-medium);
    padding-inline-end: var(--sl-spacing-medium);
  }
`, wi = Object.assign(document.createElement("div"), { className: "sl-toast-stack" }), Ht = class extends ve {
  constructor() {
    super(...arguments), this.hasSlotController = new ms(this, "icon", "suffix"), this.localize = new Vr(this), this.open = !1, this.closable = !1, this.variant = "primary", this.duration = 1 / 0;
  }
  firstUpdated() {
    this.base.hidden = !this.open;
  }
  restartAutoHide() {
    clearTimeout(this.autoHideTimeout), this.open && this.duration < 1 / 0 && (this.autoHideTimeout = window.setTimeout(() => this.hide(), this.duration));
  }
  handleCloseClick() {
    this.hide();
  }
  handleMouseMove() {
    this.restartAutoHide();
  }
  async handleOpenChange() {
    if (this.open) {
      this.emit("sl-show"), this.duration < 1 / 0 && this.restartAutoHide(), await ji(this.base), this.base.hidden = !1;
      const { keyframes: r, options: e } = Wi(this, "alert.show", { dir: this.localize.dir() });
      await Mi(this.base, r, e), this.emit("sl-after-show");
    } else {
      this.emit("sl-hide"), clearTimeout(this.autoHideTimeout), await ji(this.base);
      const { keyframes: r, options: e } = Wi(this, "alert.hide", { dir: this.localize.dir() });
      await Mi(this.base, r, e), this.base.hidden = !0, this.emit("sl-after-hide");
    }
  }
  handleDurationChange() {
    this.restartAutoHide();
  }
  /** Shows the alert. */
  async show() {
    if (!this.open)
      return this.open = !0, Vi(this, "sl-after-show");
  }
  /** Hides the alert */
  async hide() {
    if (this.open)
      return this.open = !1, Vi(this, "sl-after-hide");
  }
  /**
   * Displays the alert as a toast notification. This will move the alert out of its position in the DOM and, when
   * dismissed, it will be removed from the DOM completely. By storing a reference to the alert, you can reuse it by
   * calling this method again. The returned promise will resolve after the alert is hidden.
   */
  async toast() {
    return new Promise((r) => {
      wi.parentElement === null && document.body.append(wi), wi.appendChild(this), requestAnimationFrame(() => {
        this.clientWidth, this.show();
      }), this.addEventListener(
        "sl-after-hide",
        () => {
          wi.removeChild(this), r(), wi.querySelector("sl-alert") === null && wi.remove();
        },
        { once: !0 }
      );
    });
  }
  render() {
    return X`
      <div
        part="base"
        class=${je({
      alert: !0,
      "alert--open": this.open,
      "alert--closable": this.closable,
      "alert--has-icon": this.hasSlotController.test("icon"),
      "alert--primary": this.variant === "primary",
      "alert--success": this.variant === "success",
      "alert--neutral": this.variant === "neutral",
      "alert--warning": this.variant === "warning",
      "alert--danger": this.variant === "danger"
    })}
        role="alert"
        aria-hidden=${this.open ? "false" : "true"}
        @mousemove=${this.handleMouseMove}
      >
        <div part="icon" class="alert__icon">
          <slot name="icon"></slot>
        </div>

        <div part="message" class="alert__message" aria-live="polite">
          <slot></slot>
        </div>

        ${this.closable ? X`
              <sl-icon-button
                part="close-button"
                exportparts="base:close-button__base"
                class="alert__close-button"
                name="x-lg"
                library="system"
                label=${this.localize.term("close")}
                @click=${this.handleCloseClick}
              ></sl-icon-button>
            ` : ""}
      </div>
    `;
  }
};
Ht.styles = py;
Ht.dependencies = { "sl-icon-button": at };
w([
  J('[part~="base"]')
], Ht.prototype, "base", 2);
w([
  y({ type: Boolean, reflect: !0 })
], Ht.prototype, "open", 2);
w([
  y({ type: Boolean, reflect: !0 })
], Ht.prototype, "closable", 2);
w([
  y({ reflect: !0 })
], Ht.prototype, "variant", 2);
w([
  y({ type: Number })
], Ht.prototype, "duration", 2);
w([
  $e("open", { waitUntilFirstUpdate: !0 })
], Ht.prototype, "handleOpenChange", 1);
w([
  $e("duration")
], Ht.prototype, "handleDurationChange", 1);
en("alert.show", {
  keyframes: [
    { opacity: 0, scale: 0.8 },
    { opacity: 1, scale: 1 }
  ],
  options: { duration: 250, easing: "ease" }
});
en("alert.hide", {
  keyframes: [
    { opacity: 1, scale: 1 },
    { opacity: 0, scale: 0.8 }
  ],
  options: { duration: 250, easing: "ease" }
});
Ht.define("sl-alert");
var fy = re`
  ${We}

  :host {
    display: inline-flex;
  }

  .badge {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: max(12px, 0.75em);
    font-weight: var(--sl-font-weight-semibold);
    letter-spacing: var(--sl-letter-spacing-normal);
    line-height: 1;
    border-radius: var(--sl-border-radius-small);
    border: solid 1px var(--sl-color-neutral-0);
    white-space: nowrap;
    padding: 0.35em 0.6em;
    user-select: none;
    -webkit-user-select: none;
    cursor: inherit;
  }

  /* Variant modifiers */
  .badge--primary {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .badge--success {
    background-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .badge--neutral {
    background-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .badge--warning {
    background-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  .badge--danger {
    background-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  /* Pill modifier */
  .badge--pill {
    border-radius: var(--sl-border-radius-pill);
  }

  /* Pulse modifier */
  .badge--pulse {
    animation: pulse 1.5s infinite;
  }

  .badge--pulse.badge--primary {
    --pulse-color: var(--sl-color-primary-600);
  }

  .badge--pulse.badge--success {
    --pulse-color: var(--sl-color-success-600);
  }

  .badge--pulse.badge--neutral {
    --pulse-color: var(--sl-color-neutral-600);
  }

  .badge--pulse.badge--warning {
    --pulse-color: var(--sl-color-warning-600);
  }

  .badge--pulse.badge--danger {
    --pulse-color: var(--sl-color-danger-600);
  }

  @keyframes pulse {
    0% {
      box-shadow: 0 0 0 0 var(--pulse-color);
    }
    70% {
      box-shadow: 0 0 0 0.5rem transparent;
    }
    100% {
      box-shadow: 0 0 0 0 transparent;
    }
  }
`, ws = class extends ve {
  constructor() {
    super(...arguments), this.variant = "primary", this.pill = !1, this.pulse = !1;
  }
  render() {
    return X`
      <span
        part="base"
        class=${je({
      badge: !0,
      "badge--primary": this.variant === "primary",
      "badge--success": this.variant === "success",
      "badge--neutral": this.variant === "neutral",
      "badge--warning": this.variant === "warning",
      "badge--danger": this.variant === "danger",
      "badge--pill": this.pill,
      "badge--pulse": this.pulse
    })}
        role="status"
      >
        <slot></slot>
      </span>
    `;
  }
};
ws.styles = fy;
w([
  y({ reflect: !0 })
], ws.prototype, "variant", 2);
w([
  y({ type: Boolean, reflect: !0 })
], ws.prototype, "pill", 2);
w([
  y({ type: Boolean, reflect: !0 })
], ws.prototype, "pulse", 2);
ws.define("sl-badge");
var Oy = re`
  ${We}

  :host {
    display: inline-block;
  }

  .button-group {
    display: flex;
    flex-wrap: nowrap;
  }
`, ys = class extends ve {
  constructor() {
    super(...arguments), this.disableRole = !1, this.label = "";
  }
  handleFocus(r) {
    const e = dn(r.target);
    e == null || e.classList.add("sl-button-group__button--focus");
  }
  handleBlur(r) {
    const e = dn(r.target);
    e == null || e.classList.remove("sl-button-group__button--focus");
  }
  handleMouseOver(r) {
    const e = dn(r.target);
    e == null || e.classList.add("sl-button-group__button--hover");
  }
  handleMouseOut(r) {
    const e = dn(r.target);
    e == null || e.classList.remove("sl-button-group__button--hover");
  }
  handleSlotChange() {
    const r = [...this.defaultSlot.assignedElements({ flatten: !0 })];
    r.forEach((e) => {
      const t = r.indexOf(e), i = dn(e);
      i && (i.classList.add("sl-button-group__button"), i.classList.toggle("sl-button-group__button--first", t === 0), i.classList.toggle("sl-button-group__button--inner", t > 0 && t < r.length - 1), i.classList.toggle("sl-button-group__button--last", t === r.length - 1), i.classList.toggle("sl-button-group__button--radio", i.tagName.toLowerCase() === "sl-radio-button"));
    });
  }
  render() {
    return X`
      <div
        part="base"
        class="button-group"
        role="${this.disableRole ? "presentation" : "group"}"
        aria-label=${this.label}
        @focusout=${this.handleBlur}
        @focusin=${this.handleFocus}
        @mouseover=${this.handleMouseOver}
        @mouseout=${this.handleMouseOut}
      >
        <slot @slotchange=${this.handleSlotChange}></slot>
      </div>
    `;
  }
};
ys.styles = Oy;
w([
  J("slot")
], ys.prototype, "defaultSlot", 2);
w([
  De()
], ys.prototype, "disableRole", 2);
w([
  y()
], ys.prototype, "label", 2);
function dn(r) {
  var e;
  const t = "sl-button, sl-radio-button";
  return (e = r.closest(t)) != null ? e : r.querySelector(t);
}
ys.define("sl-button-group");
var my = re`
  ${We}

  :host {
    --max-width: 20rem;
    --hide-delay: 0ms;
    --show-delay: 150ms;

    display: contents;
  }

  .tooltip {
    --arrow-size: var(--sl-tooltip-arrow-size);
    --arrow-color: var(--sl-tooltip-background-color);
  }

  .tooltip::part(popup) {
    pointer-events: none;
    z-index: var(--sl-z-index-tooltip);
  }

  .tooltip[placement^='top']::part(popup) {
    transform-origin: bottom;
  }

  .tooltip[placement^='bottom']::part(popup) {
    transform-origin: top;
  }

  .tooltip[placement^='left']::part(popup) {
    transform-origin: right;
  }

  .tooltip[placement^='right']::part(popup) {
    transform-origin: left;
  }

  .tooltip__body {
    display: block;
    width: max-content;
    max-width: var(--max-width);
    border-radius: var(--sl-tooltip-border-radius);
    background-color: var(--sl-tooltip-background-color);
    font-family: var(--sl-tooltip-font-family);
    font-size: var(--sl-tooltip-font-size);
    font-weight: var(--sl-tooltip-font-weight);
    line-height: var(--sl-tooltip-line-height);
    color: var(--sl-tooltip-color);
    padding: var(--sl-tooltip-padding);
    pointer-events: none;
    user-select: none;
    -webkit-user-select: none;
  }
`, Re = class extends ve {
  constructor() {
    super(), this.localize = new Vr(this), this.content = "", this.placement = "top", this.disabled = !1, this.distance = 8, this.open = !1, this.skidding = 0, this.trigger = "hover focus", this.hoist = !1, this.handleBlur = () => {
      this.hasTrigger("focus") && this.hide();
    }, this.handleClick = () => {
      this.hasTrigger("click") && (this.open ? this.hide() : this.show());
    }, this.handleFocus = () => {
      this.hasTrigger("focus") && this.show();
    }, this.handleKeyDown = (r) => {
      this.open && !this.disabled && r.key === "Escape" && (r.stopPropagation(), this.hide());
    }, this.handleMouseOver = () => {
      if (this.hasTrigger("hover")) {
        const r = Yu(getComputedStyle(this).getPropertyValue("--show-delay"));
        clearTimeout(this.hoverTimeout), this.hoverTimeout = window.setTimeout(() => this.show(), r);
      }
    }, this.handleMouseOut = () => {
      if (this.hasTrigger("hover")) {
        const r = Yu(getComputedStyle(this).getPropertyValue("--hide-delay"));
        clearTimeout(this.hoverTimeout), this.hoverTimeout = window.setTimeout(() => this.hide(), r);
      }
    }, this.addEventListener("blur", this.handleBlur, !0), this.addEventListener("focus", this.handleFocus, !0), this.addEventListener("click", this.handleClick), this.addEventListener("keydown", this.handleKeyDown), this.addEventListener("mouseover", this.handleMouseOver), this.addEventListener("mouseout", this.handleMouseOut);
  }
  connectedCallback() {
    super.connectedCallback();
  }
  firstUpdated() {
    this.body.hidden = !this.open, this.open && (this.popup.active = !0, this.popup.reposition());
  }
  hasTrigger(r) {
    return this.trigger.split(" ").includes(r);
  }
  async handleOpenChange() {
    if (this.open) {
      if (this.disabled)
        return;
      this.emit("sl-show"), await ji(this.body), this.body.hidden = !1, this.popup.active = !0;
      const { keyframes: r, options: e } = Wi(this, "tooltip.show", { dir: this.localize.dir() });
      await Mi(this.popup.popup, r, e), this.emit("sl-after-show");
    } else {
      this.emit("sl-hide"), await ji(this.body);
      const { keyframes: r, options: e } = Wi(this, "tooltip.hide", { dir: this.localize.dir() });
      await Mi(this.popup.popup, r, e), this.popup.active = !1, this.body.hidden = !0, this.emit("sl-after-hide");
    }
  }
  async handleOptionsChange() {
    this.hasUpdated && (await this.updateComplete, this.popup.reposition());
  }
  handleDisabledChange() {
    this.disabled && this.open && this.hide();
  }
  /** Shows the tooltip. */
  async show() {
    if (!this.open)
      return this.open = !0, Vi(this, "sl-after-show");
  }
  /** Hides the tooltip */
  async hide() {
    if (this.open)
      return this.open = !1, Vi(this, "sl-after-hide");
  }
  //
  // NOTE: Tooltip is a bit unique in that we're using aria-live instead of aria-labelledby to trick screen readers into
  // announcing the content. It works really well, but it violates an accessibility rule. We're also adding the
  // aria-describedby attribute to a slot, which is required by <sl-popup> to correctly locate the first assigned
  // element, otherwise positioning is incorrect.
  //
  render() {
    return X`
      <sl-popup
        part="base"
        exportparts="
          popup:base__popup,
          arrow:base__arrow
        "
        class=${je({
      tooltip: !0,
      "tooltip--open": this.open
    })}
        placement=${this.placement}
        distance=${this.distance}
        skidding=${this.skidding}
        strategy=${this.hoist ? "fixed" : "absolute"}
        flip
        shift
        arrow
      >
        ${""}
        <slot slot="anchor" aria-describedby="tooltip"></slot>

        ${""}
        <div part="body" id="tooltip" class="tooltip__body" role="tooltip" aria-live=${this.open ? "polite" : "off"}>
          <slot name="content">${this.content}</slot>
        </div>
      </sl-popup>
    `;
  }
};
Re.styles = my;
Re.dependencies = { "sl-popup": se };
w([
  J("slot:not([name])")
], Re.prototype, "defaultSlot", 2);
w([
  J(".tooltip__body")
], Re.prototype, "body", 2);
w([
  J("sl-popup")
], Re.prototype, "popup", 2);
w([
  y()
], Re.prototype, "content", 2);
w([
  y()
], Re.prototype, "placement", 2);
w([
  y({ type: Boolean, reflect: !0 })
], Re.prototype, "disabled", 2);
w([
  y({ type: Number })
], Re.prototype, "distance", 2);
w([
  y({ type: Boolean, reflect: !0 })
], Re.prototype, "open", 2);
w([
  y({ type: Number })
], Re.prototype, "skidding", 2);
w([
  y()
], Re.prototype, "trigger", 2);
w([
  y({ type: Boolean })
], Re.prototype, "hoist", 2);
w([
  $e("open", { waitUntilFirstUpdate: !0 })
], Re.prototype, "handleOpenChange", 1);
w([
  $e(["content", "distance", "hoist", "placement", "skidding"])
], Re.prototype, "handleOptionsChange", 1);
w([
  $e("disabled")
], Re.prototype, "handleDisabledChange", 1);
en("tooltip.show", {
  keyframes: [
    { opacity: 0, scale: 0.8 },
    { opacity: 1, scale: 1 }
  ],
  options: { duration: 150, easing: "ease" }
});
en("tooltip.hide", {
  keyframes: [
    { opacity: 1, scale: 1 },
    { opacity: 0, scale: 0.8 }
  ],
  options: { duration: 150, easing: "ease" }
});
Re.define("sl-tooltip");
class K {
  /**
  Get the line description around the given position.
  */
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e, t, i) {
    [e, t] = Li(this, e, t);
    let n = [];
    return this.decompose(
      0,
      e,
      n,
      2
      /* Open.To */
    ), i.length && i.decompose(
      0,
      i.length,
      n,
      3
      /* Open.To */
    ), this.decompose(
      t,
      this.length,
      n,
      1
      /* Open.From */
    ), Mt.from(n, this.length - (t - e) + i.length);
  }
  /**
  Append another document to this one.
  */
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e, t = this.length) {
    [e, t] = Li(this, e, t);
    let i = [];
    return this.decompose(e, t, i, 0), Mt.from(i, t - e);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e) {
    if (e == this)
      return !0;
    if (e.length != this.length || e.lines != this.lines)
      return !1;
    let t = this.scanIdentical(e, 1), i = this.length - this.scanIdentical(e, -1), n = new An(this), s = new An(e);
    for (let o = t, l = t; ; ) {
      if (n.next(o), s.next(o), o = 0, n.lineBreak != s.lineBreak || n.done != s.done || n.value != s.value)
        return !1;
      if (l += n.value.length, n.done || l >= i)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(e = 1) {
    return new An(this, e);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e, t = this.length) {
    return new OO(this, e, t);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e, t) {
    let i;
    if (e == null)
      i = this.iter();
    else {
      t == null && (t = this.lines + 1);
      let n = this.line(e).from;
      i = this.iterRange(n, Math.max(n, t == this.lines + 1 ? this.length : t <= 1 ? 0 : this.line(t - 1).to));
    }
    return new mO(i);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? K.empty : e.length <= 32 ? new be(e) : Mt.from(be.split(e, []));
  }
}
class be extends K {
  constructor(e, t = gy(e)) {
    super(), this.text = e, this.length = t;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, t, i, n) {
    for (let s = 0; ; s++) {
      let o = this.text[s], l = n + o.length;
      if ((t ? i : l) >= e)
        return new by(n, l, i, o);
      n = l + 1, i++;
    }
  }
  decompose(e, t, i, n) {
    let s = e <= 0 && t >= this.length ? this : new be(Lu(this.text, e, t), Math.min(t, this.length) - Math.max(0, e));
    if (n & 1) {
      let o = i.pop(), l = ho(s.text, o.text.slice(), 0, s.length);
      if (l.length <= 32)
        i.push(new be(l, o.length + s.length));
      else {
        let a = l.length >> 1;
        i.push(new be(l.slice(0, a)), new be(l.slice(a)));
      }
    } else
      i.push(s);
  }
  replace(e, t, i) {
    if (!(i instanceof be))
      return super.replace(e, t, i);
    [e, t] = Li(this, e, t);
    let n = ho(this.text, ho(i.text, Lu(this.text, 0, e)), t), s = this.length + i.length - (t - e);
    return n.length <= 32 ? new be(n, s) : Mt.from(be.split(n, []), s);
  }
  sliceString(e, t = this.length, i = `
`) {
    [e, t] = Li(this, e, t);
    let n = "";
    for (let s = 0, o = 0; s <= t && o < this.text.length; o++) {
      let l = this.text[o], a = s + l.length;
      s > e && o && (n += i), e < a && t > s && (n += l.slice(Math.max(0, e - s), t - s)), s = a + 1;
    }
    return n;
  }
  flatten(e) {
    for (let t of this.text)
      e.push(t);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, t) {
    let i = [], n = -1;
    for (let s of e)
      i.push(s), n += s.length + 1, i.length == 32 && (t.push(new be(i, n)), i = [], n = -1);
    return n > -1 && t.push(new be(i, n)), t;
  }
}
class Mt extends K {
  constructor(e, t) {
    super(), this.children = e, this.length = t, this.lines = 0;
    for (let i of e)
      this.lines += i.lines;
  }
  lineInner(e, t, i, n) {
    for (let s = 0; ; s++) {
      let o = this.children[s], l = n + o.length, a = i + o.lines - 1;
      if ((t ? a : l) >= e)
        return o.lineInner(e, t, i, n);
      n = l + 1, i = a + 1;
    }
  }
  decompose(e, t, i, n) {
    for (let s = 0, o = 0; o <= t && s < this.children.length; s++) {
      let l = this.children[s], a = o + l.length;
      if (e <= a && t >= o) {
        let h = n & ((o <= e ? 1 : 0) | (a >= t ? 2 : 0));
        o >= e && a <= t && !h ? i.push(l) : l.decompose(e - o, t - o, i, h);
      }
      o = a + 1;
    }
  }
  replace(e, t, i) {
    if ([e, t] = Li(this, e, t), i.lines < this.lines)
      for (let n = 0, s = 0; n < this.children.length; n++) {
        let o = this.children[n], l = s + o.length;
        if (e >= s && t <= l) {
          let a = o.replace(e - s, t - s, i), h = this.lines - o.lines + a.lines;
          if (a.lines < h >> 4 && a.lines > h >> 6) {
            let c = this.children.slice();
            return c[n] = a, new Mt(c, this.length - (t - e) + i.length);
          }
          return super.replace(s, l, a);
        }
        s = l + 1;
      }
    return super.replace(e, t, i);
  }
  sliceString(e, t = this.length, i = `
`) {
    [e, t] = Li(this, e, t);
    let n = "";
    for (let s = 0, o = 0; s < this.children.length && o <= t; s++) {
      let l = this.children[s], a = o + l.length;
      o > e && s && (n += i), e < a && t > o && (n += l.sliceString(e - o, t - o, i)), o = a + 1;
    }
    return n;
  }
  flatten(e) {
    for (let t of this.children)
      t.flatten(e);
  }
  scanIdentical(e, t) {
    if (!(e instanceof Mt))
      return 0;
    let i = 0, [n, s, o, l] = t > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; n += t, s += t) {
      if (n == o || s == l)
        return i;
      let a = this.children[n], h = e.children[s];
      if (a != h)
        return i + a.scanIdentical(h, t);
      i += a.length + 1;
    }
  }
  static from(e, t = e.reduce((i, n) => i + n.length + 1, -1)) {
    let i = 0;
    for (let p of e)
      i += p.lines;
    if (i < 32) {
      let p = [];
      for (let f of e)
        f.flatten(p);
      return new be(p, t);
    }
    let n = Math.max(
      32,
      i >> 5
      /* Tree.BranchShift */
    ), s = n << 1, o = n >> 1, l = [], a = 0, h = -1, c = [];
    function u(p) {
      let f;
      if (p.lines > s && p instanceof Mt)
        for (let m of p.children)
          u(m);
      else
        p.lines > o && (a > o || !a) ? (d(), l.push(p)) : p instanceof be && a && (f = c[c.length - 1]) instanceof be && p.lines + f.lines <= 32 ? (a += p.lines, h += p.length + 1, c[c.length - 1] = new be(f.text.concat(p.text), f.length + 1 + p.length)) : (a + p.lines > n && d(), a += p.lines, h += p.length + 1, c.push(p));
    }
    function d() {
      a != 0 && (l.push(c.length == 1 ? c[0] : Mt.from(c, h)), h = -1, a = c.length = 0);
    }
    for (let p of e)
      u(p);
    return d(), l.length == 1 ? l[0] : new Mt(l, t);
  }
}
K.empty = /* @__PURE__ */ new be([""], 0);
function gy(r) {
  let e = -1;
  for (let t of r)
    e += t.length + 1;
  return e;
}
function ho(r, e, t = 0, i = 1e9) {
  for (let n = 0, s = 0, o = !0; s < r.length && n <= i; s++) {
    let l = r[s], a = n + l.length;
    a >= t && (a > i && (l = l.slice(0, i - n)), n < t && (l = l.slice(t - n)), o ? (e[e.length - 1] += l, o = !1) : e.push(l)), n = a + 1;
  }
  return e;
}
function Lu(r, e, t) {
  return ho(r, [""], e, t);
}
class An {
  constructor(e, t = 1) {
    this.dir = t, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [t > 0 ? 1 : (e instanceof be ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, t) {
    for (this.done = this.lineBreak = !1; ; ) {
      let i = this.nodes.length - 1, n = this.nodes[i], s = this.offsets[i], o = s >> 1, l = n instanceof be ? n.text.length : n.children.length;
      if (o == (t > 0 ? l : 0)) {
        if (i == 0)
          return this.done = !0, this.value = "", this;
        t > 0 && this.offsets[i - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((s & 1) == (t > 0 ? 0 : 1)) {
        if (this.offsets[i] += t, e == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        e--;
      } else if (n instanceof be) {
        let a = n.text[o + (t < 0 ? -1 : 0)];
        if (this.offsets[i] += t, a.length > Math.max(0, e))
          return this.value = e == 0 ? a : t > 0 ? a.slice(e) : a.slice(0, a.length - e), this;
        e -= a.length;
      } else {
        let a = n.children[o + (t < 0 ? -1 : 0)];
        e > a.length ? (e -= a.length, this.offsets[i] += t) : (t < 0 && this.offsets[i]--, this.nodes.push(a), this.offsets.push(t > 0 ? 1 : (a instanceof be ? a.text.length : a.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
}
class OO {
  constructor(e, t, i) {
    this.value = "", this.done = !1, this.cursor = new An(e, t > i ? -1 : 1), this.pos = t > i ? e.length : 0, this.from = Math.min(t, i), this.to = Math.max(t, i);
  }
  nextInner(e, t) {
    if (t < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    e += Math.max(0, t < 0 ? this.pos - this.to : this.from - this.pos);
    let i = t < 0 ? this.pos - this.from : this.to - this.pos;
    e > i && (e = i), i -= e;
    let { value: n } = this.cursor.next(e);
    return this.pos += (n.length + e) * t, this.value = n.length <= i ? n : t < 0 ? n.slice(n.length - i) : n.slice(0, i), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class mO {
  constructor(e) {
    this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(e = 0) {
    let { done: t, lineBreak: i, value: n } = this.inner.next(e);
    return t && this.afterBreak ? (this.value = "", this.afterBreak = !1) : t ? (this.done = !0, this.value = "") : i ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = n, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (K.prototype[Symbol.iterator] = function() {
  return this.iter();
}, An.prototype[Symbol.iterator] = OO.prototype[Symbol.iterator] = mO.prototype[Symbol.iterator] = function() {
  return this;
});
let by = class {
  /**
  @internal
  */
  constructor(e, t, i, n) {
    this.from = e, this.to = t, this.number = i, this.text = n;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
};
function Li(r, e, t) {
  return e = Math.max(0, Math.min(r.length, e)), [e, Math.max(e, Math.min(r.length, t))];
}
let Ci = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((r) => r ? parseInt(r, 36) : 1);
for (let r = 1; r < Ci.length; r++)
  Ci[r] += Ci[r - 1];
function wy(r) {
  for (let e = 1; e < Ci.length; e += 2)
    if (Ci[e] > r)
      return Ci[e - 1] <= r;
  return !1;
}
function Bu(r) {
  return r >= 127462 && r <= 127487;
}
const Du = 8205;
function _e(r, e, t = !0, i = !0) {
  return (t ? gO : yy)(r, e, i);
}
function gO(r, e, t) {
  if (e == r.length)
    return e;
  e && bO(r.charCodeAt(e)) && wO(r.charCodeAt(e - 1)) && e--;
  let i = Te(r, e);
  for (e += dt(i); e < r.length; ) {
    let n = Te(r, e);
    if (i == Du || n == Du || t && wy(n))
      e += dt(n), i = n;
    else if (Bu(n)) {
      let s = 0, o = e - 2;
      for (; o >= 0 && Bu(Te(r, o)); )
        s++, o -= 2;
      if (s % 2 == 0)
        break;
      e += 2;
    } else
      break;
  }
  return e;
}
function yy(r, e, t) {
  for (; e > 0; ) {
    let i = gO(r, e - 2, t);
    if (i < e)
      return i;
    e--;
  }
  return 0;
}
function bO(r) {
  return r >= 56320 && r < 57344;
}
function wO(r) {
  return r >= 55296 && r < 56320;
}
function Te(r, e) {
  let t = r.charCodeAt(e);
  if (!wO(t) || e + 1 == r.length)
    return t;
  let i = r.charCodeAt(e + 1);
  return bO(i) ? (t - 55296 << 10) + (i - 56320) + 65536 : t;
}
function cc(r) {
  return r <= 65535 ? String.fromCharCode(r) : (r -= 65536, String.fromCharCode((r >> 10) + 55296, (r & 1023) + 56320));
}
function dt(r) {
  return r < 65536 ? 1 : 2;
}
const Ma = /\r\n?|\n/;
var Xe = /* @__PURE__ */ function(r) {
  return r[r.Simple = 0] = "Simple", r[r.TrackDel = 1] = "TrackDel", r[r.TrackBefore = 2] = "TrackBefore", r[r.TrackAfter = 3] = "TrackAfter", r;
}(Xe || (Xe = {}));
class It {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e) {
    this.sections = e;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2)
      e += this.sections[t];
    return e;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2) {
      let i = this.sections[t + 1];
      e += i < 0 ? this.sections[t] : i;
    }
    return e;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(e) {
    for (let t = 0, i = 0, n = 0; t < this.sections.length; ) {
      let s = this.sections[t++], o = this.sections[t++];
      o < 0 ? (e(i, n, s), n += s) : n += o, i += s;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e, t = !1) {
    ja(this, e, t);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e = [];
    for (let t = 0; t < this.sections.length; ) {
      let i = this.sections[t++], n = this.sections[t++];
      n < 0 ? e.push(i, n) : e.push(n, i);
    }
    return new It(e);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : yO(this, e);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `other` happened before the ones in `this`.
  */
  mapDesc(e, t = !1) {
    return e.empty ? this : La(this, e, t);
  }
  mapPos(e, t = -1, i = Xe.Simple) {
    let n = 0, s = 0;
    for (let o = 0; o < this.sections.length; ) {
      let l = this.sections[o++], a = this.sections[o++], h = n + l;
      if (a < 0) {
        if (h > e)
          return s + (e - n);
        s += l;
      } else {
        if (i != Xe.Simple && h >= e && (i == Xe.TrackDel && n < e && h > e || i == Xe.TrackBefore && n < e || i == Xe.TrackAfter && h > e))
          return null;
        if (h > e || h == e && t < 0 && !l)
          return e == n || t < 0 ? s : s + a;
        s += a;
      }
      n = h;
    }
    if (e > n)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${n}`);
    return s;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e, t = e) {
    for (let i = 0, n = 0; i < this.sections.length && n <= t; ) {
      let s = this.sections[i++], o = this.sections[i++], l = n + s;
      if (o >= 0 && n <= t && l >= e)
        return n < e && l > t ? "cover" : !0;
      n = l;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let t = 0; t < this.sections.length; ) {
      let i = this.sections[t++], n = this.sections[t++];
      e += (e ? " " : "") + i + (n >= 0 ? ":" + n : "");
    }
    return e;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((t) => typeof t != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new It(e);
  }
  /**
  @internal
  */
  static create(e) {
    return new It(e);
  }
}
class ke extends It {
  constructor(e, t) {
    super(e), this.inserted = t;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return ja(this, (t, i, n, s, o) => e = e.replace(n, n + (i - t), o), !1), e;
  }
  mapDesc(e, t = !1) {
    return La(this, e, t, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e) {
    let t = this.sections.slice(), i = [];
    for (let n = 0, s = 0; n < t.length; n += 2) {
      let o = t[n], l = t[n + 1];
      if (l >= 0) {
        t[n] = l, t[n + 1] = o;
        let a = n >> 1;
        for (; i.length < a; )
          i.push(K.empty);
        i.push(o ? e.slice(s, s + o) : K.empty);
      }
      s += o;
    }
    return new ke(t, i);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */
  compose(e) {
    return this.empty ? e : e.empty ? this : yO(this, e, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e, t = !1) {
    return e.empty ? this : La(this, e, t, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e, t = !1) {
    ja(this, e, t);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return It.create(this.sections);
  }
  /**
  @internal
  */
  filter(e) {
    let t = [], i = [], n = [], s = new In(this);
    e:
      for (let o = 0, l = 0; ; ) {
        let a = o == e.length ? 1e9 : e[o++];
        for (; l < a || l == a && s.len == 0; ) {
          if (s.done)
            break e;
          let c = Math.min(s.len, a - l);
          qe(n, c, -1);
          let u = s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0;
          qe(t, c, u), u > 0 && vr(i, t, s.text), s.forward(c), l += c;
        }
        let h = e[o++];
        for (; l < h; ) {
          if (s.done)
            break e;
          let c = Math.min(s.len, h - l);
          qe(t, c, -1), qe(n, c, s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0), s.forward(c), l += c;
        }
      }
    return {
      changes: new ke(t, i),
      filtered: It.create(n)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e = [];
    for (let t = 0; t < this.sections.length; t += 2) {
      let i = this.sections[t], n = this.sections[t + 1];
      n < 0 ? e.push(i) : n == 0 ? e.push([i]) : e.push([i].concat(this.inserted[t >> 1].toJSON()));
    }
    return e;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e, t, i) {
    let n = [], s = [], o = 0, l = null;
    function a(c = !1) {
      if (!c && !n.length)
        return;
      o < t && qe(n, t - o, -1);
      let u = new ke(n, s);
      l = l ? l.compose(u.map(l)) : u, n = [], s = [], o = 0;
    }
    function h(c) {
      if (Array.isArray(c))
        for (let u of c)
          h(u);
      else if (c instanceof ke) {
        if (c.length != t)
          throw new RangeError(`Mismatched change set length (got ${c.length}, expected ${t})`);
        a(), l = l ? l.compose(c.map(l)) : c;
      } else {
        let { from: u, to: d = u, insert: p } = c;
        if (u > d || u < 0 || d > t)
          throw new RangeError(`Invalid change range ${u} to ${d} (in doc of length ${t})`);
        let f = p ? typeof p == "string" ? K.of(p.split(i || Ma)) : p : K.empty, m = f.length;
        if (u == d && m == 0)
          return;
        u < o && a(), u > o && qe(n, u - o, -1), qe(n, d - u, m), vr(s, n, f), o = d;
      }
    }
    return h(e), a(!l), l;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e) {
    return new ke(e ? [e, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let t = [], i = [];
    for (let n = 0; n < e.length; n++) {
      let s = e[n];
      if (typeof s == "number")
        t.push(s, -1);
      else {
        if (!Array.isArray(s) || typeof s[0] != "number" || s.some((o, l) => l && typeof o != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (s.length == 1)
          t.push(s[0], 0);
        else {
          for (; i.length < n; )
            i.push(K.empty);
          i[n] = K.of(s.slice(1)), t.push(s[0], i[n].length);
        }
      }
    }
    return new ke(t, i);
  }
  /**
  @internal
  */
  static createSet(e, t) {
    return new ke(e, t);
  }
}
function qe(r, e, t, i = !1) {
  if (e == 0 && t <= 0)
    return;
  let n = r.length - 2;
  n >= 0 && t <= 0 && t == r[n + 1] ? r[n] += e : e == 0 && r[n] == 0 ? r[n + 1] += t : i ? (r[n] += e, r[n + 1] += t) : r.push(e, t);
}
function vr(r, e, t) {
  if (t.length == 0)
    return;
  let i = e.length - 2 >> 1;
  if (i < r.length)
    r[r.length - 1] = r[r.length - 1].append(t);
  else {
    for (; r.length < i; )
      r.push(K.empty);
    r.push(t);
  }
}
function ja(r, e, t) {
  let i = r.inserted;
  for (let n = 0, s = 0, o = 0; o < r.sections.length; ) {
    let l = r.sections[o++], a = r.sections[o++];
    if (a < 0)
      n += l, s += l;
    else {
      let h = n, c = s, u = K.empty;
      for (; h += l, c += a, a && i && (u = u.append(i[o - 2 >> 1])), !(t || o == r.sections.length || r.sections[o + 1] < 0); )
        l = r.sections[o++], a = r.sections[o++];
      e(n, h, s, c, u), n = h, s = c;
    }
  }
}
function La(r, e, t, i = !1) {
  let n = [], s = i ? [] : null, o = new In(r), l = new In(e);
  for (let a = -1; ; )
    if (o.ins == -1 && l.ins == -1) {
      let h = Math.min(o.len, l.len);
      qe(n, h, -1), o.forward(h), l.forward(h);
    } else if (l.ins >= 0 && (o.ins < 0 || a == o.i || o.off == 0 && (l.len < o.len || l.len == o.len && !t))) {
      let h = l.len;
      for (qe(n, l.ins, -1); h; ) {
        let c = Math.min(o.len, h);
        o.ins >= 0 && a < o.i && o.len <= c && (qe(n, 0, o.ins), s && vr(s, n, o.text), a = o.i), o.forward(c), h -= c;
      }
      l.next();
    } else if (o.ins >= 0) {
      let h = 0, c = o.len;
      for (; c; )
        if (l.ins == -1) {
          let u = Math.min(c, l.len);
          h += u, c -= u, l.forward(u);
        } else if (l.ins == 0 && l.len < c)
          c -= l.len, l.next();
        else
          break;
      qe(n, h, a < o.i ? o.ins : 0), s && a < o.i && vr(s, n, o.text), a = o.i, o.forward(o.len - c);
    } else {
      if (o.done && l.done)
        return s ? ke.createSet(n, s) : It.create(n);
      throw new Error("Mismatched change set lengths");
    }
}
function yO(r, e, t = !1) {
  let i = [], n = t ? [] : null, s = new In(r), o = new In(e);
  for (let l = !1; ; ) {
    if (s.done && o.done)
      return n ? ke.createSet(i, n) : It.create(i);
    if (s.ins == 0)
      qe(i, s.len, 0, l), s.next();
    else if (o.len == 0 && !o.done)
      qe(i, 0, o.ins, l), n && vr(n, i, o.text), o.next();
    else {
      if (s.done || o.done)
        throw new Error("Mismatched change set lengths");
      {
        let a = Math.min(s.len2, o.len), h = i.length;
        if (s.ins == -1) {
          let c = o.ins == -1 ? -1 : o.off ? 0 : o.ins;
          qe(i, a, c, l), n && c && vr(n, i, o.text);
        } else
          o.ins == -1 ? (qe(i, s.off ? 0 : s.len, a, l), n && vr(n, i, s.textBit(a))) : (qe(i, s.off ? 0 : s.len, o.off ? 0 : o.ins, l), n && !o.off && vr(n, i, o.text));
        l = (s.ins > a || o.ins >= 0 && o.len > a) && (l || i.length > h), s.forward2(a), o.forward(a);
      }
    }
  }
}
class In {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, t = this.i - 2 >> 1;
    return t >= e.length ? K.empty : e[t];
  }
  textBit(e) {
    let { inserted: t } = this.set, i = this.i - 2 >> 1;
    return i >= t.length && !e ? K.empty : t[i].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
}
class ii {
  constructor(e, t, i) {
    this.from = e, this.to = t, this.flags = i;
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e = this.flags & 7;
    return e == 7 ? null : e;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e = this.flags >> 6;
    return e == 16777215 ? void 0 : e;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e, t = -1) {
    let i, n;
    return this.empty ? i = n = e.mapPos(this.from, t) : (i = e.mapPos(this.from, 1), n = e.mapPos(this.to, -1)), i == this.from && n == this.to ? this : new ii(i, n, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e, t = e) {
    if (e <= this.anchor && t >= this.anchor)
      return S.range(e, t);
    let i = Math.abs(e - this.anchor) > Math.abs(t - this.anchor) ? e : t;
    return S.range(this.anchor, i);
  }
  /**
  Compare this range to another range.
  */
  eq(e, t = !1) {
    return this.anchor == e.anchor && this.head == e.head && (!t || !this.empty || this.assoc == e.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return S.range(e.anchor, e.head);
  }
  /**
  @internal
  */
  static create(e, t, i) {
    return new ii(e, t, i);
  }
}
class S {
  constructor(e, t) {
    this.ranges = e, this.mainIndex = t;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e, t = -1) {
    return e.empty ? this : S.create(this.ranges.map((i) => i.map(e, t)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(e, t = !1) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return !1;
    for (let i = 0; i < this.ranges.length; i++)
      if (!this.ranges[i].eq(e.ranges[i], t))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new S([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e, t = !0) {
    return S.create([e].concat(this.ranges), t ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e, t = this.mainIndex) {
    let i = this.ranges.slice();
    return i[t] = e, S.create(i, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new S(e.ranges.map((t) => ii.fromJSON(t)), e.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e, t = e) {
    return new S([S.range(e, t)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e, t = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let i = 0, n = 0; n < e.length; n++) {
      let s = e[n];
      if (s.empty ? s.from <= i : s.from < i)
        return S.normalized(e.slice(), t);
      i = s.to;
    }
    return new S(e, t);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e, t = 0, i, n) {
    return ii.create(e, e, (t == 0 ? 0 : t < 0 ? 8 : 16) | (i == null ? 7 : Math.min(6, i)) | (n ?? 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(e, t, i, n) {
    let s = (i ?? 16777215) << 6 | (n == null ? 7 : Math.min(6, n));
    return t < e ? ii.create(t, e, 48 | s) : ii.create(e, t, (t > e ? 8 : 0) | s);
  }
  /**
  @internal
  */
  static normalized(e, t = 0) {
    let i = e[t];
    e.sort((n, s) => n.from - s.from), t = e.indexOf(i);
    for (let n = 1; n < e.length; n++) {
      let s = e[n], o = e[n - 1];
      if (s.empty ? s.from <= o.to : s.from < o.to) {
        let l = o.from, a = Math.max(s.to, o.to);
        n <= t && t--, e.splice(--n, 2, s.anchor > s.head ? S.range(a, l) : S.range(l, a));
      }
    }
    return new S(e, t);
  }
}
function vO(r, e) {
  for (let t of r.ranges)
    if (t.to > e)
      throw new RangeError("Selection points outside of document");
}
let uc = 0;
class _ {
  constructor(e, t, i, n, s) {
    this.combine = e, this.compareInput = t, this.compare = i, this.isStatic = n, this.id = uc++, this.default = e([]), this.extensions = typeof s == "function" ? s(this) : s;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(e = {}) {
    return new _(e.combine || ((t) => t), e.compareInput || ((t, i) => t === i), e.compare || (e.combine ? (t, i) => t === i : dc), !!e.static, e.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(e) {
    return new co([], this, 0, e);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new co(e, this, 1, t);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new co(e, this, 2, t);
  }
  from(e, t) {
    return t || (t = (i) => i), this.compute([e], (i) => t(i.field(e)));
  }
}
function dc(r, e) {
  return r == e || r.length == e.length && r.every((t, i) => t === e[i]);
}
class co {
  constructor(e, t, i, n) {
    this.dependencies = e, this.facet = t, this.type = i, this.value = n, this.id = uc++;
  }
  dynamicSlot(e) {
    var t;
    let i = this.value, n = this.facet.compareInput, s = this.id, o = e[s] >> 1, l = this.type == 2, a = !1, h = !1, c = [];
    for (let u of this.dependencies)
      u == "doc" ? a = !0 : u == "selection" ? h = !0 : ((t = e[u.id]) !== null && t !== void 0 ? t : 1) & 1 || c.push(e[u.id]);
    return {
      create(u) {
        return u.values[o] = i(u), 1;
      },
      update(u, d) {
        if (a && d.docChanged || h && (d.docChanged || d.selection) || Ba(u, c)) {
          let p = i(u);
          if (l ? !Iu(p, u.values[o], n) : !n(p, u.values[o]))
            return u.values[o] = p, 1;
        }
        return 0;
      },
      reconfigure: (u, d) => {
        let p, f = d.config.address[s];
        if (f != null) {
          let m = Xo(d, f);
          if (this.dependencies.every((g) => g instanceof _ ? d.facet(g) === u.facet(g) : g instanceof Qe ? d.field(g, !1) == u.field(g, !1) : !0) || (l ? Iu(p = i(u), m, n) : n(p = i(u), m)))
            return u.values[o] = m, 0;
        } else
          p = i(u);
        return u.values[o] = p, 1;
      }
    };
  }
}
function Iu(r, e, t) {
  if (r.length != e.length)
    return !1;
  for (let i = 0; i < r.length; i++)
    if (!t(r[i], e[i]))
      return !1;
  return !0;
}
function Ba(r, e) {
  let t = !1;
  for (let i of e)
    En(r, i) & 1 && (t = !0);
  return t;
}
function vy(r, e, t) {
  let i = t.map((a) => r[a.id]), n = t.map((a) => a.type), s = i.filter((a) => !(a & 1)), o = r[e.id] >> 1;
  function l(a) {
    let h = [];
    for (let c = 0; c < i.length; c++) {
      let u = Xo(a, i[c]);
      if (n[c] == 2)
        for (let d of u)
          h.push(d);
      else
        h.push(u);
    }
    return e.combine(h);
  }
  return {
    create(a) {
      for (let h of i)
        En(a, h);
      return a.values[o] = l(a), 1;
    },
    update(a, h) {
      if (!Ba(a, s))
        return 0;
      let c = l(a);
      return e.compare(c, a.values[o]) ? 0 : (a.values[o] = c, 1);
    },
    reconfigure(a, h) {
      let c = Ba(a, i), u = h.config.facets[e.id], d = h.facet(e);
      if (u && !c && dc(t, u))
        return a.values[o] = d, 0;
      let p = l(a);
      return e.compare(p, d) ? (a.values[o] = d, 0) : (a.values[o] = p, 1);
    }
  };
}
const Uu = /* @__PURE__ */ _.define({ static: !0 });
class Qe {
  constructor(e, t, i, n, s) {
    this.id = e, this.createF = t, this.updateF = i, this.compareF = n, this.spec = s, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e) {
    let t = new Qe(uc++, e.create, e.update, e.compare || ((i, n) => i === n), e);
    return e.provide && (t.provides = e.provide(t)), t;
  }
  create(e) {
    let t = e.facet(Uu).find((i) => i.field == this);
    return ((t == null ? void 0 : t.create) || this.createF)(e);
  }
  /**
  @internal
  */
  slot(e) {
    let t = e[this.id] >> 1;
    return {
      create: (i) => (i.values[t] = this.create(i), 1),
      update: (i, n) => {
        let s = i.values[t], o = this.updateF(s, n);
        return this.compareF(s, o) ? 0 : (i.values[t] = o, 1);
      },
      reconfigure: (i, n) => n.config.address[this.id] != null ? (i.values[t] = n.field(this), 0) : (i.values[t] = this.create(i), 1)
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e) {
    return [this, Uu.of({ field: this, create: e })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const ei = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function pn(r) {
  return (e) => new xO(e, r);
}
const Lr = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ pn(ei.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ pn(ei.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ pn(ei.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ pn(ei.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ pn(ei.lowest)
};
class xO {
  constructor(e, t) {
    this.inner = e, this.prec = t;
  }
}
class Vt {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e) {
    return new Da(this, e);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e) {
    return Vt.reconfigure.of({ compartment: this, extension: e });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e) {
    return e.config.compartments.get(this);
  }
}
class Da {
  constructor(e, t) {
    this.compartment = e, this.inner = t;
  }
}
class Co {
  constructor(e, t, i, n, s, o) {
    for (this.base = e, this.compartments = t, this.dynamicSlots = i, this.address = n, this.staticValues = s, this.facets = o, this.statusTemplate = []; this.statusTemplate.length < i.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(e) {
    let t = this.address[e.id];
    return t == null ? e.default : this.staticValues[t >> 1];
  }
  static resolve(e, t, i) {
    let n = [], s = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ new Map();
    for (let d of xy(e, t, o))
      d instanceof Qe ? n.push(d) : (s[d.facet.id] || (s[d.facet.id] = [])).push(d);
    let l = /* @__PURE__ */ Object.create(null), a = [], h = [];
    for (let d of n)
      l[d.id] = h.length << 1, h.push((p) => d.slot(p));
    let c = i == null ? void 0 : i.config.facets;
    for (let d in s) {
      let p = s[d], f = p[0].facet, m = c && c[d] || [];
      if (p.every(
        (g) => g.type == 0
        /* Provider.Static */
      ))
        if (l[f.id] = a.length << 1 | 1, dc(m, p))
          a.push(i.facet(f));
        else {
          let g = f.combine(p.map((b) => b.value));
          a.push(i && f.compare(g, i.facet(f)) ? i.facet(f) : g);
        }
      else {
        for (let g of p)
          g.type == 0 ? (l[g.id] = a.length << 1 | 1, a.push(g.value)) : (l[g.id] = h.length << 1, h.push((b) => g.dynamicSlot(b)));
        l[f.id] = h.length << 1, h.push((g) => vy(g, f, p));
      }
    }
    let u = h.map((d) => d(l));
    return new Co(e, o, u, l, a, s);
  }
}
function xy(r, e, t) {
  let i = [[], [], [], [], []], n = /* @__PURE__ */ new Map();
  function s(o, l) {
    let a = n.get(o);
    if (a != null) {
      if (a <= l)
        return;
      let h = i[a].indexOf(o);
      h > -1 && i[a].splice(h, 1), o instanceof Da && t.delete(o.compartment);
    }
    if (n.set(o, l), Array.isArray(o))
      for (let h of o)
        s(h, l);
    else if (o instanceof Da) {
      if (t.has(o.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let h = e.get(o.compartment) || o.inner;
      t.set(o.compartment, h), s(h, l);
    } else if (o instanceof xO)
      s(o.inner, o.prec);
    else if (o instanceof Qe)
      i[l].push(o), o.provides && s(o.provides, l);
    else if (o instanceof co)
      i[l].push(o), o.facet.extensions && s(o.facet.extensions, ei.default);
    else {
      let h = o.extension;
      if (!h)
        throw new Error(`Unrecognized extension value in extension set (${o}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      s(h, l);
    }
  }
  return s(r, ei.default), i.reduce((o, l) => o.concat(l));
}
function En(r, e) {
  if (e & 1)
    return 2;
  let t = e >> 1, i = r.status[t];
  if (i == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (i & 2)
    return i;
  r.status[t] = 4;
  let n = r.computeSlot(r, r.config.dynamicSlots[t]);
  return r.status[t] = 2 | n;
}
function Xo(r, e) {
  return e & 1 ? r.config.staticValues[e >> 1] : r.values[e >> 1];
}
const SO = /* @__PURE__ */ _.define(), Ia = /* @__PURE__ */ _.define({
  combine: (r) => r.some((e) => e),
  static: !0
}), kO = /* @__PURE__ */ _.define({
  combine: (r) => r.length ? r[0] : void 0,
  static: !0
}), $O = /* @__PURE__ */ _.define(), QO = /* @__PURE__ */ _.define(), PO = /* @__PURE__ */ _.define(), TO = /* @__PURE__ */ _.define({
  combine: (r) => r.length ? r[0] : !1
});
class pr {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new Sy();
  }
}
class Sy {
  /**
  Create an instance of this annotation.
  */
  of(e) {
    return new pr(this, e);
  }
}
class ky {
  /**
  @internal
  */
  constructor(e) {
    this.map = e;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e) {
    return new j(this, e);
  }
}
class j {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e) {
    let t = this.type.map(this.value, e);
    return t === void 0 ? void 0 : t == this.value ? this : new j(this.type, t);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e) {
    return this.type == e;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(e = {}) {
    return new ky(e.map || ((t) => t));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e, t) {
    if (!e.length)
      return e;
    let i = [];
    for (let n of e) {
      let s = n.map(t);
      s && i.push(s);
    }
    return i;
  }
}
j.reconfigure = /* @__PURE__ */ j.define();
j.appendConfig = /* @__PURE__ */ j.define();
class we {
  constructor(e, t, i, n, s, o) {
    this.startState = e, this.changes = t, this.selection = i, this.effects = n, this.annotations = s, this.scrollIntoView = o, this._doc = null, this._state = null, i && vO(i, t.newLength), s.some((l) => l.type == we.time) || (this.annotations = s.concat(we.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(e, t, i, n, s, o) {
    return new we(e, t, i, n, s, o);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e) {
    for (let t of this.annotations)
      if (t.type == e)
        return t.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e) {
    let t = this.annotation(we.userEvent);
    return !!(t && (t == e || t.length > e.length && t.slice(0, e.length) == e && t[e.length] == "."));
  }
}
we.time = /* @__PURE__ */ pr.define();
we.userEvent = /* @__PURE__ */ pr.define();
we.addToHistory = /* @__PURE__ */ pr.define();
we.remote = /* @__PURE__ */ pr.define();
function $y(r, e) {
  let t = [];
  for (let i = 0, n = 0; ; ) {
    let s, o;
    if (i < r.length && (n == e.length || e[n] >= r[i]))
      s = r[i++], o = r[i++];
    else if (n < e.length)
      s = e[n++], o = e[n++];
    else
      return t;
    !t.length || t[t.length - 1] < s ? t.push(s, o) : t[t.length - 1] < o && (t[t.length - 1] = o);
  }
}
function CO(r, e, t) {
  var i;
  let n, s, o;
  return t ? (n = e.changes, s = ke.empty(e.changes.length), o = r.changes.compose(e.changes)) : (n = e.changes.map(r.changes), s = r.changes.mapDesc(e.changes, !0), o = r.changes.compose(n)), {
    changes: o,
    selection: e.selection ? e.selection.map(s) : (i = r.selection) === null || i === void 0 ? void 0 : i.map(n),
    effects: j.mapEffects(r.effects, n).concat(j.mapEffects(e.effects, s)),
    annotations: r.annotations.length ? r.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: r.scrollIntoView || e.scrollIntoView
  };
}
function Ua(r, e, t) {
  let i = e.selection, n = Xi(e.annotations);
  return e.userEvent && (n = n.concat(we.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof ke ? e.changes : ke.of(e.changes || [], t, r.facet(kO)),
    selection: i && (i instanceof S ? i : S.single(i.anchor, i.head)),
    effects: Xi(e.effects),
    annotations: n,
    scrollIntoView: !!e.scrollIntoView
  };
}
function XO(r, e, t) {
  let i = Ua(r, e.length ? e[0] : {}, r.doc.length);
  e.length && e[0].filter === !1 && (t = !1);
  for (let s = 1; s < e.length; s++) {
    e[s].filter === !1 && (t = !1);
    let o = !!e[s].sequential;
    i = CO(i, Ua(r, e[s], o ? i.changes.newLength : r.doc.length), o);
  }
  let n = we.create(r, i.changes, i.selection, i.effects, i.annotations, i.scrollIntoView);
  return Py(t ? Qy(n) : n);
}
function Qy(r) {
  let e = r.startState, t = !0;
  for (let n of e.facet($O)) {
    let s = n(r);
    if (s === !1) {
      t = !1;
      break;
    }
    Array.isArray(s) && (t = t === !0 ? s : $y(t, s));
  }
  if (t !== !0) {
    let n, s;
    if (t === !1)
      s = r.changes.invertedDesc, n = ke.empty(e.doc.length);
    else {
      let o = r.changes.filter(t);
      n = o.changes, s = o.filtered.mapDesc(o.changes).invertedDesc;
    }
    r = we.create(e, n, r.selection && r.selection.map(s), j.mapEffects(r.effects, s), r.annotations, r.scrollIntoView);
  }
  let i = e.facet(QO);
  for (let n = i.length - 1; n >= 0; n--) {
    let s = i[n](r);
    s instanceof we ? r = s : Array.isArray(s) && s.length == 1 && s[0] instanceof we ? r = s[0] : r = XO(e, Xi(s), !1);
  }
  return r;
}
function Py(r) {
  let e = r.startState, t = e.facet(PO), i = r;
  for (let n = t.length - 1; n >= 0; n--) {
    let s = t[n](r);
    s && Object.keys(s).length && (i = CO(i, Ua(e, s, r.changes.newLength), !0));
  }
  return i == r ? r : we.create(e, r.changes, r.selection, i.effects, i.annotations, i.scrollIntoView);
}
const Ty = [];
function Xi(r) {
  return r == null ? Ty : Array.isArray(r) ? r : [r];
}
var pe = /* @__PURE__ */ function(r) {
  return r[r.Word = 0] = "Word", r[r.Space = 1] = "Space", r[r.Other = 2] = "Other", r;
}(pe || (pe = {}));
const Cy = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let Ga;
try {
  Ga = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function Xy(r) {
  if (Ga)
    return Ga.test(r);
  for (let e = 0; e < r.length; e++) {
    let t = r[e];
    if (/\w/.test(t) || t > "" && (t.toUpperCase() != t.toLowerCase() || Cy.test(t)))
      return !0;
  }
  return !1;
}
function Zy(r) {
  return (e) => {
    if (!/\S/.test(e))
      return pe.Space;
    if (Xy(e))
      return pe.Word;
    for (let t = 0; t < r.length; t++)
      if (e.indexOf(r[t]) > -1)
        return pe.Word;
    return pe.Other;
  };
}
class U {
  constructor(e, t, i, n, s, o) {
    this.config = e, this.doc = t, this.selection = i, this.values = n, this.status = e.statusTemplate.slice(), this.computeSlot = s, o && (o._state = this);
    for (let l = 0; l < this.config.dynamicSlots.length; l++)
      En(this, l << 1);
    this.computeSlot = null;
  }
  field(e, t = !0) {
    let i = this.config.address[e.id];
    if (i == null) {
      if (t)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return En(this, i), Xo(this, i);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e) {
    return XO(this, e, !0);
  }
  /**
  @internal
  */
  applyTransaction(e) {
    let t = this.config, { base: i, compartments: n } = t;
    for (let l of e.effects)
      l.is(Vt.reconfigure) ? (t && (n = /* @__PURE__ */ new Map(), t.compartments.forEach((a, h) => n.set(h, a)), t = null), n.set(l.value.compartment, l.value.extension)) : l.is(j.reconfigure) ? (t = null, i = l.value) : l.is(j.appendConfig) && (t = null, i = Xi(i).concat(l.value));
    let s;
    t ? s = e.startState.values.slice() : (t = Co.resolve(i, n, this), s = new U(t, this.doc, this.selection, t.dynamicSlots.map(() => null), (a, h) => h.reconfigure(a, this), null).values);
    let o = e.startState.facet(Ia) ? e.newSelection : e.newSelection.asSingle();
    new U(t, e.newDoc, o, s, (l, a) => a.update(l, e), e);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((t) => ({
      changes: { from: t.from, to: t.to, insert: e },
      range: S.cursor(t.from + e.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e) {
    let t = this.selection, i = e(t.ranges[0]), n = this.changes(i.changes), s = [i.range], o = Xi(i.effects);
    for (let l = 1; l < t.ranges.length; l++) {
      let a = e(t.ranges[l]), h = this.changes(a.changes), c = h.map(n);
      for (let d = 0; d < l; d++)
        s[d] = s[d].map(c);
      let u = n.mapDesc(h, !0);
      s.push(a.range.map(u)), n = n.compose(c), o = j.mapEffects(o, c).concat(j.mapEffects(Xi(a.effects), u));
    }
    return {
      changes: n,
      selection: S.create(s, t.mainIndex),
      effects: o
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e = []) {
    return e instanceof ke ? e : ke.of(e, this.doc.length, this.facet(U.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(e) {
    return K.of(e.split(this.facet(U.lineSeparator) || Ma));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e = 0, t = this.doc.length) {
    return this.doc.sliceString(e, t, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e) {
    let t = this.config.address[e.id];
    return t == null ? e.default : (En(this, t), Xo(this, t));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e) {
    let t = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let i in e) {
        let n = e[i];
        n instanceof Qe && this.config.address[n.id] != null && (t[i] = n.spec.toJSON(this.field(e[i]), this));
      }
    return t;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e, t = {}, i) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let n = [];
    if (i) {
      for (let s in i)
        if (Object.prototype.hasOwnProperty.call(e, s)) {
          let o = i[s], l = e[s];
          n.push(o.init((a) => o.spec.fromJSON(l, a)));
        }
    }
    return U.create({
      doc: e.doc,
      selection: S.fromJSON(e.selection),
      extensions: t.extensions ? n.concat([t.extensions]) : n
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */
  static create(e = {}) {
    let t = Co.resolve(e.extensions || [], /* @__PURE__ */ new Map()), i = e.doc instanceof K ? e.doc : K.of((e.doc || "").split(t.staticFacet(U.lineSeparator) || Ma)), n = e.selection ? e.selection instanceof S ? e.selection : S.single(e.selection.anchor, e.selection.head) : S.single(0);
    return vO(n, i.length), t.staticFacet(Ia) || (n = n.asSingle()), new U(t, i, n, t.dynamicSlots.map(() => null), (s, o) => o.create(s), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(U.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(U.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(TO);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(e, ...t) {
    for (let i of this.facet(U.phrases))
      if (Object.prototype.hasOwnProperty.call(i, e)) {
        e = i[e];
        break;
      }
    return t.length && (e = e.replace(/\$(\$|\d*)/g, (i, n) => {
      if (n == "$")
        return "$";
      let s = +(n || 1);
      return !s || s > t.length ? i : t[s - 1];
    })), e;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(e, t, i = -1) {
    let n = [];
    for (let s of this.facet(SO))
      for (let o of s(this, t, i))
        Object.prototype.hasOwnProperty.call(o, e) && n.push(o[e]);
    return n;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e) {
    return Zy(this.languageDataAt("wordChars", e).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e) {
    let { text: t, from: i, length: n } = this.doc.lineAt(e), s = this.charCategorizer(e), o = e - i, l = e - i;
    for (; o > 0; ) {
      let a = _e(t, o, !1);
      if (s(t.slice(a, o)) != pe.Word)
        break;
      o = a;
    }
    for (; l < n; ) {
      let a = _e(t, l);
      if (s(t.slice(l, a)) != pe.Word)
        break;
      l = a;
    }
    return o == l ? null : S.range(o + i, l + i);
  }
}
U.allowMultipleSelections = Ia;
U.tabSize = /* @__PURE__ */ _.define({
  combine: (r) => r.length ? r[0] : 4
});
U.lineSeparator = kO;
U.readOnly = TO;
U.phrases = /* @__PURE__ */ _.define({
  compare(r, e) {
    let t = Object.keys(r), i = Object.keys(e);
    return t.length == i.length && t.every((n) => r[n] == e[n]);
  }
});
U.languageData = SO;
U.changeFilter = $O;
U.transactionFilter = QO;
U.transactionExtender = PO;
Vt.reconfigure = /* @__PURE__ */ j.define();
function _t(r, e, t = {}) {
  let i = {};
  for (let n of r)
    for (let s of Object.keys(n)) {
      let o = n[s], l = i[s];
      if (l === void 0)
        i[s] = o;
      else if (!(l === o || o === void 0))
        if (Object.hasOwnProperty.call(t, s))
          i[s] = t[s](l, o);
        else
          throw new Error("Config merge conflict for field " + s);
    }
  for (let n in e)
    i[n] === void 0 && (i[n] = e[n]);
  return i;
}
class ci {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(e) {
    return this == e;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(e, t = e) {
    return Na.create(e, t, this);
  }
}
ci.prototype.startSide = ci.prototype.endSide = 0;
ci.prototype.point = !1;
ci.prototype.mapMode = Xe.TrackDel;
let Na = class ZO {
  constructor(e, t, i) {
    this.from = e, this.to = t, this.value = i;
  }
  /**
  @internal
  */
  static create(e, t, i) {
    return new ZO(e, t, i);
  }
};
function Fa(r, e) {
  return r.from - e.from || r.value.startSide - e.value.startSide;
}
class pc {
  constructor(e, t, i, n) {
    this.from = e, this.to = t, this.value = i, this.maxPoint = n;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e, t, i, n = 0) {
    let s = i ? this.to : this.from;
    for (let o = n, l = s.length; ; ) {
      if (o == l)
        return o;
      let a = o + l >> 1, h = s[a] - e || (i ? this.value[a].endSide : this.value[a].startSide) - t;
      if (a == o)
        return h >= 0 ? o : l;
      h >= 0 ? l = a : o = a + 1;
    }
  }
  between(e, t, i, n) {
    for (let s = this.findIndex(t, -1e9, !0), o = this.findIndex(i, 1e9, !1, s); s < o; s++)
      if (n(this.from[s] + e, this.to[s] + e, this.value[s]) === !1)
        return !1;
  }
  map(e, t) {
    let i = [], n = [], s = [], o = -1, l = -1;
    for (let a = 0; a < this.value.length; a++) {
      let h = this.value[a], c = this.from[a] + e, u = this.to[a] + e, d, p;
      if (c == u) {
        let f = t.mapPos(c, h.startSide, h.mapMode);
        if (f == null || (d = p = f, h.startSide != h.endSide && (p = t.mapPos(c, h.endSide), p < d)))
          continue;
      } else if (d = t.mapPos(c, h.startSide), p = t.mapPos(u, h.endSide), d > p || d == p && h.startSide > 0 && h.endSide <= 0)
        continue;
      (p - d || h.endSide - h.startSide) < 0 || (o < 0 && (o = d), h.point && (l = Math.max(l, p - d)), i.push(h), n.push(d - o), s.push(p - o));
    }
    return { mapped: i.length ? new pc(n, s, i, l) : null, pos: o };
  }
}
class H {
  constructor(e, t, i, n) {
    this.chunkPos = e, this.chunk = t, this.nextLayer = i, this.maxPoint = n;
  }
  /**
  @internal
  */
  static create(e, t, i, n) {
    return new H(e, t, i, n);
  }
  /**
  @internal
  */
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let t of this.chunk)
      e += t.value.length;
    return e;
  }
  /**
  @internal
  */
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e) {
    let { add: t = [], sort: i = !1, filterFrom: n = 0, filterTo: s = this.length } = e, o = e.filter;
    if (t.length == 0 && !o)
      return this;
    if (i && (t = t.slice().sort(Fa)), this.isEmpty)
      return t.length ? H.of(t) : this;
    let l = new _O(this, null, -1).goto(0), a = 0, h = [], c = new sr();
    for (; l.value || a < t.length; )
      if (a < t.length && (l.from - t[a].from || l.startSide - t[a].value.startSide) >= 0) {
        let u = t[a++];
        c.addInner(u.from, u.to, u.value) || h.push(u);
      } else
        l.rangeIndex == 1 && l.chunkIndex < this.chunk.length && (a == t.length || this.chunkEnd(l.chunkIndex) < t[a].from) && (!o || n > this.chunkEnd(l.chunkIndex) || s < this.chunkPos[l.chunkIndex]) && c.addChunk(this.chunkPos[l.chunkIndex], this.chunk[l.chunkIndex]) ? l.nextChunk() : ((!o || n > l.to || s < l.from || o(l.from, l.to, l.value)) && (c.addInner(l.from, l.to, l.value) || h.push(Na.create(l.from, l.to, l.value))), l.next());
    return c.finishInner(this.nextLayer.isEmpty && !h.length ? H.empty : this.nextLayer.update({ add: h, filter: o, filterFrom: n, filterTo: s }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let t = [], i = [], n = -1;
    for (let o = 0; o < this.chunk.length; o++) {
      let l = this.chunkPos[o], a = this.chunk[o], h = e.touchesRange(l, l + a.length);
      if (h === !1)
        n = Math.max(n, a.maxPoint), t.push(a), i.push(e.mapPos(l));
      else if (h === !0) {
        let { mapped: c, pos: u } = a.map(l, e);
        c && (n = Math.max(n, c.maxPoint), t.push(c), i.push(u));
      }
    }
    let s = this.nextLayer.map(e);
    return t.length == 0 ? s : new H(i, t, s || H.empty, n);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e, t, i) {
    if (!this.isEmpty) {
      for (let n = 0; n < this.chunk.length; n++) {
        let s = this.chunkPos[n], o = this.chunk[n];
        if (t >= s && e <= s + o.length && o.between(s, e - s, t - s, i) === !1)
          return;
      }
      this.nextLayer.between(e, t, i);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e = 0) {
    return Un.from([this]).goto(e);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e, t = 0) {
    return Un.from(e).goto(t);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e, t, i, n, s = -1) {
    let o = e.filter((u) => u.maxPoint > 0 || !u.isEmpty && u.maxPoint >= s), l = t.filter((u) => u.maxPoint > 0 || !u.isEmpty && u.maxPoint >= s), a = Gu(o, l, i), h = new fn(o, a, s), c = new fn(l, a, s);
    i.iterGaps((u, d, p) => Nu(h, u, c, d, p, n)), i.empty && i.length == 0 && Nu(h, 0, c, 0, 0, n);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e, t, i = 0, n) {
    n == null && (n = 999999999);
    let s = e.filter((c) => !c.isEmpty && t.indexOf(c) < 0), o = t.filter((c) => !c.isEmpty && e.indexOf(c) < 0);
    if (s.length != o.length)
      return !1;
    if (!s.length)
      return !0;
    let l = Gu(s, o), a = new fn(s, l, 0).goto(i), h = new fn(o, l, 0).goto(i);
    for (; ; ) {
      if (a.to != h.to || !Ha(a.active, h.active) || a.point && (!h.point || !a.point.eq(h.point)))
        return !1;
      if (a.to > n)
        return !0;
      a.next(), h.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e, t, i, n, s = -1) {
    let o = new fn(e, null, s).goto(t), l = t, a = o.openStart;
    for (; ; ) {
      let h = Math.min(o.to, i);
      if (o.point) {
        let c = o.activeForPoint(o.to), u = o.pointFrom < t ? c.length + 1 : Math.min(c.length, a);
        n.point(l, h, o.point, c, u, o.pointRank), a = Math.min(o.openEnd(h), c.length);
      } else
        h > l && (n.span(l, h, o.active, a), a = o.openEnd(h));
      if (o.to > i)
        return a + (o.point && o.to > i ? 1 : 0);
      l = o.to, o.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e, t = !1) {
    let i = new sr();
    for (let n of e instanceof Na ? [e] : t ? _y(e) : e)
      i.add(n.from, n.to, n.value);
    return i.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(e) {
    if (!e.length)
      return H.empty;
    let t = e[e.length - 1];
    for (let i = e.length - 2; i >= 0; i--)
      for (let n = e[i]; n != H.empty; n = n.nextLayer)
        t = new H(n.chunkPos, n.chunk, t, Math.max(n.maxPoint, t.maxPoint));
    return t;
  }
}
H.empty = /* @__PURE__ */ new H([], [], null, -1);
function _y(r) {
  if (r.length > 1)
    for (let e = r[0], t = 1; t < r.length; t++) {
      let i = r[t];
      if (Fa(e, i) > 0)
        return r.slice().sort(Fa);
      e = i;
    }
  return r;
}
H.empty.nextLayer = H.empty;
class sr {
  finishChunk(e) {
    this.chunks.push(new pc(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e, t, i) {
    this.addInner(e, t, i) || (this.nextLayer || (this.nextLayer = new sr())).add(e, t, i);
  }
  /**
  @internal
  */
  addInner(e, t, i) {
    let n = e - this.lastTo || i.startSide - this.last.endSide;
    if (n <= 0 && (e - this.lastFrom || i.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return n < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(t - this.chunkStart), this.last = i, this.lastFrom = e, this.lastTo = t, this.value.push(i), i.point && (this.maxPoint = Math.max(this.maxPoint, t - e)), !0);
  }
  /**
  @internal
  */
  addChunk(e, t) {
    if ((e - this.lastTo || t.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, t.maxPoint), this.chunks.push(t), this.chunkPos.push(e);
    let i = t.value.length - 1;
    return this.last = t.value[i], this.lastFrom = t.from[i] + e, this.lastTo = t.to[i] + e, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(H.empty);
  }
  /**
  @internal
  */
  finishInner(e) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return e;
    let t = H.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, t;
  }
}
function Gu(r, e, t) {
  let i = /* @__PURE__ */ new Map();
  for (let s of r)
    for (let o = 0; o < s.chunk.length; o++)
      s.chunk[o].maxPoint <= 0 && i.set(s.chunk[o], s.chunkPos[o]);
  let n = /* @__PURE__ */ new Set();
  for (let s of e)
    for (let o = 0; o < s.chunk.length; o++) {
      let l = i.get(s.chunk[o]);
      l != null && (t ? t.mapPos(l) : l) == s.chunkPos[o] && !(t != null && t.touchesRange(l, l + s.chunk[o].length)) && n.add(s.chunk[o]);
    }
  return n;
}
class _O {
  constructor(e, t, i, n = 0) {
    this.layer = e, this.skip = t, this.minPoint = i, this.rank = n;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, t = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, t, !1), this;
  }
  gotoInner(e, t, i) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let n = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(n) || this.layer.chunkEnd(this.chunkIndex) < e || n.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, i = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let n = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], t, !0);
      (!i || this.rangeIndex < n) && this.setRangeIndex(n);
    }
    this.next();
  }
  forward(e, t) {
    (this.to - e || this.endSide - t) < 0 && this.gotoInner(e, t, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], t = this.layer.chunk[this.chunkIndex], i = e + t.from[this.rangeIndex];
        if (this.from = i, this.to = e + t.to[this.rangeIndex], this.value = t.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class Un {
  constructor(e) {
    this.heap = e;
  }
  static from(e, t = null, i = -1) {
    let n = [];
    for (let s = 0; s < e.length; s++)
      for (let o = e[s]; !o.isEmpty; o = o.nextLayer)
        o.maxPoint >= i && n.push(new _O(o, t, i, s));
    return n.length == 1 ? n[0] : new Un(n);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, t = -1e9) {
    for (let i of this.heap)
      i.goto(e, t);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      Dl(this.heap, i);
    return this.next(), this;
  }
  forward(e, t) {
    for (let i of this.heap)
      i.forward(e, t);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      Dl(this.heap, i);
    (this.to - e || this.value.endSide - t) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), Dl(this.heap, 0);
    }
  }
}
function Dl(r, e) {
  for (let t = r[e]; ; ) {
    let i = (e << 1) + 1;
    if (i >= r.length)
      break;
    let n = r[i];
    if (i + 1 < r.length && n.compare(r[i + 1]) >= 0 && (n = r[i + 1], i++), t.compare(n) < 0)
      break;
    r[i] = t, r[e] = n, e = i;
  }
}
class fn {
  constructor(e, t, i) {
    this.minPoint = i, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = Un.from(e, t, i);
  }
  goto(e, t = -1e9) {
    return this.cursor.goto(e, t), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = t, this.openStart = -1, this.next(), this;
  }
  forward(e, t) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - t) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, t);
  }
  removeActive(e) {
    Rs(this.active, e), Rs(this.activeTo, e), Rs(this.activeRank, e), this.minActive = Fu(this.active, this.activeTo);
  }
  addActive(e) {
    let t = 0, { value: i, to: n, rank: s } = this.cursor;
    for (; t < this.activeRank.length && (s - this.activeRank[t] || n - this.activeTo[t]) > 0; )
      t++;
    As(this.active, t, i), As(this.activeTo, t, n), As(this.activeRank, t, s), e && As(e, t, this.cursor.from), this.minActive = Fu(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e = this.to, t = this.point;
    this.point = null;
    let i = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let n = this.minActive;
      if (n > -1 && (this.activeTo[n] - this.cursor.from || this.active[n].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[n] > e) {
          this.to = this.activeTo[n], this.endSide = this.active[n].endSide;
          break;
        }
        this.removeActive(n), i && Rs(i, n);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let s = this.cursor.value;
          if (!s.point)
            this.addActive(i), this.cursor.next();
          else if (t && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = s, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = s.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (i) {
      this.openStart = 0;
      for (let n = i.length - 1; n >= 0 && i[n] < e; n--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let t = [];
    for (let i = this.active.length - 1; i >= 0 && !(this.activeRank[i] < this.pointRank); i--)
      (this.activeTo[i] > e || this.activeTo[i] == e && this.active[i].endSide >= this.point.endSide) && t.push(this.active[i]);
    return t.reverse();
  }
  openEnd(e) {
    let t = 0;
    for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > e; i--)
      t++;
    return t;
  }
}
function Nu(r, e, t, i, n, s) {
  r.goto(e), t.goto(i);
  let o = i + n, l = i, a = i - e;
  for (; ; ) {
    let h = r.to + a - t.to || r.endSide - t.endSide, c = h < 0 ? r.to + a : t.to, u = Math.min(c, o);
    if (r.point || t.point ? r.point && t.point && (r.point == t.point || r.point.eq(t.point)) && Ha(r.activeForPoint(r.to), t.activeForPoint(t.to)) || s.comparePoint(l, u, r.point, t.point) : u > l && !Ha(r.active, t.active) && s.compareRange(l, u, r.active, t.active), c > o)
      break;
    l = c, h <= 0 && r.next(), h >= 0 && t.next();
  }
}
function Ha(r, e) {
  if (r.length != e.length)
    return !1;
  for (let t = 0; t < r.length; t++)
    if (r[t] != e[t] && !r[t].eq(e[t]))
      return !1;
  return !0;
}
function Rs(r, e) {
  for (let t = e, i = r.length - 1; t < i; t++)
    r[t] = r[t + 1];
  r.pop();
}
function As(r, e, t) {
  for (let i = r.length - 1; i >= e; i--)
    r[i + 1] = r[i];
  r[e] = t;
}
function Fu(r, e) {
  let t = -1, i = 1e9;
  for (let n = 0; n < e.length; n++)
    (e[n] - i || r[n].endSide - r[t].endSide) < 0 && (t = n, i = e[n]);
  return t;
}
function Tt(r, e, t = r.length) {
  let i = 0;
  for (let n = 0; n < t; )
    r.charCodeAt(n) == 9 ? (i += e - i % e, n++) : (i++, n = _e(r, n));
  return i;
}
function Ka(r, e, t, i) {
  for (let n = 0, s = 0; ; ) {
    if (s >= e)
      return n;
    if (n == r.length)
      break;
    s += r.charCodeAt(n) == 9 ? t - s % t : 1, n = _e(r, n);
  }
  return i === !0 ? -1 : r.length;
}
const Ja = "ͼ", Hu = typeof Symbol > "u" ? "__" + Ja : Symbol.for(Ja), eh = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), Ku = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class Er {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e, t) {
    this.rules = [];
    let { finish: i } = t || {};
    function n(o) {
      return /^@/.test(o) ? [o] : o.split(/,\s*/);
    }
    function s(o, l, a, h) {
      let c = [], u = /^@(\w+)\b/.exec(o[0]), d = u && u[1] == "keyframes";
      if (u && l == null)
        return a.push(o[0] + ";");
      for (let p in l) {
        let f = l[p];
        if (/&/.test(p))
          s(
            p.split(/,\s*/).map((m) => o.map((g) => m.replace(/&/, g))).reduce((m, g) => m.concat(g)),
            f,
            a
          );
        else if (f && typeof f == "object") {
          if (!u)
            throw new RangeError("The value of a property (" + p + ") should be a primitive value.");
          s(n(p), f, c, d);
        } else
          f != null && c.push(p.replace(/_.*/, "").replace(/[A-Z]/g, (m) => "-" + m.toLowerCase()) + ": " + f + ";");
      }
      (c.length || d) && a.push((i && !u && !h ? o.map(i) : o).join(", ") + " {" + c.join(" ") + "}");
    }
    for (let o in e)
      s(n(o), e[o], this.rules);
  }
  // :: () → string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: () → string
  // Generate a new unique CSS class name.
  static newName() {
    let e = Ku[Hu] || 1;
    return Ku[Hu] = e + 1, Ja + e.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(e, t, i) {
    let n = e[eh], s = i && i.nonce;
    n ? s && n.setNonce(s) : n = new Ry(e, s), n.mount(Array.isArray(t) ? t : [t]);
  }
}
let Ju = /* @__PURE__ */ new Map();
class Ry {
  constructor(e, t) {
    let i = e.ownerDocument || e, n = i.defaultView;
    if (!e.head && e.adoptedStyleSheets && n.CSSStyleSheet) {
      let s = Ju.get(i);
      if (s)
        return e.adoptedStyleSheets = [s.sheet, ...e.adoptedStyleSheets], e[eh] = s;
      this.sheet = new n.CSSStyleSheet(), e.adoptedStyleSheets = [this.sheet, ...e.adoptedStyleSheets], Ju.set(i, this);
    } else {
      this.styleTag = i.createElement("style"), t && this.styleTag.setAttribute("nonce", t);
      let s = e.head || e;
      s.insertBefore(this.styleTag, s.firstChild);
    }
    this.modules = [], e[eh] = this;
  }
  mount(e) {
    let t = this.sheet, i = 0, n = 0;
    for (let s = 0; s < e.length; s++) {
      let o = e[s], l = this.modules.indexOf(o);
      if (l < n && l > -1 && (this.modules.splice(l, 1), n--, l = -1), l == -1) {
        if (this.modules.splice(n++, 0, o), t)
          for (let a = 0; a < o.rules.length; a++)
            t.insertRule(o.rules[a], i++);
      } else {
        for (; n < l; )
          i += this.modules[n++].rules.length;
        i += o.rules.length, n++;
      }
    }
    if (!t) {
      let s = "";
      for (let o = 0; o < this.modules.length; o++)
        s += this.modules[o].getRules() + `
`;
      this.styleTag.textContent = s;
    }
  }
  setNonce(e) {
    this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e);
  }
}
var qr = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, Gn = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, Ay = typeof navigator < "u" && /Mac/.test(navigator.platform), Ey = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var Ce = 0; Ce < 10; Ce++)
  qr[48 + Ce] = qr[96 + Ce] = String(Ce);
for (var Ce = 1; Ce <= 24; Ce++)
  qr[Ce + 111] = "F" + Ce;
for (var Ce = 65; Ce <= 90; Ce++)
  qr[Ce] = String.fromCharCode(Ce + 32), Gn[Ce] = String.fromCharCode(Ce);
for (var Il in qr)
  Gn.hasOwnProperty(Il) || (Gn[Il] = qr[Il]);
function qy(r) {
  var e = Ay && r.metaKey && r.shiftKey && !r.ctrlKey && !r.altKey || Ey && r.shiftKey && r.key && r.key.length == 1 || r.key == "Unidentified", t = !e && r.key || (r.shiftKey ? Gn : qr)[r.keyCode] || r.key || "Unidentified";
  return t == "Esc" && (t = "Escape"), t == "Del" && (t = "Delete"), t == "Left" && (t = "ArrowLeft"), t == "Up" && (t = "ArrowUp"), t == "Right" && (t = "ArrowRight"), t == "Down" && (t = "ArrowDown"), t;
}
function Zo(r) {
  let e;
  return r.nodeType == 11 ? e = r.getSelection ? r : r.ownerDocument : e = r, e.getSelection();
}
function th(r, e) {
  return e ? r == e || r.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function zy(r) {
  let e = r.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function uo(r, e) {
  if (!e.anchorNode)
    return !1;
  try {
    return th(r, e.anchorNode);
  } catch {
    return !1;
  }
}
function Bi(r) {
  return r.nodeType == 3 ? ui(r, 0, r.nodeValue.length).getClientRects() : r.nodeType == 1 ? r.getClientRects() : [];
}
function qn(r, e, t, i) {
  return t ? ed(r, e, t, i, -1) || ed(r, e, t, i, 1) : !1;
}
function Nn(r) {
  for (var e = 0; ; e++)
    if (r = r.previousSibling, !r)
      return e;
}
function ed(r, e, t, i, n) {
  for (; ; ) {
    if (r == t && e == i)
      return !0;
    if (e == (n < 0 ? 0 : or(r))) {
      if (r.nodeName == "DIV")
        return !1;
      let s = r.parentNode;
      if (!s || s.nodeType != 1)
        return !1;
      e = Nn(r) + (n < 0 ? 0 : 1), r = s;
    } else if (r.nodeType == 1) {
      if (r = r.childNodes[e + (n < 0 ? -1 : 0)], r.nodeType == 1 && r.contentEditable == "false")
        return !1;
      e = n < 0 ? or(r) : 0;
    } else
      return !1;
  }
}
function or(r) {
  return r.nodeType == 3 ? r.nodeValue.length : r.childNodes.length;
}
function dl(r, e) {
  let t = e ? r.left : r.right;
  return { left: t, right: t, top: r.top, bottom: r.bottom };
}
function Yy(r) {
  return {
    left: 0,
    right: r.innerWidth,
    top: 0,
    bottom: r.innerHeight
  };
}
function RO(r, e) {
  let t = e.width / r.offsetWidth, i = e.height / r.offsetHeight;
  return (t > 0.995 && t < 1.005 || !isFinite(t) || Math.abs(e.width - r.offsetWidth) < 1) && (t = 1), (i > 0.995 && i < 1.005 || !isFinite(i) || Math.abs(e.height - r.offsetHeight) < 1) && (i = 1), { scaleX: t, scaleY: i };
}
function Wy(r, e, t, i, n, s, o, l) {
  let a = r.ownerDocument, h = a.defaultView || window;
  for (let c = r, u = !1; c && !u; )
    if (c.nodeType == 1) {
      let d, p = c == a.body, f = 1, m = 1;
      if (p)
        d = Yy(h);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(c).position) && (u = !0), c.scrollHeight <= c.clientHeight && c.scrollWidth <= c.clientWidth) {
          c = c.assignedSlot || c.parentNode;
          continue;
        }
        let v = c.getBoundingClientRect();
        ({ scaleX: f, scaleY: m } = RO(c, v)), d = {
          left: v.left,
          right: v.left + c.clientWidth * f,
          top: v.top,
          bottom: v.top + c.clientHeight * m
        };
      }
      let g = 0, b = 0;
      if (n == "nearest")
        e.top < d.top ? (b = -(d.top - e.top + o), t > 0 && e.bottom > d.bottom + b && (b = e.bottom - d.bottom + b + o)) : e.bottom > d.bottom && (b = e.bottom - d.bottom + o, t < 0 && e.top - b < d.top && (b = -(d.top + b - e.top + o)));
      else {
        let v = e.bottom - e.top, k = d.bottom - d.top;
        b = (n == "center" && v <= k ? e.top + v / 2 - k / 2 : n == "start" || n == "center" && t < 0 ? e.top - o : e.bottom - k + o) - d.top;
      }
      if (i == "nearest" ? e.left < d.left ? (g = -(d.left - e.left + s), t > 0 && e.right > d.right + g && (g = e.right - d.right + g + s)) : e.right > d.right && (g = e.right - d.right + s, t < 0 && e.left < d.left + g && (g = -(d.left + g - e.left + s))) : g = (i == "center" ? e.left + (e.right - e.left) / 2 - (d.right - d.left) / 2 : i == "start" == l ? e.left - s : e.right - (d.right - d.left) + s) - d.left, g || b)
        if (p)
          h.scrollBy(g, b);
        else {
          let v = 0, k = 0;
          if (b) {
            let $ = c.scrollTop;
            c.scrollTop += b / m, k = (c.scrollTop - $) * m;
          }
          if (g) {
            let $ = c.scrollLeft;
            c.scrollLeft += g / f, v = (c.scrollLeft - $) * f;
          }
          e = {
            left: e.left - v,
            top: e.top - k,
            right: e.right - v,
            bottom: e.bottom - k
          }, v && Math.abs(v - g) < 1 && (i = "nearest"), k && Math.abs(k - b) < 1 && (n = "nearest");
        }
      if (p)
        break;
      c = c.assignedSlot || c.parentNode;
    } else if (c.nodeType == 11)
      c = c.host;
    else
      break;
}
function Vy(r) {
  let e = r.ownerDocument;
  for (let t = r.parentNode; t && t != e.body; )
    if (t.nodeType == 1) {
      if (t.scrollHeight > t.clientHeight || t.scrollWidth > t.clientWidth)
        return t;
      t = t.assignedSlot || t.parentNode;
    } else if (t.nodeType == 11)
      t = t.host;
    else
      break;
  return null;
}
class My {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    let { anchorNode: t, focusNode: i } = e;
    this.set(t, Math.min(e.anchorOffset, t ? or(t) : 0), i, Math.min(e.focusOffset, i ? or(i) : 0));
  }
  set(e, t, i, n) {
    this.anchorNode = e, this.anchorOffset = t, this.focusNode = i, this.focusOffset = n;
  }
}
let yi = null;
function AO(r) {
  if (r.setActive)
    return r.setActive();
  if (yi)
    return r.focus(yi);
  let e = [];
  for (let t = r; t && (e.push(t, t.scrollTop, t.scrollLeft), t != t.ownerDocument); t = t.parentNode)
    ;
  if (r.focus(yi == null ? {
    get preventScroll() {
      return yi = { preventScroll: !0 }, !0;
    }
  } : void 0), !yi) {
    yi = !1;
    for (let t = 0; t < e.length; ) {
      let i = e[t++], n = e[t++], s = e[t++];
      i.scrollTop != n && (i.scrollTop = n), i.scrollLeft != s && (i.scrollLeft = s);
    }
  }
}
let td;
function ui(r, e, t = e) {
  let i = td || (td = document.createRange());
  return i.setEnd(r, t), i.setStart(r, e), i;
}
function Zi(r, e, t) {
  let i = { key: e, code: e, keyCode: t, which: t, cancelable: !0 }, n = new KeyboardEvent("keydown", i);
  n.synthetic = !0, r.dispatchEvent(n);
  let s = new KeyboardEvent("keyup", i);
  return s.synthetic = !0, r.dispatchEvent(s), n.defaultPrevented || s.defaultPrevented;
}
function jy(r) {
  for (; r; ) {
    if (r && (r.nodeType == 9 || r.nodeType == 11 && r.host))
      return r;
    r = r.assignedSlot || r.parentNode;
  }
  return null;
}
function EO(r) {
  for (; r.attributes.length; )
    r.removeAttributeNode(r.attributes[0]);
}
function Ly(r, e) {
  let t = e.focusNode, i = e.focusOffset;
  if (!t || e.anchorNode != t || e.anchorOffset != i)
    return !1;
  for (i = Math.min(i, or(t)); ; )
    if (i) {
      if (t.nodeType != 1)
        return !1;
      let n = t.childNodes[i - 1];
      n.contentEditable == "false" ? i-- : (t = n, i = or(t));
    } else {
      if (t == r)
        return !0;
      i = Nn(t), t = t.parentNode;
    }
}
function qO(r) {
  return r.scrollTop > Math.max(1, r.scrollHeight - r.clientHeight - 4);
}
class ze {
  constructor(e, t, i = !0) {
    this.node = e, this.offset = t, this.precise = i;
  }
  static before(e, t) {
    return new ze(e.parentNode, Nn(e), t);
  }
  static after(e, t) {
    return new ze(e.parentNode, Nn(e) + 1, t);
  }
}
const fc = [];
class he {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let t = this.posAtStart;
    for (let i of this.children) {
      if (i == e)
        return t;
      t += i.length + i.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, t) {
    if (this.flags & 2) {
      let i = this.dom, n = null, s;
      for (let o of this.children) {
        if (o.flags & 7) {
          if (!o.dom && (s = n ? n.nextSibling : i.firstChild)) {
            let l = he.get(s);
            (!l || !l.parent && l.canReuseDOM(o)) && o.reuseDOM(s);
          }
          o.sync(e, t), o.flags &= -8;
        }
        if (s = n ? n.nextSibling : i.firstChild, t && !t.written && t.node == i && s != o.dom && (t.written = !0), o.dom.parentNode == i)
          for (; s && s != o.dom; )
            s = rd(s);
        else
          i.insertBefore(o.dom, s);
        n = o.dom;
      }
      for (s = n ? n.nextSibling : i.firstChild, s && t && t.node == i && (t.written = !0); s; )
        s = rd(s);
    } else if (this.flags & 1)
      for (let i of this.children)
        i.flags & 7 && (i.sync(e, t), i.flags &= -8);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, t) {
    let i;
    if (e == this.dom)
      i = this.dom.childNodes[t];
    else {
      let n = or(e) == 0 ? 0 : t == 0 ? -1 : 1;
      for (; ; ) {
        let s = e.parentNode;
        if (s == this.dom)
          break;
        n == 0 && s.firstChild != s.lastChild && (e == s.firstChild ? n = -1 : n = 1), e = s;
      }
      n < 0 ? i = e : i = e.nextSibling;
    }
    if (i == this.dom.firstChild)
      return 0;
    for (; i && !he.get(i); )
      i = i.nextSibling;
    if (!i)
      return this.length;
    for (let n = 0, s = 0; ; n++) {
      let o = this.children[n];
      if (o.dom == i)
        return s;
      s += o.length + o.breakAfter;
    }
  }
  domBoundsAround(e, t, i = 0) {
    let n = -1, s = -1, o = -1, l = -1;
    for (let a = 0, h = i, c = i; a < this.children.length; a++) {
      let u = this.children[a], d = h + u.length;
      if (h < e && d > t)
        return u.domBoundsAround(e, t, h);
      if (d >= e && n == -1 && (n = a, s = h), h > t && u.dom.parentNode == this.dom) {
        o = a, l = c;
        break;
      }
      c = d, h = d + u.breakAfter;
    }
    return {
      from: s,
      to: l < 0 ? i + this.length : l,
      startDOM: (n ? this.children[n - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: o < this.children.length && o >= 0 ? this.children[o].dom : null
    };
  }
  markDirty(e = !1) {
    this.flags |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let t = this.parent; t; t = t.parent) {
      if (e && (t.flags |= 2), t.flags & 1)
        return;
      t.flags |= 1, e = !1;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom != e && (this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this);
  }
  get rootView() {
    for (let e = this; ; ) {
      let t = e.parent;
      if (!t)
        return e;
      e = t;
    }
  }
  replaceChildren(e, t, i = fc) {
    this.markDirty();
    for (let n = e; n < t; n++) {
      let s = this.children[n];
      s.parent == this && i.indexOf(s) < 0 && s.destroy();
    }
    this.children.splice(e, t - e, ...i);
    for (let n = 0; n < i.length; n++)
      i[n].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new zO(this.children, e, this.children.length);
  }
  childPos(e, t = 1) {
    return this.childCursor().findPos(e, t);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, t, i, n, s, o) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let e of this.children)
      e.parent == this && e.destroy();
    this.parent = null;
  }
}
he.prototype.breakAfter = 0;
function rd(r) {
  let e = r.nextSibling;
  return r.parentNode.removeChild(r), e;
}
class zO {
  constructor(e, t, i) {
    this.children = e, this.pos = t, this.i = i, this.off = 0;
  }
  findPos(e, t = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (t > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let i = this.children[--this.i];
      this.pos -= i.length + i.breakAfter;
    }
  }
}
function YO(r, e, t, i, n, s, o, l, a) {
  let { children: h } = r, c = h.length ? h[e] : null, u = s.length ? s[s.length - 1] : null, d = u ? u.breakAfter : o;
  if (!(e == i && c && !o && !d && s.length < 2 && c.merge(t, n, s.length ? u : null, t == 0, l, a))) {
    if (i < h.length) {
      let p = h[i];
      p && (n < p.length || p.breakAfter && (u != null && u.breakAfter)) ? (e == i && (p = p.split(n), n = 0), !d && u && p.merge(0, n, u, !0, 0, a) ? s[s.length - 1] = p : ((n || p.children.length && !p.children[0].length) && p.merge(0, n, null, !1, 0, a), s.push(p))) : p != null && p.breakAfter && (u ? u.breakAfter = 1 : o = 1), i++;
    }
    for (c && (c.breakAfter = o, t > 0 && (!o && s.length && c.merge(t, c.length, s[0], !1, l, 0) ? c.breakAfter = s.shift().breakAfter : (t < c.length || c.children.length && c.children[c.children.length - 1].length == 0) && c.merge(t, c.length, null, !1, l, 0), e++)); e < i && s.length; )
      if (h[i - 1].become(s[s.length - 1]))
        i--, s.pop(), a = s.length ? 0 : l;
      else if (h[e].become(s[0]))
        e++, s.shift(), l = s.length ? 0 : a;
      else
        break;
    !s.length && e && i < h.length && !h[e - 1].breakAfter && h[i].merge(0, 0, h[e - 1], !1, l, a) && e--, (e < i || s.length) && r.replaceChildren(e, i, s);
  }
}
function WO(r, e, t, i, n, s) {
  let o = r.childCursor(), { i: l, off: a } = o.findPos(t, 1), { i: h, off: c } = o.findPos(e, -1), u = e - t;
  for (let d of i)
    u += d.length;
  r.length += u, YO(r, h, c, l, a, i, 0, n, s);
}
let it = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, rh = typeof document < "u" ? document : { documentElement: { style: {} } };
const ih = /* @__PURE__ */ /Edge\/(\d+)/.exec(it.userAgent), VO = /* @__PURE__ */ /MSIE \d/.test(it.userAgent), nh = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(it.userAgent), pl = !!(VO || nh || ih), id = !pl && /* @__PURE__ */ /gecko\/(\d+)/i.test(it.userAgent), Ul = !pl && /* @__PURE__ */ /Chrome\/(\d+)/.exec(it.userAgent), nd = "webkitFontSmoothing" in rh.documentElement.style, MO = !pl && /* @__PURE__ */ /Apple Computer/.test(it.vendor), sd = MO && (/* @__PURE__ */ /Mobile\/\w+/.test(it.userAgent) || it.maxTouchPoints > 2);
var R = {
  mac: sd || /* @__PURE__ */ /Mac/.test(it.platform),
  windows: /* @__PURE__ */ /Win/.test(it.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(it.platform),
  ie: pl,
  ie_version: VO ? rh.documentMode || 6 : nh ? +nh[1] : ih ? +ih[1] : 0,
  gecko: id,
  gecko_version: id ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(it.userAgent) || [0, 0])[1] : 0,
  chrome: !!Ul,
  chrome_version: Ul ? +Ul[1] : 0,
  ios: sd,
  android: /* @__PURE__ */ /Android\b/.test(it.userAgent),
  webkit: nd,
  safari: MO,
  webkit_version: nd ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
  tabSize: rh.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const By = 256;
class lr extends he {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, t) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (t && t.node == this.dom && (t.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, t, i) {
    return this.flags & 8 || i && (!(i instanceof lr) || this.length - (t - e) + i.length > By || i.flags & 8) ? !1 : (this.text = this.text.slice(0, e) + (i ? i.text : "") + this.text.slice(t), this.markDirty(), !0);
  }
  split(e) {
    let t = new lr(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), t.flags |= this.flags & 8, t;
  }
  localPosFromDOM(e, t) {
    return e == this.dom ? t : t ? this.text.length : 0;
  }
  domAtPos(e) {
    return new ze(this.dom, e);
  }
  domBoundsAround(e, t, i) {
    return { from: i, to: i + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, t) {
    return Dy(this.dom, e, t);
  }
}
class ar extends he {
  constructor(e, t = [], i = 0) {
    super(), this.mark = e, this.children = t, this.length = i;
    for (let n of t)
      n.setParent(this);
  }
  setAttrs(e) {
    if (EO(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let t in this.mark.attrs)
        e.setAttribute(t, this.mark.attrs[t]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, t) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, t);
  }
  merge(e, t, i, n, s, o) {
    return i && (!(i instanceof ar && i.mark.eq(this.mark)) || e && s <= 0 || t < this.length && o <= 0) ? !1 : (WO(this, e, t, i ? i.children.slice() : [], s - 1, o - 1), this.markDirty(), !0);
  }
  split(e) {
    let t = [], i = 0, n = -1, s = 0;
    for (let l of this.children) {
      let a = i + l.length;
      a > e && t.push(i < e ? l.split(e - i) : l), n < 0 && i >= e && (n = s), i = a, s++;
    }
    let o = this.length - e;
    return this.length = e, n > -1 && (this.children.length = n, this.markDirty()), new ar(this.mark, t, o);
  }
  domAtPos(e) {
    return jO(this, e);
  }
  coordsAt(e, t) {
    return BO(this, e, t);
  }
}
function Dy(r, e, t) {
  let i = r.nodeValue.length;
  e > i && (e = i);
  let n = e, s = e, o = 0;
  e == 0 && t < 0 || e == i && t >= 0 ? R.chrome || R.gecko || (e ? (n--, o = 1) : s < i && (s++, o = -1)) : t < 0 ? n-- : s < i && s++;
  let l = ui(r, n, s).getClientRects();
  if (!l.length)
    return null;
  let a = l[(o ? o < 0 : t >= 0) ? 0 : l.length - 1];
  return R.safari && !o && a.width == 0 && (a = Array.prototype.find.call(l, (h) => h.width) || a), o ? dl(a, o < 0) : a || null;
}
class xr extends he {
  static create(e, t, i) {
    return new xr(e, t, i);
  }
  constructor(e, t, i) {
    super(), this.widget = e, this.length = t, this.side = i, this.prevWidget = null;
  }
  split(e) {
    let t = xr.create(this.widget, this.length - e, this.side);
    return this.length -= e, t;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(e, t, i, n, s, o) {
    return i && (!(i instanceof xr) || !this.widget.compare(i.widget) || e > 0 && s <= 0 || t < this.length && o <= 0) ? !1 : (this.length = e + (i ? i.length : 0) + (this.length - t), !0);
  }
  become(e) {
    return e instanceof xr && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return K.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: t } = e, i = t && t.state.doc, n = this.posAtStart;
    return i ? i.slice(n, n + this.length) : K.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? ze.before(this.dom) : ze.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, t) {
    let i = this.widget.coordsAt(this.dom, e, t);
    if (i)
      return i;
    let n = this.dom.getClientRects(), s = null;
    if (!n.length)
      return null;
    let o = this.side ? this.side < 0 : e > 0;
    for (let l = o ? n.length - 1 : 0; s = n[l], !(e > 0 ? l == 0 : l == n.length - 1 || s.top < s.bottom); l += o ? -1 : 1)
      ;
    return dl(s, !o);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class Di extends he {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof Di && e.side == this.side;
  }
  split() {
    return new Di(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? ze.before(this.dom) : ze.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return K.empty;
  }
  get isHidden() {
    return !0;
  }
}
lr.prototype.children = xr.prototype.children = Di.prototype.children = fc;
function jO(r, e) {
  let t = r.dom, { children: i } = r, n = 0;
  for (let s = 0; n < i.length; n++) {
    let o = i[n], l = s + o.length;
    if (!(l == s && o.getSide() <= 0)) {
      if (e > s && e < l && o.dom.parentNode == t)
        return o.domAtPos(e - s);
      if (e <= s)
        break;
      s = l;
    }
  }
  for (let s = n; s > 0; s--) {
    let o = i[s - 1];
    if (o.dom.parentNode == t)
      return o.domAtPos(o.length);
  }
  for (let s = n; s < i.length; s++) {
    let o = i[s];
    if (o.dom.parentNode == t)
      return o.domAtPos(0);
  }
  return new ze(t, 0);
}
function LO(r, e, t) {
  let i, { children: n } = r;
  t > 0 && e instanceof ar && n.length && (i = n[n.length - 1]) instanceof ar && i.mark.eq(e.mark) ? LO(i, e.children[0], t - 1) : (n.push(e), e.setParent(r)), r.length += e.length;
}
function BO(r, e, t) {
  let i = null, n = -1, s = null, o = -1;
  function l(h, c) {
    for (let u = 0, d = 0; u < h.children.length && d <= c; u++) {
      let p = h.children[u], f = d + p.length;
      f >= c && (p.children.length ? l(p, c - d) : (!s || s.isHidden && t > 0) && (f > c || d == f && p.getSide() > 0) ? (s = p, o = c - d) : (d < c || d == f && p.getSide() < 0 && !p.isHidden) && (i = p, n = c - d)), d = f;
    }
  }
  l(r, e);
  let a = (t < 0 ? i : s) || i || s;
  return a ? a.coordsAt(Math.max(0, a == i ? n : o), t) : Iy(r);
}
function Iy(r) {
  let e = r.dom.lastChild;
  if (!e)
    return r.dom.getBoundingClientRect();
  let t = Bi(e);
  return t[t.length - 1] || null;
}
function sh(r, e) {
  for (let t in r)
    t == "class" && e.class ? e.class += " " + r.class : t == "style" && e.style ? e.style += ";" + r.style : e[t] = r[t];
  return e;
}
const od = /* @__PURE__ */ Object.create(null);
function Oc(r, e, t) {
  if (r == e)
    return !0;
  r || (r = od), e || (e = od);
  let i = Object.keys(r), n = Object.keys(e);
  if (i.length - (t && i.indexOf(t) > -1 ? 1 : 0) != n.length - (t && n.indexOf(t) > -1 ? 1 : 0))
    return !1;
  for (let s of i)
    if (s != t && (n.indexOf(s) == -1 || r[s] !== e[s]))
      return !1;
  return !0;
}
function oh(r, e, t) {
  let i = !1;
  if (e)
    for (let n in e)
      t && n in t || (i = !0, n == "style" ? r.style.cssText = "" : r.removeAttribute(n));
  if (t)
    for (let n in t)
      e && e[n] == t[n] || (i = !0, n == "style" ? r.style.cssText = t[n] : r.setAttribute(n, t[n]));
  return i;
}
function Uy(r) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t = 0; t < r.attributes.length; t++) {
    let i = r.attributes[t];
    e[i.name] = i.value;
  }
  return e;
}
class Se extends he {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e, t, i, n, s, o) {
    if (i) {
      if (!(i instanceof Se))
        return !1;
      this.dom || i.transferDOM(this);
    }
    return n && this.setDeco(i ? i.attrs : null), WO(this, e, t, i ? i.children.slice() : [], s, o), !0;
  }
  split(e) {
    let t = new Se();
    if (t.breakAfter = this.breakAfter, this.length == 0)
      return t;
    let { i, off: n } = this.childPos(e);
    n && (t.append(this.children[i].split(n), 0), this.children[i].merge(n, this.children[i].length, null, !1, 0, 0), i++);
    for (let s = i; s < this.children.length; s++)
      t.append(this.children[s], 0);
    for (; i > 0 && this.children[i - 1].length == 0; )
      this.children[--i].destroy();
    return this.children.length = i, this.markDirty(), this.length = e, t;
  }
  transferDOM(e) {
    this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    Oc(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, t) {
    LO(this, e, t);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e) {
    let t = e.spec.attributes, i = e.spec.class;
    t && (this.attrs = sh(t, this.attrs || {})), i && (this.attrs = sh({ class: i }, this.attrs || {}));
  }
  domAtPos(e) {
    return jO(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, t) {
    var i;
    this.dom ? this.flags & 4 && (EO(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (oh(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, t);
    let n = this.dom.lastChild;
    for (; n && he.get(n) instanceof ar; )
      n = n.lastChild;
    if (!n || !this.length || n.nodeName != "BR" && ((i = he.get(n)) === null || i === void 0 ? void 0 : i.isEditable) == !1 && (!R.ios || !this.children.some((s) => s instanceof lr))) {
      let s = document.createElement("BR");
      s.cmIgnore = !0, this.dom.appendChild(s);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0, t;
    for (let i of this.children) {
      if (!(i instanceof lr) || /[^ -~]/.test(i.text))
        return null;
      let n = Bi(i.dom);
      if (n.length != 1)
        return null;
      e += n[0].width, t = n[0].height;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length,
      textHeight: t
    } : null;
  }
  coordsAt(e, t) {
    let i = BO(this, e, t);
    if (!this.children.length && i && this.parent) {
      let { heightOracle: n } = this.parent.view.viewState, s = i.bottom - i.top;
      if (Math.abs(s - n.lineHeight) < 2 && n.textHeight < s) {
        let o = (s - n.textHeight) / 2;
        return { top: i.top + o, bottom: i.bottom - o, left: i.left, right: i.left };
      }
    }
    return i;
  }
  become(e) {
    return !1;
  }
  covers() {
    return !0;
  }
  static find(e, t) {
    for (let i = 0, n = 0; i < e.children.length; i++) {
      let s = e.children[i], o = n + s.length;
      if (o >= t) {
        if (s instanceof Se)
          return s;
        if (o > t)
          break;
      }
      n = o + s.breakAfter;
    }
    return null;
  }
}
class Qr extends he {
  constructor(e, t, i) {
    super(), this.widget = e, this.length = t, this.deco = i, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, t, i, n, s, o) {
    return i && (!(i instanceof Qr) || !this.widget.compare(i.widget) || e > 0 && s <= 0 || t < this.length && o <= 0) ? !1 : (this.length = e + (i ? i.length : 0) + (this.length - t), !0);
  }
  domAtPos(e) {
    return e == 0 ? ze.before(this.dom) : ze.after(this.dom, e == this.length);
  }
  split(e) {
    let t = this.length - e;
    this.length = e;
    let i = new Qr(this.widget, t, this.deco);
    return i.breakAfter = this.breakAfter, i;
  }
  get children() {
    return fc;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : K.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof Qr && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.deco = e.deco, this.breakAfter = e.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, t) {
    return this.widget.coordsAt(this.dom, e, t);
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(e) {
    let { startSide: t, endSide: i } = this.deco;
    return t == i ? !1 : e < 0 ? t < 0 : i > 0;
  }
}
class Kt {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e, t) {
    return !1;
  }
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queried—less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(e, t, i) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e) {
  }
}
var Le = /* @__PURE__ */ function(r) {
  return r[r.Text = 0] = "Text", r[r.WidgetBefore = 1] = "WidgetBefore", r[r.WidgetAfter = 2] = "WidgetAfter", r[r.WidgetRange = 3] = "WidgetRange", r;
}(Le || (Le = {}));
class E extends ci {
  constructor(e, t, i, n) {
    super(), this.startSide = e, this.endSide = t, this.widget = i, this.spec = n;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(e) {
    return new vs(e);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(e) {
    let t = Math.max(-1e4, Math.min(1e4, e.side || 0)), i = !!e.block;
    return t += i && !e.inlineOrder ? t > 0 ? 3e8 : -4e8 : t > 0 ? 1e8 : -1e8, new zr(e, t, t, i, e.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e) {
    let t = !!e.block, i, n;
    if (e.isBlockGap)
      i = -5e8, n = 4e8;
    else {
      let { start: s, end: o } = DO(e, t);
      i = (s ? t ? -3e8 : -1 : 5e8) - 1, n = (o ? t ? 2e8 : 1 : -6e8) + 1;
    }
    return new zr(e, i, n, t, e.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e) {
    return new xs(e);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e, t = !1) {
    return H.of(e, t);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
E.none = H.empty;
class vs extends E {
  constructor(e) {
    let { start: t, end: i } = DO(e);
    super(t ? -1 : 5e8, i ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    var t, i;
    return this == e || e instanceof vs && this.tagName == e.tagName && (this.class || ((t = this.attrs) === null || t === void 0 ? void 0 : t.class)) == (e.class || ((i = e.attrs) === null || i === void 0 ? void 0 : i.class)) && Oc(this.attrs, e.attrs, "class");
  }
  range(e, t = e) {
    if (e >= t)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, t);
  }
}
vs.prototype.point = !1;
class xs extends E {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof xs && this.spec.class == e.spec.class && Oc(this.spec.attributes, e.spec.attributes);
  }
  range(e, t = e) {
    if (t != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, t);
  }
}
xs.prototype.mapMode = Xe.TrackBefore;
xs.prototype.point = !0;
class zr extends E {
  constructor(e, t, i, n, s, o) {
    super(t, i, s, e), this.block = n, this.isReplace = o, this.mapMode = n ? t <= 0 ? Xe.TrackBefore : Xe.TrackAfter : Xe.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? Le.WidgetRange : this.startSide <= 0 ? Le.WidgetBefore : Le.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e) {
    return e instanceof zr && Gy(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, t = e) {
    if (this.isReplace && (e > t || e == t && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && t != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, t);
  }
}
zr.prototype.point = !0;
function DO(r, e = !1) {
  let { inclusiveStart: t, inclusiveEnd: i } = r;
  return t == null && (t = r.inclusive), i == null && (i = r.inclusive), { start: t ?? e, end: i ?? e };
}
function Gy(r, e) {
  return r == e || !!(r && e && r.compare(e));
}
function lh(r, e, t, i = 0) {
  let n = t.length - 1;
  n >= 0 && t[n] + i >= r ? t[n] = Math.max(t[n], e) : t.push(r, e);
}
class zn {
  constructor(e, t, i, n) {
    this.doc = e, this.pos = t, this.end = i, this.disallowBlockEffectsFor = n, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = t;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !(e.breakAfter || e instanceof Qr && e.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new Se()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(Es(new Di(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1] instanceof Qr) && this.getLine();
  }
  buildText(e, t, i) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: s, lineBreak: o, done: l } = this.cursor.next(this.skip);
        if (this.skip = 0, l)
          throw new Error("Ran out of text content when drawing inline views");
        if (o) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;
          continue;
        } else
          this.text = s, this.textOff = 0;
      }
      let n = Math.min(
        this.text.length - this.textOff,
        e,
        512
        /* T.Chunk */
      );
      this.flushBuffer(t.slice(t.length - i)), this.getLine().append(Es(new lr(this.text.slice(this.textOff, this.textOff + n)), t), i), this.atCursorPos = !0, this.textOff += n, e -= n, i = 0;
    }
  }
  span(e, t, i, n) {
    this.buildText(t - e, i, n), this.pos = t, this.openStart < 0 && (this.openStart = n);
  }
  point(e, t, i, n, s, o) {
    if (this.disallowBlockEffectsFor[o] && i instanceof zr) {
      if (i.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (t > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let l = t - e;
    if (i instanceof zr)
      if (i.block)
        i.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new Qr(i.widget || new ld("div"), l, i));
      else {
        let a = xr.create(i.widget || new ld("span"), l, l ? 0 : i.startSide), h = this.atCursorPos && !a.isEditable && s <= n.length && (e < t || i.startSide > 0), c = !a.isEditable && (e < t || s > n.length || i.startSide <= 0), u = this.getLine();
        this.pendingBuffer == 2 && !h && !a.isEditable && (this.pendingBuffer = 0), this.flushBuffer(n), h && (u.append(Es(new Di(1), n), s), s = n.length + Math.max(0, s - n.length)), u.append(Es(a, n), s), this.atCursorPos = c, this.pendingBuffer = c ? e < t || s > n.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = n.slice());
      }
    else
      this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(i);
    l && (this.textOff + l <= this.text.length ? this.textOff += l : (this.skip += l - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = t), this.openStart < 0 && (this.openStart = s);
  }
  static build(e, t, i, n, s) {
    let o = new zn(e, t, i, s);
    return o.openEnd = H.spans(n, t, i, o), o.openStart < 0 && (o.openStart = o.openEnd), o.finish(o.openEnd), o;
  }
}
function Es(r, e) {
  for (let t of e)
    r = new ar(t, [r], r.length);
  return r;
}
class ld extends Kt {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
var ce = /* @__PURE__ */ function(r) {
  return r[r.LTR = 0] = "LTR", r[r.RTL = 1] = "RTL", r;
}(ce || (ce = {}));
const di = ce.LTR, mc = ce.RTL;
function IO(r) {
  let e = [];
  for (let t = 0; t < r.length; t++)
    e.push(1 << +r[t]);
  return e;
}
const Ny = /* @__PURE__ */ IO("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), Fy = /* @__PURE__ */ IO("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), ah = /* @__PURE__ */ Object.create(null), Et = [];
for (let r of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ r.charCodeAt(0), t = /* @__PURE__ */ r.charCodeAt(1);
  ah[e] = t, ah[t] = -e;
}
function UO(r) {
  return r <= 247 ? Ny[r] : 1424 <= r && r <= 1524 ? 2 : 1536 <= r && r <= 1785 ? Fy[r - 1536] : 1774 <= r && r <= 2220 ? 4 : 8192 <= r && r <= 8204 ? 256 : 64336 <= r && r <= 65023 ? 4 : 1;
}
const Hy = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class Sr {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? mc : di;
  }
  /**
  @internal
  */
  constructor(e, t, i) {
    this.from = e, this.to = t, this.level = i;
  }
  /**
  @internal
  */
  side(e, t) {
    return this.dir == t == e ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(e, t) {
    return e == (this.dir == t);
  }
  /**
  @internal
  */
  static find(e, t, i, n) {
    let s = -1;
    for (let o = 0; o < e.length; o++) {
      let l = e[o];
      if (l.from <= t && l.to >= t) {
        if (l.level == i)
          return o;
        (s < 0 || (n != 0 ? n < 0 ? l.from < t : l.to > t : e[s].level > l.level)) && (s = o);
      }
    }
    if (s < 0)
      throw new RangeError("Index out of range");
    return s;
  }
}
function GO(r, e) {
  if (r.length != e.length)
    return !1;
  for (let t = 0; t < r.length; t++) {
    let i = r[t], n = e[t];
    if (i.from != n.from || i.to != n.to || i.direction != n.direction || !GO(i.inner, n.inner))
      return !1;
  }
  return !0;
}
const ie = [];
function Ky(r, e, t, i, n) {
  for (let s = 0; s <= i.length; s++) {
    let o = s ? i[s - 1].to : e, l = s < i.length ? i[s].from : t, a = s ? 256 : n;
    for (let h = o, c = a, u = a; h < l; h++) {
      let d = UO(r.charCodeAt(h));
      d == 512 ? d = c : d == 8 && u == 4 && (d = 16), ie[h] = d == 4 ? 2 : d, d & 7 && (u = d), c = d;
    }
    for (let h = o, c = a, u = a; h < l; h++) {
      let d = ie[h];
      if (d == 128)
        h < l - 1 && c == ie[h + 1] && c & 24 ? d = ie[h] = c : ie[h] = 256;
      else if (d == 64) {
        let p = h + 1;
        for (; p < l && ie[p] == 64; )
          p++;
        let f = h && c == 8 || p < t && ie[p] == 8 ? u == 1 ? 1 : 8 : 256;
        for (let m = h; m < p; m++)
          ie[m] = f;
        h = p - 1;
      } else
        d == 8 && u == 1 && (ie[h] = 1);
      c = d, d & 7 && (u = d);
    }
  }
}
function Jy(r, e, t, i, n) {
  let s = n == 1 ? 2 : 1;
  for (let o = 0, l = 0, a = 0; o <= i.length; o++) {
    let h = o ? i[o - 1].to : e, c = o < i.length ? i[o].from : t;
    for (let u = h, d, p, f; u < c; u++)
      if (p = ah[d = r.charCodeAt(u)])
        if (p < 0) {
          for (let m = l - 3; m >= 0; m -= 3)
            if (Et[m + 1] == -p) {
              let g = Et[m + 2], b = g & 2 ? n : g & 4 ? g & 1 ? s : n : 0;
              b && (ie[u] = ie[Et[m]] = b), l = m;
              break;
            }
        } else {
          if (Et.length == 189)
            break;
          Et[l++] = u, Et[l++] = d, Et[l++] = a;
        }
      else if ((f = ie[u]) == 2 || f == 1) {
        let m = f == n;
        a = m ? 0 : 1;
        for (let g = l - 3; g >= 0; g -= 3) {
          let b = Et[g + 2];
          if (b & 2)
            break;
          if (m)
            Et[g + 2] |= 2;
          else {
            if (b & 4)
              break;
            Et[g + 2] |= 4;
          }
        }
      }
  }
}
function ev(r, e, t, i) {
  for (let n = 0, s = i; n <= t.length; n++) {
    let o = n ? t[n - 1].to : r, l = n < t.length ? t[n].from : e;
    for (let a = o; a < l; ) {
      let h = ie[a];
      if (h == 256) {
        let c = a + 1;
        for (; ; )
          if (c == l) {
            if (n == t.length)
              break;
            c = t[n++].to, l = n < t.length ? t[n].from : e;
          } else if (ie[c] == 256)
            c++;
          else
            break;
        let u = s == 1, d = (c < e ? ie[c] : i) == 1, p = u == d ? u ? 1 : 2 : i;
        for (let f = c, m = n, g = m ? t[m - 1].to : r; f > a; )
          f == g && (f = t[--m].from, g = m ? t[m - 1].to : r), ie[--f] = p;
        a = c;
      } else
        s = h, a++;
    }
  }
}
function hh(r, e, t, i, n, s, o) {
  let l = i % 2 ? 2 : 1;
  if (i % 2 == n % 2)
    for (let a = e, h = 0; a < t; ) {
      let c = !0, u = !1;
      if (h == s.length || a < s[h].from) {
        let m = ie[a];
        m != l && (c = !1, u = m == 16);
      }
      let d = !c && l == 1 ? [] : null, p = c ? i : i + 1, f = a;
      e:
        for (; ; )
          if (h < s.length && f == s[h].from) {
            if (u)
              break e;
            let m = s[h];
            if (!c)
              for (let g = m.to, b = h + 1; ; ) {
                if (g == t)
                  break e;
                if (b < s.length && s[b].from == g)
                  g = s[b++].to;
                else {
                  if (ie[g] == l)
                    break e;
                  break;
                }
              }
            if (h++, d)
              d.push(m);
            else {
              m.from > a && o.push(new Sr(a, m.from, p));
              let g = m.direction == di != !(p % 2);
              ch(r, g ? i + 1 : i, n, m.inner, m.from, m.to, o), a = m.to;
            }
            f = m.to;
          } else {
            if (f == t || (c ? ie[f] != l : ie[f] == l))
              break;
            f++;
          }
      d ? hh(r, a, f, i + 1, n, d, o) : a < f && o.push(new Sr(a, f, p)), a = f;
    }
  else
    for (let a = t, h = s.length; a > e; ) {
      let c = !0, u = !1;
      if (!h || a > s[h - 1].to) {
        let m = ie[a - 1];
        m != l && (c = !1, u = m == 16);
      }
      let d = !c && l == 1 ? [] : null, p = c ? i : i + 1, f = a;
      e:
        for (; ; )
          if (h && f == s[h - 1].to) {
            if (u)
              break e;
            let m = s[--h];
            if (!c)
              for (let g = m.from, b = h; ; ) {
                if (g == e)
                  break e;
                if (b && s[b - 1].to == g)
                  g = s[--b].from;
                else {
                  if (ie[g - 1] == l)
                    break e;
                  break;
                }
              }
            if (d)
              d.push(m);
            else {
              m.to < a && o.push(new Sr(m.to, a, p));
              let g = m.direction == di != !(p % 2);
              ch(r, g ? i + 1 : i, n, m.inner, m.from, m.to, o), a = m.from;
            }
            f = m.from;
          } else {
            if (f == e || (c ? ie[f - 1] != l : ie[f - 1] == l))
              break;
            f--;
          }
      d ? hh(r, f, a, i + 1, n, d, o) : f < a && o.push(new Sr(f, a, p)), a = f;
    }
}
function ch(r, e, t, i, n, s, o) {
  let l = e % 2 ? 2 : 1;
  Ky(r, n, s, i, l), Jy(r, n, s, i, l), ev(n, s, i, l), hh(r, n, s, e, t, i, o);
}
function tv(r, e, t) {
  if (!r)
    return [new Sr(0, 0, e == mc ? 1 : 0)];
  if (e == di && !t.length && !Hy.test(r))
    return NO(r.length);
  if (t.length)
    for (; r.length > ie.length; )
      ie[ie.length] = 256;
  let i = [], n = e == di ? 0 : 1;
  return ch(r, n, n, t, 0, r.length, i), i;
}
function NO(r) {
  return [new Sr(0, r, 0)];
}
let FO = "";
function rv(r, e, t, i, n) {
  var s;
  let o = i.head - r.from, l = Sr.find(e, o, (s = i.bidiLevel) !== null && s !== void 0 ? s : -1, i.assoc), a = e[l], h = a.side(n, t);
  if (o == h) {
    let d = l += n ? 1 : -1;
    if (d < 0 || d >= e.length)
      return null;
    a = e[l = d], o = a.side(!n, t), h = a.side(n, t);
  }
  let c = _e(r.text, o, a.forward(n, t));
  (c < a.from || c > a.to) && (c = h), FO = r.text.slice(Math.min(o, c), Math.max(o, c));
  let u = l == (n ? e.length - 1 : 0) ? null : e[l + (n ? 1 : -1)];
  return u && c == h && u.level + (n ? 0 : 1) < a.level ? S.cursor(u.side(!n, t) + r.from, u.forward(n, t) ? 1 : -1, u.level) : S.cursor(c + r.from, a.forward(n, t) ? -1 : 1, a.level);
}
function iv(r, e, t) {
  for (let i = e; i < t; i++) {
    let n = UO(r.charCodeAt(i));
    if (n == 1)
      return di;
    if (n == 2 || n == 4)
      return mc;
  }
  return di;
}
const HO = /* @__PURE__ */ _.define(), KO = /* @__PURE__ */ _.define(), JO = /* @__PURE__ */ _.define(), em = /* @__PURE__ */ _.define(), uh = /* @__PURE__ */ _.define(), tm = /* @__PURE__ */ _.define(), rm = /* @__PURE__ */ _.define(), im = /* @__PURE__ */ _.define({
  combine: (r) => r.some((e) => e)
}), nm = /* @__PURE__ */ _.define({
  combine: (r) => r.some((e) => e)
});
class _i {
  constructor(e, t = "nearest", i = "nearest", n = 5, s = 5, o = !1) {
    this.range = e, this.y = t, this.x = i, this.yMargin = n, this.xMargin = s, this.isSnapshot = o;
  }
  map(e) {
    return e.empty ? this : new _i(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(e) {
    return this.range.to <= e.doc.length ? this : new _i(S.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const qs = /* @__PURE__ */ j.define({ map: (r, e) => r.map(e) });
function gt(r, e, t) {
  let i = r.facet(em);
  i.length ? i[0](e) : window.onerror ? window.onerror(String(e), t, void 0, void 0, e) : t ? console.error(t + ":", e) : console.error(e);
}
const fl = /* @__PURE__ */ _.define({ combine: (r) => r.length ? r[0] : !0 });
let nv = 0;
const kn = /* @__PURE__ */ _.define();
class ge {
  constructor(e, t, i, n, s) {
    this.id = e, this.create = t, this.domEventHandlers = i, this.domEventObservers = n, this.extension = s(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e, t) {
    const { eventHandlers: i, eventObservers: n, provide: s, decorations: o } = t || {};
    return new ge(nv++, e, i, n, (l) => {
      let a = [kn.of(l)];
      return o && a.push(Fn.of((h) => {
        let c = h.plugin(l);
        return c ? o(c) : E.none;
      })), s && a.push(s(l)), a;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e, t) {
    return ge.define((i) => new e(i), t);
  }
}
class Gl {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let t = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(t);
          } catch (i) {
            if (gt(t.state, i, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(e);
      } catch (t) {
        gt(e.state, t, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var t;
    if (!((t = this.value) === null || t === void 0) && t.destroy)
      try {
        this.value.destroy();
      } catch (i) {
        gt(e.state, i, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const sm = /* @__PURE__ */ _.define(), gc = /* @__PURE__ */ _.define(), Fn = /* @__PURE__ */ _.define(), om = /* @__PURE__ */ _.define(), bc = /* @__PURE__ */ _.define(), lm = /* @__PURE__ */ _.define();
function ad(r, e) {
  let t = r.state.facet(lm);
  if (!t.length)
    return t;
  let i = t.map((s) => s instanceof Function ? s(r) : s), n = [];
  return H.spans(i, e.from, e.to, {
    point() {
    },
    span(s, o, l, a) {
      let h = s - e.from, c = o - e.from, u = n;
      for (let d = l.length - 1; d >= 0; d--, a--) {
        let p = l[d].spec.bidiIsolate, f;
        if (p == null && (p = iv(e.text, h, c)), a > 0 && u.length && (f = u[u.length - 1]).to == h && f.direction == p)
          f.to = c, u = f.inner;
        else {
          let m = { from: h, to: c, direction: p, inner: [] };
          u.push(m), u = m.inner;
        }
      }
    }
  }), n;
}
const am = /* @__PURE__ */ _.define();
function hm(r) {
  let e = 0, t = 0, i = 0, n = 0;
  for (let s of r.state.facet(am)) {
    let o = s(r);
    o && (o.left != null && (e = Math.max(e, o.left)), o.right != null && (t = Math.max(t, o.right)), o.top != null && (i = Math.max(i, o.top)), o.bottom != null && (n = Math.max(n, o.bottom)));
  }
  return { left: e, right: t, top: i, bottom: n };
}
const $n = /* @__PURE__ */ _.define();
class bt {
  constructor(e, t, i, n) {
    this.fromA = e, this.toA = t, this.fromB = i, this.toB = n;
  }
  join(e) {
    return new bt(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let t = e.length, i = this;
    for (; t > 0; t--) {
      let n = e[t - 1];
      if (!(n.fromA > i.toA)) {
        if (n.toA < i.fromA)
          break;
        i = i.join(n), e.splice(t - 1, 1);
      }
    }
    return e.splice(t, 0, i), e;
  }
  static extendWithRanges(e, t) {
    if (t.length == 0)
      return e;
    let i = [];
    for (let n = 0, s = 0, o = 0, l = 0; ; n++) {
      let a = n == e.length ? null : e[n], h = o - l, c = a ? a.fromB : 1e9;
      for (; s < t.length && t[s] < c; ) {
        let u = t[s], d = t[s + 1], p = Math.max(l, u), f = Math.min(c, d);
        if (p <= f && new bt(p + h, f + h, p, f).addToSet(i), d > c)
          break;
        s += 2;
      }
      if (!a)
        return i;
      new bt(a.fromA, a.toA, a.fromB, a.toB).addToSet(i), o = a.toA, l = a.toB;
    }
  }
}
class _o {
  constructor(e, t, i) {
    this.view = e, this.state = t, this.transactions = i, this.flags = 0, this.startState = e.state, this.changes = ke.empty(this.startState.doc.length);
    for (let s of i)
      this.changes = this.changes.compose(s.changes);
    let n = [];
    this.changes.iterChangedRanges((s, o, l, a) => n.push(new bt(s, o, l, a))), this.changedRanges = n;
  }
  /**
  @internal
  */
  static create(e, t, i) {
    return new _o(e, t, i);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 10) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
class hd extends he {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(e) {
    super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new Se()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new bt(0, 0, 0, e.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(e) {
    var t;
    let i = e.changedRanges;
    this.minWidth > 0 && i.length && (i.every(({ fromA: h, toA: c }) => c < this.minWidthFrom || h > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0);
    let n = -1;
    this.view.inputState.composing >= 0 && (!((t = this.domChanged) === null || t === void 0) && t.newSel ? n = this.domChanged.newSel.head : !uv(e.changes, this.hasComposition) && !e.selectionSet && (n = e.state.selection.main.head));
    let s = n > -1 ? ov(this.view, e.changes, n) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: h, to: c } = this.hasComposition;
      i = new bt(h, c, e.changes.mapPos(h, -1), e.changes.mapPos(c, 1)).addToSet(i.slice());
    }
    this.hasComposition = s ? { from: s.range.fromB, to: s.range.toB } : null, (R.ie || R.chrome) && !s && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let o = this.decorations, l = this.updateDeco(), a = hv(o, l, e.changes);
    return i = bt.extendWithRanges(i, a), !(this.flags & 7) && i.length == 0 ? !1 : (this.updateInner(i, e.startState.doc.length, s), e.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e, t, i) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, t, i);
    let { observer: n } = this.view;
    n.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let o = R.chrome || R.ios ? { node: n.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, o), this.flags &= -8, o && (o.written || n.selectionRange.focusNode != o.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (o) => o.flags &= -9
      /* ViewFlag.Composition */
    );
    let s = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let o of this.children)
        o instanceof Qr && o.widget instanceof cd && s.push(o.dom);
    n.updateGaps(s);
  }
  updateChildren(e, t, i) {
    let n = i ? i.range.addToSet(e.slice()) : e, s = this.childCursor(t);
    for (let o = n.length - 1; ; o--) {
      let l = o >= 0 ? n[o] : null;
      if (!l)
        break;
      let { fromA: a, toA: h, fromB: c, toB: u } = l, d, p, f, m;
      if (i && i.range.fromB < u && i.range.toB > c) {
        let $ = zn.build(this.view.state.doc, c, i.range.fromB, this.decorations, this.dynamicDecorationMap), x = zn.build(this.view.state.doc, i.range.toB, u, this.decorations, this.dynamicDecorationMap);
        p = $.breakAtStart, f = $.openStart, m = x.openEnd;
        let Q = this.compositionView(i);
        x.breakAtStart ? Q.breakAfter = 1 : x.content.length && Q.merge(Q.length, Q.length, x.content[0], !1, x.openStart, 0) && (Q.breakAfter = x.content[0].breakAfter, x.content.shift()), $.content.length && Q.merge(0, 0, $.content[$.content.length - 1], !0, 0, $.openEnd) && $.content.pop(), d = $.content.concat(Q).concat(x.content);
      } else
        ({ content: d, breakAtStart: p, openStart: f, openEnd: m } = zn.build(this.view.state.doc, c, u, this.decorations, this.dynamicDecorationMap));
      let { i: g, off: b } = s.findPos(h, 1), { i: v, off: k } = s.findPos(a, -1);
      YO(this, v, k, g, b, d, p, f, m);
    }
    i && this.fixCompositionDOM(i);
  }
  compositionView(e) {
    let t = new lr(e.text.nodeValue);
    t.flags |= 8;
    for (let { deco: n } of e.marks)
      t = new ar(n, [t], t.length);
    let i = new Se();
    return i.append(t, 0), i;
  }
  fixCompositionDOM(e) {
    let t = (s, o) => {
      o.flags |= 8 | (o.children.some(
        (a) => a.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(o);
      let l = he.get(s);
      l && l != o && (l.dom = null), o.setDOM(s);
    }, i = this.childPos(e.range.fromB, 1), n = this.children[i.i];
    t(e.line, n);
    for (let s = e.marks.length - 1; s >= -1; s--)
      i = n.childPos(i.off, 1), n = n.children[i.i], t(s >= 0 ? e.marks[s].node : e.text, n);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e = !1, t = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let i = this.view.root.activeElement, n = i == this.dom, s = !n && uo(this.dom, this.view.observer.selectionRange) && !(i && this.dom.contains(i));
    if (!(n || t || s))
      return;
    let o = this.forceSelection;
    this.forceSelection = !1;
    let l = this.view.state.selection.main, a = this.moveToLine(this.domAtPos(l.anchor)), h = l.empty ? a : this.moveToLine(this.domAtPos(l.head));
    if (R.gecko && l.empty && !this.hasComposition && sv(a)) {
      let u = document.createTextNode("");
      this.view.observer.ignore(() => a.node.insertBefore(u, a.node.childNodes[a.offset] || null)), a = h = new ze(u, 0), o = !0;
    }
    let c = this.view.observer.selectionRange;
    (o || !c.focusNode || (!qn(a.node, a.offset, c.anchorNode, c.anchorOffset) || !qn(h.node, h.offset, c.focusNode, c.focusOffset)) && !this.suppressWidgetCursorChange(c, l)) && (this.view.observer.ignore(() => {
      R.android && R.chrome && this.dom.contains(c.focusNode) && cv(c.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let u = Zo(this.view.root);
      if (u)
        if (l.empty) {
          if (R.gecko) {
            let d = lv(a.node, a.offset);
            if (d && d != 3) {
              let p = um(a.node, a.offset, d == 1 ? 1 : -1);
              p && (a = new ze(p.node, p.offset));
            }
          }
          u.collapse(a.node, a.offset), l.bidiLevel != null && u.caretBidiLevel !== void 0 && (u.caretBidiLevel = l.bidiLevel);
        } else if (u.extend) {
          u.collapse(a.node, a.offset);
          try {
            u.extend(h.node, h.offset);
          } catch {
          }
        } else {
          let d = document.createRange();
          l.anchor > l.head && ([a, h] = [h, a]), d.setEnd(h.node, h.offset), d.setStart(a.node, a.offset), u.removeAllRanges(), u.addRange(d);
        }
      s && this.view.root.activeElement == this.dom && (this.dom.blur(), i && i.focus());
    }), this.view.observer.setSelectionRange(a, h)), this.impreciseAnchor = a.precise ? null : new ze(c.anchorNode, c.anchorOffset), this.impreciseHead = h.precise ? null : new ze(c.focusNode, c.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(e, t) {
    return this.hasComposition && t.empty && qn(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) && this.posFromDOM(e.focusNode, e.focusOffset) == t.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: e } = this, t = e.state.selection.main, i = Zo(e.root), { anchorNode: n, anchorOffset: s } = e.observer.selectionRange;
    if (!i || !t.empty || !t.assoc || !i.modify)
      return;
    let o = Se.find(this, t.head);
    if (!o)
      return;
    let l = o.posAtStart;
    if (t.head == l || t.head == l + o.length)
      return;
    let a = this.coordsAt(t.head, -1), h = this.coordsAt(t.head, 1);
    if (!a || !h || a.bottom > h.top)
      return;
    let c = this.domAtPos(t.head + t.assoc);
    i.collapse(c.node, c.offset), i.modify("move", t.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let u = e.observer.selectionRange;
    e.docView.posFromDOM(u.anchorNode, u.anchorOffset) != t.from && i.collapse(n, s);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(e) {
    let t = this.dom, i;
    if (e.node != t)
      return e;
    for (let n = e.offset; !i && n < t.childNodes.length; n++) {
      let s = he.get(t.childNodes[n]);
      s instanceof Se && (i = s.domAtPos(0));
    }
    for (let n = e.offset - 1; !i && n >= 0; n--) {
      let s = he.get(t.childNodes[n]);
      s instanceof Se && (i = s.domAtPos(s.length));
    }
    return i ? new ze(i.node, i.offset, !0) : e;
  }
  nearest(e) {
    for (let t = e; t; ) {
      let i = he.get(t);
      if (i && i.rootView == this)
        return i;
      t = t.parentNode;
    }
    return null;
  }
  posFromDOM(e, t) {
    let i = this.nearest(e);
    if (!i)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return i.localPosFromDOM(e, t) + i.posAtStart;
  }
  domAtPos(e) {
    let { i: t, off: i } = this.childCursor().findPos(e, -1);
    for (; t < this.children.length - 1; ) {
      let n = this.children[t];
      if (i < n.length || n instanceof Se)
        break;
      t++, i = 0;
    }
    return this.children[t].domAtPos(i);
  }
  coordsAt(e, t) {
    let i = null, n = 0;
    for (let s = this.length, o = this.children.length - 1; o >= 0; o--) {
      let l = this.children[o], a = s - l.breakAfter, h = a - l.length;
      if (a < e)
        break;
      h <= e && (h < e || l.covers(-1)) && (a > e || l.covers(1)) && (!i || l instanceof Se && !(i instanceof Se && t >= 0)) && (i = l, n = h), s = h;
    }
    return i ? i.coordsAt(e - n, t) : null;
  }
  coordsForChar(e) {
    let { i: t, off: i } = this.childPos(e, 1), n = this.children[t];
    if (!(n instanceof Se))
      return null;
    for (; n.children.length; ) {
      let { i: l, off: a } = n.childPos(i, 1);
      for (; ; l++) {
        if (l == n.children.length)
          return null;
        if ((n = n.children[l]).length)
          break;
      }
      i = a;
    }
    if (!(n instanceof lr))
      return null;
    let s = _e(n.text, i);
    if (s == i)
      return null;
    let o = ui(n.dom, i, s).getClientRects();
    for (let l = 0; l < o.length; l++) {
      let a = o[l];
      if (l == o.length - 1 || a.top < a.bottom && a.left < a.right)
        return a;
    }
    return null;
  }
  measureVisibleLineHeights(e) {
    let t = [], { from: i, to: n } = e, s = this.view.contentDOM.clientWidth, o = s > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, l = -1, a = this.view.textDirection == ce.LTR;
    for (let h = 0, c = 0; c < this.children.length; c++) {
      let u = this.children[c], d = h + u.length;
      if (d > n)
        break;
      if (h >= i) {
        let p = u.dom.getBoundingClientRect();
        if (t.push(p.height), o) {
          let f = u.dom.lastChild, m = f ? Bi(f) : [];
          if (m.length) {
            let g = m[m.length - 1], b = a ? g.right - p.left : p.right - g.left;
            b > l && (l = b, this.minWidth = s, this.minWidthFrom = h, this.minWidthTo = d);
          }
        }
      }
      h = d + u.breakAfter;
    }
    return t;
  }
  textDirectionAt(e) {
    let { i: t } = this.childPos(e, 1);
    return getComputedStyle(this.children[t].dom).direction == "rtl" ? ce.RTL : ce.LTR;
  }
  measureTextSize() {
    for (let s of this.children)
      if (s instanceof Se) {
        let o = s.measureTextSize();
        if (o)
          return o;
      }
    let e = document.createElement("div"), t, i, n;
    return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let s = Bi(e.firstChild)[0];
      t = e.getBoundingClientRect().height, i = s ? s.width / 27 : 7, n = s ? s.height : t, e.remove();
    }), { lineHeight: t, charWidth: i, textHeight: n };
  }
  childCursor(e = this.length) {
    let t = this.children.length;
    return t && (e -= this.children[--t].length), new zO(this.children, e, t);
  }
  computeBlockGapDeco() {
    let e = [], t = this.view.viewState;
    for (let i = 0, n = 0; ; n++) {
      let s = n == t.viewports.length ? null : t.viewports[n], o = s ? s.from - 1 : this.length;
      if (o > i) {
        let l = (t.lineBlockAt(o).bottom - t.lineBlockAt(i).top) / this.view.scaleY;
        e.push(E.replace({
          widget: new cd(l),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(i, o));
      }
      if (!s)
        break;
      i = s.to + 1;
    }
    return E.set(e);
  }
  updateDeco() {
    let e = this.view.state.facet(Fn).map((n, s) => (this.dynamicDecorationMap[s] = typeof n == "function") ? n(this.view) : n), t = !1, i = this.view.state.facet(om).map((n, s) => {
      let o = typeof n == "function";
      return o && (t = !0), o ? n(this.view) : n;
    });
    i.length && (this.dynamicDecorationMap[e.length] = t, e.push(H.join(i)));
    for (let n = e.length; n < e.length + 3; n++)
      this.dynamicDecorationMap[n] = !1;
    return this.decorations = [
      ...e,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ];
  }
  scrollIntoView(e) {
    if (e.isSnapshot) {
      let h = this.view.viewState.lineBlockAt(e.range.head);
      this.view.scrollDOM.scrollTop = h.top - e.yMargin, this.view.scrollDOM.scrollLeft = e.xMargin;
      return;
    }
    let { range: t } = e, i = this.coordsAt(t.head, t.empty ? t.assoc : t.head > t.anchor ? -1 : 1), n;
    if (!i)
      return;
    !t.empty && (n = this.coordsAt(t.anchor, t.anchor > t.head ? -1 : 1)) && (i = {
      left: Math.min(i.left, n.left),
      top: Math.min(i.top, n.top),
      right: Math.max(i.right, n.right),
      bottom: Math.max(i.bottom, n.bottom)
    });
    let s = hm(this.view), o = {
      left: i.left - s.left,
      top: i.top - s.top,
      right: i.right + s.right,
      bottom: i.bottom + s.bottom
    }, { offsetWidth: l, offsetHeight: a } = this.view.scrollDOM;
    Wy(this.view.scrollDOM, o, t.head < t.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, l), -l), Math.max(Math.min(e.yMargin, a), -a), this.view.textDirection == ce.LTR);
  }
}
function sv(r) {
  return r.node.nodeType == 1 && r.node.firstChild && (r.offset == 0 || r.node.childNodes[r.offset - 1].contentEditable == "false") && (r.offset == r.node.childNodes.length || r.node.childNodes[r.offset].contentEditable == "false");
}
class cd extends Kt {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return e.className = "cm-gap", this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
}
function cm(r, e) {
  let t = r.observer.selectionRange, i = t.focusNode && um(t.focusNode, t.focusOffset, 0);
  if (!i)
    return null;
  let n = e - i.offset;
  return { from: n, to: n + i.node.nodeValue.length, node: i.node };
}
function ov(r, e, t) {
  let i = cm(r, t);
  if (!i)
    return null;
  let { node: n, from: s, to: o } = i, l = n.nodeValue;
  if (/[\n\r]/.test(l) || r.state.doc.sliceString(i.from, i.to) != l)
    return null;
  let a = e.invertedDesc, h = new bt(a.mapPos(s), a.mapPos(o), s, o), c = [];
  for (let u = n.parentNode; ; u = u.parentNode) {
    let d = he.get(u);
    if (d instanceof ar)
      c.push({ node: u, deco: d.mark });
    else {
      if (d instanceof Se || u.nodeName == "DIV" && u.parentNode == r.contentDOM)
        return { range: h, text: n, marks: c, line: u };
      if (u != r.contentDOM)
        c.push({ node: u, deco: new vs({
          inclusive: !0,
          attributes: Uy(u),
          tagName: u.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function um(r, e, t) {
  if (t <= 0)
    for (let i = r, n = e; ; ) {
      if (i.nodeType == 3)
        return { node: i, offset: n };
      if (i.nodeType == 1 && n > 0)
        i = i.childNodes[n - 1], n = or(i);
      else
        break;
    }
  if (t >= 0)
    for (let i = r, n = e; ; ) {
      if (i.nodeType == 3)
        return { node: i, offset: n };
      if (i.nodeType == 1 && n < i.childNodes.length && t >= 0)
        i = i.childNodes[n], n = 0;
      else
        break;
    }
  return null;
}
function lv(r, e) {
  return r.nodeType != 1 ? 0 : (e && r.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < r.childNodes.length && r.childNodes[e].contentEditable == "false" ? 2 : 0);
}
let av = class {
  constructor() {
    this.changes = [];
  }
  compareRange(e, t) {
    lh(e, t, this.changes);
  }
  comparePoint(e, t) {
    lh(e, t, this.changes);
  }
};
function hv(r, e, t) {
  let i = new av();
  return H.compare(r, e, t, i), i.changes;
}
function cv(r, e) {
  for (let t = r; t && t != e; t = t.assignedSlot || t.parentNode)
    if (t.nodeType == 1 && t.contentEditable == "false")
      return !0;
  return !1;
}
function uv(r, e) {
  let t = !1;
  return e && r.iterChangedRanges((i, n) => {
    i < e.to && n > e.from && (t = !0);
  }), t;
}
function dv(r, e, t = 1) {
  let i = r.charCategorizer(e), n = r.doc.lineAt(e), s = e - n.from;
  if (n.length == 0)
    return S.cursor(e);
  s == 0 ? t = 1 : s == n.length && (t = -1);
  let o = s, l = s;
  t < 0 ? o = _e(n.text, s, !1) : l = _e(n.text, s);
  let a = i(n.text.slice(o, l));
  for (; o > 0; ) {
    let h = _e(n.text, o, !1);
    if (i(n.text.slice(h, o)) != a)
      break;
    o = h;
  }
  for (; l < n.length; ) {
    let h = _e(n.text, l);
    if (i(n.text.slice(l, h)) != a)
      break;
    l = h;
  }
  return S.range(o + n.from, l + n.from);
}
function pv(r, e) {
  return e.left > r ? e.left - r : Math.max(0, r - e.right);
}
function fv(r, e) {
  return e.top > r ? e.top - r : Math.max(0, r - e.bottom);
}
function Nl(r, e) {
  return r.top < e.bottom - 1 && r.bottom > e.top + 1;
}
function ud(r, e) {
  return e < r.top ? { top: e, left: r.left, right: r.right, bottom: r.bottom } : r;
}
function dd(r, e) {
  return e > r.bottom ? { top: r.top, left: r.left, right: r.right, bottom: e } : r;
}
function dh(r, e, t) {
  let i, n, s, o, l = !1, a, h, c, u;
  for (let f = r.firstChild; f; f = f.nextSibling) {
    let m = Bi(f);
    for (let g = 0; g < m.length; g++) {
      let b = m[g];
      n && Nl(n, b) && (b = ud(dd(b, n.bottom), n.top));
      let v = pv(e, b), k = fv(t, b);
      if (v == 0 && k == 0)
        return f.nodeType == 3 ? pd(f, e, t) : dh(f, e, t);
      if (!i || o > k || o == k && s > v) {
        i = f, n = b, s = v, o = k;
        let $ = k ? t < b.top ? -1 : 1 : v ? e < b.left ? -1 : 1 : 0;
        l = !$ || ($ > 0 ? g < m.length - 1 : g > 0);
      }
      v == 0 ? t > b.bottom && (!c || c.bottom < b.bottom) ? (a = f, c = b) : t < b.top && (!u || u.top > b.top) && (h = f, u = b) : c && Nl(c, b) ? c = dd(c, b.bottom) : u && Nl(u, b) && (u = ud(u, b.top));
    }
  }
  if (c && c.bottom >= t ? (i = a, n = c) : u && u.top <= t && (i = h, n = u), !i)
    return { node: r, offset: 0 };
  let d = Math.max(n.left, Math.min(n.right, e));
  if (i.nodeType == 3)
    return pd(i, d, t);
  if (l && i.contentEditable != "false")
    return dh(i, d, t);
  let p = Array.prototype.indexOf.call(r.childNodes, i) + (e >= (n.left + n.right) / 2 ? 1 : 0);
  return { node: r, offset: p };
}
function pd(r, e, t) {
  let i = r.nodeValue.length, n = -1, s = 1e9, o = 0;
  for (let l = 0; l < i; l++) {
    let a = ui(r, l, l + 1).getClientRects();
    for (let h = 0; h < a.length; h++) {
      let c = a[h];
      if (c.top == c.bottom)
        continue;
      o || (o = e - c.left);
      let u = (c.top > t ? c.top - t : t - c.bottom) - 1;
      if (c.left - 1 <= e && c.right + 1 >= e && u < s) {
        let d = e >= (c.left + c.right) / 2, p = d;
        if ((R.chrome || R.gecko) && ui(r, l).getBoundingClientRect().left == c.right && (p = !d), u <= 0)
          return { node: r, offset: l + (p ? 1 : 0) };
        n = l + (p ? 1 : 0), s = u;
      }
    }
  }
  return { node: r, offset: n > -1 ? n : o > 0 ? r.nodeValue.length : 0 };
}
function dm(r, e, t, i = -1) {
  var n, s;
  let o = r.contentDOM.getBoundingClientRect(), l = o.top + r.viewState.paddingTop, a, { docHeight: h } = r.viewState, { x: c, y: u } = e, d = u - l;
  if (d < 0)
    return 0;
  if (d > h)
    return r.state.doc.length;
  for (let $ = r.viewState.heightOracle.textHeight / 2, x = !1; a = r.elementAtHeight(d), a.type != Le.Text; )
    for (; d = i > 0 ? a.bottom + $ : a.top - $, !(d >= 0 && d <= h); ) {
      if (x)
        return t ? null : 0;
      x = !0, i = -i;
    }
  u = l + d;
  let p = a.from;
  if (p < r.viewport.from)
    return r.viewport.from == 0 ? 0 : t ? null : fd(r, o, a, c, u);
  if (p > r.viewport.to)
    return r.viewport.to == r.state.doc.length ? r.state.doc.length : t ? null : fd(r, o, a, c, u);
  let f = r.dom.ownerDocument, m = r.root.elementFromPoint ? r.root : f, g = m.elementFromPoint(c, u);
  g && !r.contentDOM.contains(g) && (g = null), g || (c = Math.max(o.left + 1, Math.min(o.right - 1, c)), g = m.elementFromPoint(c, u), g && !r.contentDOM.contains(g) && (g = null));
  let b, v = -1;
  if (g && ((n = r.docView.nearest(g)) === null || n === void 0 ? void 0 : n.isEditable) != !1) {
    if (f.caretPositionFromPoint) {
      let $ = f.caretPositionFromPoint(c, u);
      $ && ({ offsetNode: b, offset: v } = $);
    } else if (f.caretRangeFromPoint) {
      let $ = f.caretRangeFromPoint(c, u);
      $ && ({ startContainer: b, startOffset: v } = $, (!r.contentDOM.contains(b) || R.safari && Ov(b, v, c) || R.chrome && mv(b, v, c)) && (b = void 0));
    }
  }
  if (!b || !r.docView.dom.contains(b)) {
    let $ = Se.find(r.docView, p);
    if (!$)
      return d > a.top + a.height / 2 ? a.to : a.from;
    ({ node: b, offset: v } = dh($.dom, c, u));
  }
  let k = r.docView.nearest(b);
  if (!k)
    return null;
  if (k.isWidget && ((s = k.dom) === null || s === void 0 ? void 0 : s.nodeType) == 1) {
    let $ = k.dom.getBoundingClientRect();
    return e.y < $.top || e.y <= $.bottom && e.x <= ($.left + $.right) / 2 ? k.posAtStart : k.posAtEnd;
  } else
    return k.localPosFromDOM(b, v) + k.posAtStart;
}
function fd(r, e, t, i, n) {
  let s = Math.round((i - e.left) * r.defaultCharacterWidth);
  if (r.lineWrapping && t.height > r.defaultLineHeight * 1.5) {
    let l = r.viewState.heightOracle.textHeight, a = Math.floor((n - t.top - (r.defaultLineHeight - l) * 0.5) / l);
    s += a * r.viewState.heightOracle.lineLength;
  }
  let o = r.state.sliceDoc(t.from, t.to);
  return t.from + Ka(o, s, r.state.tabSize);
}
function Ov(r, e, t) {
  let i;
  if (r.nodeType != 3 || e != (i = r.nodeValue.length))
    return !1;
  for (let n = r.nextSibling; n; n = n.nextSibling)
    if (n.nodeType != 1 || n.nodeName != "BR")
      return !1;
  return ui(r, i - 1, i).getBoundingClientRect().left > t;
}
function mv(r, e, t) {
  if (e != 0)
    return !1;
  for (let n = r; ; ) {
    let s = n.parentNode;
    if (!s || s.nodeType != 1 || s.firstChild != n)
      return !1;
    if (s.classList.contains("cm-line"))
      break;
    n = s;
  }
  let i = r.nodeType == 1 ? r.getBoundingClientRect() : ui(r, 0, Math.max(r.nodeValue.length, 1)).getBoundingClientRect();
  return t - i.left > 5;
}
function ph(r, e) {
  let t = r.lineBlockAt(e);
  if (Array.isArray(t.type)) {
    for (let i of t.type)
      if (i.to > e || i.to == e && (i.to == t.to || i.type == Le.Text))
        return i;
  }
  return t;
}
function gv(r, e, t, i) {
  let n = ph(r, e.head), s = !i || n.type != Le.Text || !(r.lineWrapping || n.widgetLineBreaks) ? null : r.coordsAtPos(e.assoc < 0 && e.head > n.from ? e.head - 1 : e.head);
  if (s) {
    let o = r.dom.getBoundingClientRect(), l = r.textDirectionAt(n.from), a = r.posAtCoords({
      x: t == (l == ce.LTR) ? o.right - 1 : o.left + 1,
      y: (s.top + s.bottom) / 2
    });
    if (a != null)
      return S.cursor(a, t ? -1 : 1);
  }
  return S.cursor(t ? n.to : n.from, t ? -1 : 1);
}
function Od(r, e, t, i) {
  let n = r.state.doc.lineAt(e.head), s = r.bidiSpans(n), o = r.textDirectionAt(n.from);
  for (let l = e, a = null; ; ) {
    let h = rv(n, s, o, l, t), c = FO;
    if (!h) {
      if (n.number == (t ? r.state.doc.lines : 1))
        return l;
      c = `
`, n = r.state.doc.line(n.number + (t ? 1 : -1)), s = r.bidiSpans(n), h = r.visualLineSide(n, !t);
    }
    if (a) {
      if (!a(c))
        return l;
    } else {
      if (!i)
        return h;
      a = i(c);
    }
    l = h;
  }
}
function bv(r, e, t) {
  let i = r.state.charCategorizer(e), n = i(t);
  return (s) => {
    let o = i(s);
    return n == pe.Space && (n = o), n == o;
  };
}
function wv(r, e, t, i) {
  let n = e.head, s = t ? 1 : -1;
  if (n == (t ? r.state.doc.length : 0))
    return S.cursor(n, e.assoc);
  let o = e.goalColumn, l, a = r.contentDOM.getBoundingClientRect(), h = r.coordsAtPos(n, e.assoc || -1), c = r.documentTop;
  if (h)
    o == null && (o = h.left - a.left), l = s < 0 ? h.top : h.bottom;
  else {
    let p = r.viewState.lineBlockAt(n);
    o == null && (o = Math.min(a.right - a.left, r.defaultCharacterWidth * (n - p.from))), l = (s < 0 ? p.top : p.bottom) + c;
  }
  let u = a.left + o, d = i ?? r.viewState.heightOracle.textHeight >> 1;
  for (let p = 0; ; p += 10) {
    let f = l + (d + p) * s, m = dm(r, { x: u, y: f }, !1, s);
    if (f < a.top || f > a.bottom || (s < 0 ? m < n : m > n)) {
      let g = r.docView.coordsForChar(m), b = !g || f < g.top ? -1 : 1;
      return S.cursor(m, b, void 0, o);
    }
  }
}
function po(r, e, t) {
  for (; ; ) {
    let i = 0;
    for (let n of r)
      n.between(e - 1, e + 1, (s, o, l) => {
        if (e > s && e < o) {
          let a = i || t || (e - s < o - e ? -1 : 1);
          e = a < 0 ? s : o, i = a;
        }
      });
    if (!i)
      return e;
  }
}
function Fl(r, e, t) {
  let i = po(r.state.facet(bc).map((n) => n(r)), t.from, e.head > t.from ? -1 : 1);
  return i == t.from ? t : S.cursor(i, i < t.from ? 1 : -1);
}
class yv {
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  constructor(e) {
    this.view = e, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastEscPress = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = e.hasFocus, R.safari && e.contentDOM.addEventListener("input", () => null), R.gecko && qv(e.contentDOM.ownerDocument);
  }
  handleEvent(e) {
    !Tv(this.view, e) || this.ignoreDuringComposition(e) || e.type == "keydown" && this.keydown(e) || this.runHandlers(e.type, e);
  }
  runHandlers(e, t) {
    let i = this.handlers[e];
    if (i) {
      for (let n of i.observers)
        n(this.view, t);
      for (let n of i.handlers) {
        if (t.defaultPrevented)
          break;
        if (n(this.view, t)) {
          t.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(e) {
    let t = vv(e), i = this.handlers, n = this.view.contentDOM;
    for (let s in t)
      if (s != "scroll") {
        let o = !t[s].handlers.length, l = i[s];
        l && o != !l.handlers.length && (n.removeEventListener(s, this.handleEvent), l = null), l || n.addEventListener(s, this.handleEvent, { passive: o });
      }
    for (let s in i)
      s != "scroll" && !t[s] && n.removeEventListener(s, this.handleEvent);
    this.handlers = t;
  }
  keydown(e) {
    if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), e.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
      return !0;
    if (e.keyCode != 27 && fm.indexOf(e.keyCode) < 0 && (this.view.inputState.lastEscPress = 0), R.android && R.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
      return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0;
    let t;
    return R.ios && !e.synthetic && !e.altKey && !e.metaKey && ((t = pm.find((i) => i.keyCode == e.keyCode)) && !e.ctrlKey || xv.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = t || e, setTimeout(() => this.flushIOSKey(), 250), !0) : (e.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey() {
    let e = this.pendingIOSKey;
    return e ? (this.pendingIOSKey = void 0, Zi(this.view.contentDOM, e.key, e.keyCode)) : !1;
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type) ? this.composing > 0 ? !0 : R.safari && !R.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.mouseSelection && this.mouseSelection.update(e), this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function md(r, e) {
  return (t, i) => {
    try {
      return e.call(r, i, t);
    } catch (n) {
      gt(t.state, n);
    }
  };
}
function vv(r) {
  let e = /* @__PURE__ */ Object.create(null);
  function t(i) {
    return e[i] || (e[i] = { observers: [], handlers: [] });
  }
  for (let i of r) {
    let n = i.spec;
    if (n && n.domEventHandlers)
      for (let s in n.domEventHandlers) {
        let o = n.domEventHandlers[s];
        o && t(s).handlers.push(md(i.value, o));
      }
    if (n && n.domEventObservers)
      for (let s in n.domEventObservers) {
        let o = n.domEventObservers[s];
        o && t(s).observers.push(md(i.value, o));
      }
  }
  for (let i in Ct)
    t(i).handlers.push(Ct[i]);
  for (let i in Xt)
    t(i).observers.push(Xt[i]);
  return e;
}
const pm = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], xv = "dthko", fm = [16, 17, 18, 20, 91, 92, 224, 225], zs = 6;
function Ys(r) {
  return Math.max(0, r) * 0.7 + 8;
}
function Sv(r, e) {
  return Math.max(Math.abs(r.clientX - e.clientX), Math.abs(r.clientY - e.clientY));
}
class kv {
  constructor(e, t, i, n) {
    this.view = e, this.startEvent = t, this.style = i, this.mustSelect = n, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = t, this.scrollParent = Vy(e.contentDOM), this.atoms = e.state.facet(bc).map((o) => o(e));
    let s = e.contentDOM.ownerDocument;
    s.addEventListener("mousemove", this.move = this.move.bind(this)), s.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = t.shiftKey, this.multiple = e.state.facet(U.allowMultipleSelections) && $v(e, t), this.dragging = Pv(e, t) && bm(t) == 1 ? null : !1;
  }
  start(e) {
    this.dragging === !1 && this.select(e);
  }
  move(e) {
    var t;
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && Sv(this.startEvent, e) < 10)
      return;
    this.select(this.lastEvent = e);
    let i = 0, n = 0, s = ((t = this.scrollParent) === null || t === void 0 ? void 0 : t.getBoundingClientRect()) || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight }, o = hm(this.view);
    e.clientX - o.left <= s.left + zs ? i = -Ys(s.left - e.clientX) : e.clientX + o.right >= s.right - zs && (i = Ys(e.clientX - s.right)), e.clientY - o.top <= s.top + zs ? n = -Ys(s.top - e.clientY) : e.clientY + o.bottom >= s.bottom - zs && (n = Ys(e.clientY - s.bottom)), this.setScrollSpeed(i, n);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(e, t) {
    this.scrollSpeed = { x: e, y: t }, e || t ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    this.scrollParent ? (this.scrollParent.scrollLeft += this.scrollSpeed.x, this.scrollParent.scrollTop += this.scrollSpeed.y) : this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y), this.dragging === !1 && this.select(this.lastEvent);
  }
  skipAtoms(e) {
    let t = null;
    for (let i = 0; i < e.ranges.length; i++) {
      let n = e.ranges[i], s = null;
      if (n.empty) {
        let o = po(this.atoms, n.from, 0);
        o != n.from && (s = S.cursor(o, -1));
      } else {
        let o = po(this.atoms, n.from, -1), l = po(this.atoms, n.to, 1);
        (o != n.from || l != n.to) && (s = S.range(n.from == n.anchor ? o : l, n.from == n.head ? o : l));
      }
      s && (t || (t = e.ranges.slice()), t[i] = s);
    }
    return t ? S.create(t, e.mainIndex) : e;
  }
  select(e) {
    let { view: t } = this, i = this.skipAtoms(this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !i.eq(t.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: i,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(e) {
    this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function $v(r, e) {
  let t = r.state.facet(HO);
  return t.length ? t[0](e) : R.mac ? e.metaKey : e.ctrlKey;
}
function Qv(r, e) {
  let t = r.state.facet(KO);
  return t.length ? t[0](e) : R.mac ? !e.altKey : !e.ctrlKey;
}
function Pv(r, e) {
  let { main: t } = r.state.selection;
  if (t.empty)
    return !1;
  let i = Zo(r.root);
  if (!i || i.rangeCount == 0)
    return !0;
  let n = i.getRangeAt(0).getClientRects();
  for (let s = 0; s < n.length; s++) {
    let o = n[s];
    if (o.left <= e.clientX && o.right >= e.clientX && o.top <= e.clientY && o.bottom >= e.clientY)
      return !0;
  }
  return !1;
}
function Tv(r, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let t = e.target, i; t != r.contentDOM; t = t.parentNode)
    if (!t || t.nodeType == 11 || (i = he.get(t)) && i.ignoreEvent(e))
      return !1;
  return !0;
}
const Ct = /* @__PURE__ */ Object.create(null), Xt = /* @__PURE__ */ Object.create(null), Om = R.ie && R.ie_version < 15 || R.ios && R.webkit_version < 604;
function Cv(r) {
  let e = r.dom.parentNode;
  if (!e)
    return;
  let t = e.appendChild(document.createElement("textarea"));
  t.style.cssText = "position: fixed; left: -10000px; top: 10px", t.focus(), setTimeout(() => {
    r.focus(), t.remove(), mm(r, t.value);
  }, 50);
}
function mm(r, e) {
  let { state: t } = r, i, n = 1, s = t.toText(e), o = s.lines == t.selection.ranges.length;
  if (fh != null && t.selection.ranges.every((a) => a.empty) && fh == s.toString()) {
    let a = -1;
    i = t.changeByRange((h) => {
      let c = t.doc.lineAt(h.from);
      if (c.from == a)
        return { range: h };
      a = c.from;
      let u = t.toText((o ? s.line(n++).text : e) + t.lineBreak);
      return {
        changes: { from: c.from, insert: u },
        range: S.cursor(h.from + u.length)
      };
    });
  } else
    o ? i = t.changeByRange((a) => {
      let h = s.line(n++);
      return {
        changes: { from: a.from, to: a.to, insert: h.text },
        range: S.cursor(a.from + h.length)
      };
    }) : i = t.replaceSelection(s);
  r.dispatch(i, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
Xt.scroll = (r) => {
  r.inputState.lastScrollTop = r.scrollDOM.scrollTop, r.inputState.lastScrollLeft = r.scrollDOM.scrollLeft;
};
Ct.keydown = (r, e) => (r.inputState.setSelectionOrigin("select"), e.keyCode == 27 && (r.inputState.lastEscPress = Date.now()), !1);
Xt.touchstart = (r, e) => {
  r.inputState.lastTouchTime = Date.now(), r.inputState.setSelectionOrigin("select.pointer");
};
Xt.touchmove = (r) => {
  r.inputState.setSelectionOrigin("select.pointer");
};
Ct.mousedown = (r, e) => {
  if (r.observer.flush(), r.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let t = null;
  for (let i of r.state.facet(JO))
    if (t = i(r, e), t)
      break;
  if (!t && e.button == 0 && (t = _v(r, e)), t) {
    let i = !r.hasFocus;
    r.inputState.startMouseSelection(new kv(r, e, t, i)), i && r.observer.ignore(() => AO(r.contentDOM));
    let n = r.inputState.mouseSelection;
    if (n)
      return n.start(e), n.dragging === !1;
  }
  return !1;
};
function gd(r, e, t, i) {
  if (i == 1)
    return S.cursor(e, t);
  if (i == 2)
    return dv(r.state, e, t);
  {
    let n = Se.find(r.docView, e), s = r.state.doc.lineAt(n ? n.posAtEnd : e), o = n ? n.posAtStart : s.from, l = n ? n.posAtEnd : s.to;
    return l < r.state.doc.length && l == s.to && l++, S.range(o, l);
  }
}
let gm = (r, e) => r >= e.top && r <= e.bottom, bd = (r, e, t) => gm(e, t) && r >= t.left && r <= t.right;
function Xv(r, e, t, i) {
  let n = Se.find(r.docView, e);
  if (!n)
    return 1;
  let s = e - n.posAtStart;
  if (s == 0)
    return 1;
  if (s == n.length)
    return -1;
  let o = n.coordsAt(s, -1);
  if (o && bd(t, i, o))
    return -1;
  let l = n.coordsAt(s, 1);
  return l && bd(t, i, l) ? 1 : o && gm(i, o) ? -1 : 1;
}
function wd(r, e) {
  let t = r.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: t, bias: Xv(r, t, e.clientX, e.clientY) };
}
const Zv = R.ie && R.ie_version <= 11;
let yd = null, vd = 0, xd = 0;
function bm(r) {
  if (!Zv)
    return r.detail;
  let e = yd, t = xd;
  return yd = r, xd = Date.now(), vd = !e || t > Date.now() - 400 && Math.abs(e.clientX - r.clientX) < 2 && Math.abs(e.clientY - r.clientY) < 2 ? (vd + 1) % 3 : 1;
}
function _v(r, e) {
  let t = wd(r, e), i = bm(e), n = r.state.selection;
  return {
    update(s) {
      s.docChanged && (t.pos = s.changes.mapPos(t.pos), n = n.map(s.changes));
    },
    get(s, o, l) {
      let a = wd(r, s), h, c = gd(r, a.pos, a.bias, i);
      if (t.pos != a.pos && !o) {
        let u = gd(r, t.pos, t.bias, i), d = Math.min(u.from, c.from), p = Math.max(u.to, c.to);
        c = d < c.from ? S.range(d, p) : S.range(p, d);
      }
      return o ? n.replaceRange(n.main.extend(c.from, c.to)) : l && i == 1 && n.ranges.length > 1 && (h = Rv(n, a.pos)) ? h : l ? n.addRange(c) : S.create([c]);
    }
  };
}
function Rv(r, e) {
  for (let t = 0; t < r.ranges.length; t++) {
    let { from: i, to: n } = r.ranges[t];
    if (i <= e && n >= e)
      return S.create(r.ranges.slice(0, t).concat(r.ranges.slice(t + 1)), r.mainIndex == t ? 0 : r.mainIndex - (r.mainIndex > t ? 1 : 0));
  }
  return null;
}
Ct.dragstart = (r, e) => {
  let { selection: { main: t } } = r.state;
  if (e.target.draggable) {
    let n = r.docView.nearest(e.target);
    if (n && n.isWidget) {
      let s = n.posAtStart, o = s + n.length;
      (s >= t.to || o <= t.from) && (t = S.range(s, o));
    }
  }
  let { inputState: i } = r;
  return i.mouseSelection && (i.mouseSelection.dragging = !0), i.draggedContent = t, e.dataTransfer && (e.dataTransfer.setData("Text", r.state.sliceDoc(t.from, t.to)), e.dataTransfer.effectAllowed = "copyMove"), !1;
};
Ct.dragend = (r) => (r.inputState.draggedContent = null, !1);
function Sd(r, e, t, i) {
  if (!t)
    return;
  let n = r.posAtCoords({ x: e.clientX, y: e.clientY }, !1), { draggedContent: s } = r.inputState, o = i && s && Qv(r, e) ? { from: s.from, to: s.to } : null, l = { from: n, insert: t }, a = r.state.changes(o ? [o, l] : l);
  r.focus(), r.dispatch({
    changes: a,
    selection: { anchor: a.mapPos(n, -1), head: a.mapPos(n, 1) },
    userEvent: o ? "move.drop" : "input.drop"
  }), r.inputState.draggedContent = null;
}
Ct.drop = (r, e) => {
  if (!e.dataTransfer)
    return !1;
  if (r.state.readOnly)
    return !0;
  let t = e.dataTransfer.files;
  if (t && t.length) {
    let i = Array(t.length), n = 0, s = () => {
      ++n == t.length && Sd(r, e, i.filter((o) => o != null).join(r.state.lineBreak), !1);
    };
    for (let o = 0; o < t.length; o++) {
      let l = new FileReader();
      l.onerror = s, l.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(l.result) || (i[o] = l.result), s();
      }, l.readAsText(t[o]);
    }
    return !0;
  } else {
    let i = e.dataTransfer.getData("Text");
    if (i)
      return Sd(r, e, i, !0), !0;
  }
  return !1;
};
Ct.paste = (r, e) => {
  if (r.state.readOnly)
    return !0;
  r.observer.flush();
  let t = Om ? null : e.clipboardData;
  return t ? (mm(r, t.getData("text/plain") || t.getData("text/uri-text")), !0) : (Cv(r), !1);
};
function Av(r, e) {
  let t = r.dom.parentNode;
  if (!t)
    return;
  let i = t.appendChild(document.createElement("textarea"));
  i.style.cssText = "position: fixed; left: -10000px; top: 10px", i.value = e, i.focus(), i.selectionEnd = e.length, i.selectionStart = 0, setTimeout(() => {
    i.remove(), r.focus();
  }, 50);
}
function Ev(r) {
  let e = [], t = [], i = !1;
  for (let n of r.selection.ranges)
    n.empty || (e.push(r.sliceDoc(n.from, n.to)), t.push(n));
  if (!e.length) {
    let n = -1;
    for (let { from: s } of r.selection.ranges) {
      let o = r.doc.lineAt(s);
      o.number > n && (e.push(o.text), t.push({ from: o.from, to: Math.min(r.doc.length, o.to + 1) })), n = o.number;
    }
    i = !0;
  }
  return { text: e.join(r.lineBreak), ranges: t, linewise: i };
}
let fh = null;
Ct.copy = Ct.cut = (r, e) => {
  let { text: t, ranges: i, linewise: n } = Ev(r.state);
  if (!t && !n)
    return !1;
  fh = n ? t : null, e.type == "cut" && !r.state.readOnly && r.dispatch({
    changes: i,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let s = Om ? null : e.clipboardData;
  return s ? (s.clearData(), s.setData("text/plain", t), !0) : (Av(r, t), !1);
};
const wm = /* @__PURE__ */ pr.define();
function ym(r, e) {
  let t = [];
  for (let i of r.facet(rm)) {
    let n = i(r, e);
    n && t.push(n);
  }
  return t ? r.update({ effects: t, annotations: wm.of(!0) }) : null;
}
function vm(r) {
  setTimeout(() => {
    let e = r.hasFocus;
    if (e != r.inputState.notifiedFocused) {
      let t = ym(r.state, e);
      t ? r.dispatch(t) : r.update([]);
    }
  }, 10);
}
Xt.focus = (r) => {
  r.inputState.lastFocusTime = Date.now(), !r.scrollDOM.scrollTop && (r.inputState.lastScrollTop || r.inputState.lastScrollLeft) && (r.scrollDOM.scrollTop = r.inputState.lastScrollTop, r.scrollDOM.scrollLeft = r.inputState.lastScrollLeft), vm(r);
};
Xt.blur = (r) => {
  r.observer.clearSelectionRange(), vm(r);
};
Xt.compositionstart = Xt.compositionupdate = (r) => {
  r.inputState.compositionFirstChange == null && (r.inputState.compositionFirstChange = !0), r.inputState.composing < 0 && (r.inputState.composing = 0);
};
Xt.compositionend = (r) => {
  r.inputState.composing = -1, r.inputState.compositionEndedAt = Date.now(), r.inputState.compositionPendingKey = !0, r.inputState.compositionPendingChange = r.observer.pendingRecords().length > 0, r.inputState.compositionFirstChange = null, R.chrome && R.android ? r.observer.flushSoon() : r.inputState.compositionPendingChange ? Promise.resolve().then(() => r.observer.flush()) : setTimeout(() => {
    r.inputState.composing < 0 && r.docView.hasComposition && r.update([]);
  }, 50);
};
Xt.contextmenu = (r) => {
  r.inputState.lastContextMenu = Date.now();
};
Ct.beforeinput = (r, e) => {
  var t;
  let i;
  if (R.chrome && R.android && (i = pm.find((n) => n.inputType == e.inputType)) && (r.observer.delayAndroidKey(i.key, i.keyCode), i.key == "Backspace" || i.key == "Delete")) {
    let n = ((t = window.visualViewport) === null || t === void 0 ? void 0 : t.height) || 0;
    setTimeout(() => {
      var s;
      (((s = window.visualViewport) === null || s === void 0 ? void 0 : s.height) || 0) > n + 10 && r.hasFocus && (r.contentDOM.blur(), r.focus());
    }, 100);
  }
  return !1;
};
const kd = /* @__PURE__ */ new Set();
function qv(r) {
  kd.has(r) || (kd.add(r), r.addEventListener("copy", () => {
  }), r.addEventListener("cut", () => {
  }));
}
const $d = ["pre-wrap", "normal", "pre-line", "break-spaces"];
class zv {
  constructor(e) {
    this.lineWrapping = e, this.doc = K.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30, this.heightChanged = !1;
  }
  heightForGap(e, t) {
    let i = this.doc.lineAt(t).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (i += Math.max(0, Math.ceil((t - e - i * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * i;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return $d.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let t = !1;
    for (let i = 0; i < e.length; i++) {
      let n = e[i];
      n < 0 ? i++ : this.heightSamples[Math.floor(n * 10)] || (t = !0, this.heightSamples[Math.floor(n * 10)] = !0);
    }
    return t;
  }
  refresh(e, t, i, n, s, o) {
    let l = $d.indexOf(e) > -1, a = Math.round(t) != Math.round(this.lineHeight) || this.lineWrapping != l;
    if (this.lineWrapping = l, this.lineHeight = t, this.charWidth = i, this.textHeight = n, this.lineLength = s, a) {
      this.heightSamples = {};
      for (let h = 0; h < o.length; h++) {
        let c = o[h];
        c < 0 ? h++ : this.heightSamples[Math.floor(c * 10)] = !0;
      }
    }
    return a;
  }
}
class Yv {
  constructor(e, t) {
    this.from = e, this.heights = t, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class jt {
  /**
  @internal
  */
  constructor(e, t, i, n, s) {
    this.from = e, this.length = t, this.top = i, this.height = n, this._content = s;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? Le.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof zr ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(e) {
    let t = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new jt(this.from, this.length + e.length, this.top, this.height + e.height, t);
  }
}
var ae = /* @__PURE__ */ function(r) {
  return r[r.ByPos = 0] = "ByPos", r[r.ByHeight = 1] = "ByHeight", r[r.ByPosNoHeight = 2] = "ByPosNoHeight", r;
}(ae || (ae = {}));
const fo = 1e-3;
class Be {
  constructor(e, t, i = 2) {
    this.length = e, this.height = t, this.flags = i;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e, t) {
    this.height != t && (Math.abs(this.height - t) > fo && (e.heightChanged = !0), this.height = t);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e, t, i) {
    return Be.of(i);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e, t) {
    t.push(this);
  }
  decomposeRight(e, t) {
    t.push(this);
  }
  applyChanges(e, t, i, n) {
    let s = this, o = i.doc;
    for (let l = n.length - 1; l >= 0; l--) {
      let { fromA: a, toA: h, fromB: c, toB: u } = n[l], d = s.lineAt(a, ae.ByPosNoHeight, i.setDoc(t), 0, 0), p = d.to >= h ? d : s.lineAt(h, ae.ByPosNoHeight, i, 0, 0);
      for (u += p.to - h, h = p.to; l > 0 && d.from <= n[l - 1].toA; )
        a = n[l - 1].fromA, c = n[l - 1].fromB, l--, a < d.from && (d = s.lineAt(a, ae.ByPosNoHeight, i, 0, 0));
      c += d.from - a, a = d.from;
      let f = wc.build(i.setDoc(o), e, c, u);
      s = s.replace(a, h, f);
    }
    return s.updateHeight(i, 0);
  }
  static empty() {
    return new et(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e) {
    if (e.length == 1)
      return e[0];
    let t = 0, i = e.length, n = 0, s = 0;
    for (; ; )
      if (t == i)
        if (n > s * 2) {
          let l = e[t - 1];
          l.break ? e.splice(--t, 1, l.left, null, l.right) : e.splice(--t, 1, l.left, l.right), i += 1 + l.break, n -= l.size;
        } else if (s > n * 2) {
          let l = e[i];
          l.break ? e.splice(i, 1, l.left, null, l.right) : e.splice(i, 1, l.left, l.right), i += 2 + l.break, s -= l.size;
        } else
          break;
      else if (n < s) {
        let l = e[t++];
        l && (n += l.size);
      } else {
        let l = e[--i];
        l && (s += l.size);
      }
    let o = 0;
    return e[t - 1] == null ? (o = 1, t--) : e[t] == null && (o = 1, i++), new Wv(Be.of(e.slice(0, t)), o, Be.of(e.slice(i)));
  }
}
Be.prototype.size = 1;
class xm extends Be {
  constructor(e, t, i) {
    super(e, t), this.deco = i;
  }
  blockAt(e, t, i, n) {
    return new jt(n, this.length, i, this.height, this.deco || 0);
  }
  lineAt(e, t, i, n, s) {
    return this.blockAt(0, i, n, s);
  }
  forEachLine(e, t, i, n, s, o) {
    e <= s + this.length && t >= s && o(this.blockAt(0, i, n, s));
  }
  updateHeight(e, t = 0, i = !1, n) {
    return n && n.from <= t && n.more && this.setHeight(e, n.heights[n.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class et extends xm {
  constructor(e, t) {
    super(e, t, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(e, t, i, n) {
    return new jt(n, this.length, i, this.height, this.breaks);
  }
  replace(e, t, i) {
    let n = i[0];
    return i.length == 1 && (n instanceof et || n instanceof Pe && n.flags & 4) && Math.abs(this.length - n.length) < 10 ? (n instanceof Pe ? n = new et(n.length, this.height) : n.height = this.height, this.outdated || (n.outdated = !1), n) : Be.of(i);
  }
  updateHeight(e, t = 0, i = !1, n) {
    return n && n.from <= t && n.more ? this.setHeight(e, n.heights[n.index++]) : (i || this.outdated) && this.setHeight(e, Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class Pe extends Be {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, t) {
    let i = e.doc.lineAt(t).number, n = e.doc.lineAt(t + this.length).number, s = n - i + 1, o, l = 0;
    if (e.lineWrapping) {
      let a = Math.min(this.height, e.lineHeight * s);
      o = a / s, this.length > s + 1 && (l = (this.height - a) / (this.length - s - 1));
    } else
      o = this.height / s;
    return { firstLine: i, lastLine: n, perLine: o, perChar: l };
  }
  blockAt(e, t, i, n) {
    let { firstLine: s, lastLine: o, perLine: l, perChar: a } = this.heightMetrics(t, n);
    if (t.lineWrapping) {
      let h = n + Math.round(Math.max(0, Math.min(1, (e - i) / this.height)) * this.length), c = t.doc.lineAt(h), u = l + c.length * a, d = Math.max(i, e - u / 2);
      return new jt(c.from, c.length, d, u, 0);
    } else {
      let h = Math.max(0, Math.min(o - s, Math.floor((e - i) / l))), { from: c, length: u } = t.doc.line(s + h);
      return new jt(c, u, i + l * h, l, 0);
    }
  }
  lineAt(e, t, i, n, s) {
    if (t == ae.ByHeight)
      return this.blockAt(e, i, n, s);
    if (t == ae.ByPosNoHeight) {
      let { from: p, to: f } = i.doc.lineAt(e);
      return new jt(p, f - p, 0, 0, 0);
    }
    let { firstLine: o, perLine: l, perChar: a } = this.heightMetrics(i, s), h = i.doc.lineAt(e), c = l + h.length * a, u = h.number - o, d = n + l * u + a * (h.from - s - u);
    return new jt(h.from, h.length, Math.max(n, Math.min(d, n + this.height - c)), c, 0);
  }
  forEachLine(e, t, i, n, s, o) {
    e = Math.max(e, s), t = Math.min(t, s + this.length);
    let { firstLine: l, perLine: a, perChar: h } = this.heightMetrics(i, s);
    for (let c = e, u = n; c <= t; ) {
      let d = i.doc.lineAt(c);
      if (c == e) {
        let f = d.number - l;
        u += a * f + h * (e - s - f);
      }
      let p = a + h * d.length;
      o(new jt(d.from, d.length, u, p, 0)), u += p, c = d.to + 1;
    }
  }
  replace(e, t, i) {
    let n = this.length - t;
    if (n > 0) {
      let s = i[i.length - 1];
      s instanceof Pe ? i[i.length - 1] = new Pe(s.length + n) : i.push(null, new Pe(n - 1));
    }
    if (e > 0) {
      let s = i[0];
      s instanceof Pe ? i[0] = new Pe(e + s.length) : i.unshift(new Pe(e - 1), null);
    }
    return Be.of(i);
  }
  decomposeLeft(e, t) {
    t.push(new Pe(e - 1), null);
  }
  decomposeRight(e, t) {
    t.push(null, new Pe(this.length - e - 1));
  }
  updateHeight(e, t = 0, i = !1, n) {
    let s = t + this.length;
    if (n && n.from <= t + this.length && n.more) {
      let o = [], l = Math.max(t, n.from), a = -1;
      for (n.from > t && o.push(new Pe(n.from - t - 1).updateHeight(e, t)); l <= s && n.more; ) {
        let c = e.doc.lineAt(l).length;
        o.length && o.push(null);
        let u = n.heights[n.index++];
        a == -1 ? a = u : Math.abs(u - a) >= fo && (a = -2);
        let d = new et(c, u);
        d.outdated = !1, o.push(d), l += c + 1;
      }
      l <= s && o.push(null, new Pe(s - l).updateHeight(e, l));
      let h = Be.of(o);
      return (a < 0 || Math.abs(h.height - this.height) >= fo || Math.abs(a - this.heightMetrics(e, t).perLine) >= fo) && (e.heightChanged = !0), h;
    } else
      (i || this.outdated) && (this.setHeight(e, e.heightForGap(t, t + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class Wv extends Be {
  constructor(e, t, i) {
    super(e.length + t + i.length, e.height + i.height, t | (e.outdated || i.outdated ? 2 : 0)), this.left = e, this.right = i, this.size = e.size + i.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, t, i, n) {
    let s = i + this.left.height;
    return e < s ? this.left.blockAt(e, t, i, n) : this.right.blockAt(e, t, s, n + this.left.length + this.break);
  }
  lineAt(e, t, i, n, s) {
    let o = n + this.left.height, l = s + this.left.length + this.break, a = t == ae.ByHeight ? e < o : e < l, h = a ? this.left.lineAt(e, t, i, n, s) : this.right.lineAt(e, t, i, o, l);
    if (this.break || (a ? h.to < l : h.from > l))
      return h;
    let c = t == ae.ByPosNoHeight ? ae.ByPosNoHeight : ae.ByPos;
    return a ? h.join(this.right.lineAt(l, c, i, o, l)) : this.left.lineAt(l, c, i, n, s).join(h);
  }
  forEachLine(e, t, i, n, s, o) {
    let l = n + this.left.height, a = s + this.left.length + this.break;
    if (this.break)
      e < a && this.left.forEachLine(e, t, i, n, s, o), t >= a && this.right.forEachLine(e, t, i, l, a, o);
    else {
      let h = this.lineAt(a, ae.ByPos, i, n, s);
      e < h.from && this.left.forEachLine(e, h.from - 1, i, n, s, o), h.to >= e && h.from <= t && o(h), t > h.to && this.right.forEachLine(h.to + 1, t, i, l, a, o);
    }
  }
  replace(e, t, i) {
    let n = this.left.length + this.break;
    if (t < n)
      return this.balanced(this.left.replace(e, t, i), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - n, t - n, i));
    let s = [];
    e > 0 && this.decomposeLeft(e, s);
    let o = s.length;
    for (let l of i)
      s.push(l);
    if (e > 0 && Qd(s, o - 1), t < this.length) {
      let l = s.length;
      this.decomposeRight(t, s), Qd(s, l);
    }
    return Be.of(s);
  }
  decomposeLeft(e, t) {
    let i = this.left.length;
    if (e <= i)
      return this.left.decomposeLeft(e, t);
    t.push(this.left), this.break && (i++, e >= i && t.push(null)), e > i && this.right.decomposeLeft(e - i, t);
  }
  decomposeRight(e, t) {
    let i = this.left.length, n = i + this.break;
    if (e >= n)
      return this.right.decomposeRight(e - n, t);
    e < i && this.left.decomposeRight(e, t), this.break && e < n && t.push(null), t.push(this.right);
  }
  balanced(e, t) {
    return e.size > 2 * t.size || t.size > 2 * e.size ? Be.of(this.break ? [e, null, t] : [e, t]) : (this.left = e, this.right = t, this.height = e.height + t.height, this.outdated = e.outdated || t.outdated, this.size = e.size + t.size, this.length = e.length + this.break + t.length, this);
  }
  updateHeight(e, t = 0, i = !1, n) {
    let { left: s, right: o } = this, l = t + s.length + this.break, a = null;
    return n && n.from <= t + s.length && n.more ? a = s = s.updateHeight(e, t, i, n) : s.updateHeight(e, t, i), n && n.from <= l + o.length && n.more ? a = o = o.updateHeight(e, l, i, n) : o.updateHeight(e, l, i), a ? this.balanced(s, o) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function Qd(r, e) {
  let t, i;
  r[e] == null && (t = r[e - 1]) instanceof Pe && (i = r[e + 1]) instanceof Pe && r.splice(e - 1, 3, new Pe(t.length + 1 + i.length));
}
const Vv = 5;
class wc {
  constructor(e, t) {
    this.pos = e, this.oracle = t, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, t) {
    if (this.lineStart > -1) {
      let i = Math.min(t, this.lineEnd), n = this.nodes[this.nodes.length - 1];
      n instanceof et ? n.length += i - this.pos : (i > this.pos || !this.isCovered) && this.nodes.push(new et(i - this.pos, -1)), this.writtenTo = i, t > i && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = t;
  }
  point(e, t, i) {
    if (e < t || i.heightRelevant) {
      let n = i.widget ? i.widget.estimatedHeight : 0, s = i.widget ? i.widget.lineBreaks : 0;
      n < 0 && (n = this.oracle.lineHeight);
      let o = t - e;
      i.block ? this.addBlock(new xm(o, n, i)) : (o || s || n >= Vv) && this.addLineDeco(n, s, o);
    } else
      t > e && this.span(e, t);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: t } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = t, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new et(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, t) {
    let i = new Pe(t - e);
    return this.oracle.doc.lineAt(e).to == t && (i.flags |= 4), i;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof et)
      return e;
    let t = new et(0, -1);
    return this.nodes.push(t), t;
  }
  addBlock(e) {
    this.enterLine();
    let t = e.deco;
    t && t.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, t && t.endSide > 0 && (this.covering = e);
  }
  addLineDeco(e, t, i) {
    let n = this.ensureLine();
    n.length += i, n.collapsed += i, n.widgetHeight = Math.max(n.widgetHeight, e), n.breaks += t, this.writtenTo = this.pos = this.pos + i;
  }
  finish(e) {
    let t = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(t instanceof et) && !this.isCovered ? this.nodes.push(new et(0, -1)) : (this.writtenTo < this.pos || t == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let i = e;
    for (let n of this.nodes)
      n instanceof et && n.updateHeight(this.oracle, i), i += n ? n.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e, t, i, n) {
    let s = new wc(i, e);
    return H.spans(t, i, n, s, 0), s.finish(i);
  }
}
function Mv(r, e, t) {
  let i = new jv();
  return H.compare(r, e, t, i, 0), i.changes;
}
class jv {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, t, i, n) {
    (e < t || i && i.heightRelevant || n && n.heightRelevant) && lh(e, t, this.changes, 5);
  }
}
function Lv(r, e) {
  let t = r.getBoundingClientRect(), i = r.ownerDocument, n = i.defaultView || window, s = Math.max(0, t.left), o = Math.min(n.innerWidth, t.right), l = Math.max(0, t.top), a = Math.min(n.innerHeight, t.bottom);
  for (let h = r.parentNode; h && h != i.body; )
    if (h.nodeType == 1) {
      let c = h, u = window.getComputedStyle(c);
      if ((c.scrollHeight > c.clientHeight || c.scrollWidth > c.clientWidth) && u.overflow != "visible") {
        let d = c.getBoundingClientRect();
        s = Math.max(s, d.left), o = Math.min(o, d.right), l = Math.max(l, d.top), a = h == r.parentNode ? d.bottom : Math.min(a, d.bottom);
      }
      h = u.position == "absolute" || u.position == "fixed" ? c.offsetParent : c.parentNode;
    } else if (h.nodeType == 11)
      h = h.host;
    else
      break;
  return {
    left: s - t.left,
    right: Math.max(s, o) - t.left,
    top: l - (t.top + e),
    bottom: Math.max(l, a) - (t.top + e)
  };
}
function Bv(r, e) {
  let t = r.getBoundingClientRect();
  return {
    left: 0,
    right: t.right - t.left,
    top: e,
    bottom: t.bottom - (t.top + e)
  };
}
class Hl {
  constructor(e, t, i) {
    this.from = e, this.to = t, this.size = i;
  }
  static same(e, t) {
    if (e.length != t.length)
      return !1;
    for (let i = 0; i < e.length; i++) {
      let n = e[i], s = t[i];
      if (n.from != s.from || n.to != s.to || n.size != s.size)
        return !1;
    }
    return !0;
  }
  draw(e, t) {
    return E.replace({
      widget: new Dv(this.size * (t ? e.scaleY : e.scaleX), t)
    }).range(this.from, this.to);
  }
}
class Dv extends Kt {
  constructor(e, t) {
    super(), this.size = e, this.vertical = t;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class Pd {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !0, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = Td, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = ce.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let t = e.facet(gc).some((i) => typeof i != "function" && i.class == "cm-lineWrapping");
    this.heightOracle = new zv(t), this.stateDeco = e.facet(Fn).filter((i) => typeof i != "function"), this.heightMap = Be.empty().applyChanges(this.stateDeco, K.empty, this.heightOracle.setDoc(e.doc), [new bt(0, 0, 0, e.doc.length)]), this.viewport = this.getViewport(0, null), this.updateViewportLines(), this.updateForViewport(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = E.set(this.lineGaps.map((i) => i.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: t } = this.state.selection;
    for (let i = 0; i <= 1; i++) {
      let n = i ? t.head : t.anchor;
      if (!e.some(({ from: s, to: o }) => n >= s && n <= o)) {
        let { from: s, to: o } = this.lineBlockAt(n);
        e.push(new Ws(s, o));
      }
    }
    this.viewports = e.sort((i, n) => i.from - n.from), this.scaler = this.heightMap.height <= 7e6 ? Td : new Gv(this.heightOracle, this.heightMap, this.viewports);
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
      this.viewportLines.push(this.scaler.scale == 1 ? e : Qn(e, this.scaler));
    });
  }
  update(e, t = null) {
    this.state = e.state;
    let i = this.stateDeco;
    this.stateDeco = this.state.facet(Fn).filter((c) => typeof c != "function");
    let n = e.changedRanges, s = bt.extendWithRanges(n, Mv(i, this.stateDeco, e ? e.changes : ke.empty(this.state.doc.length))), o = this.heightMap.height, l = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), s), this.heightMap.height != o && (e.flags |= 2), l ? (this.scrollAnchorPos = e.changes.mapPos(l.from, -1), this.scrollAnchorHeight = l.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height);
    let a = s.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (t && (t.range.head < a.from || t.range.head > a.to) || !this.viewportIsAppropriate(a)) && (a = this.getViewport(0, t));
    let h = !e.changes.empty || e.flags & 2 || a.from != this.viewport.from || a.to != this.viewport.to;
    this.viewport = a, this.updateForViewport(), h && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(), t && (this.scrollTarget = t), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(nm) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let t = e.contentDOM, i = window.getComputedStyle(t), n = this.heightOracle, s = i.whiteSpace;
    this.defaultTextDirection = i.direction == "rtl" ? ce.RTL : ce.LTR;
    let o = this.heightOracle.mustRefreshForWrapping(s), l = t.getBoundingClientRect(), a = o || this.mustMeasureContent || this.contentDOMHeight != l.height;
    this.contentDOMHeight = l.height, this.mustMeasureContent = !1;
    let h = 0, c = 0;
    if (l.width && l.height) {
      let { scaleX: $, scaleY: x } = RO(t, l);
      (this.scaleX != $ || this.scaleY != x) && (this.scaleX = $, this.scaleY = x, h |= 8, o = a = !0);
    }
    let u = (parseInt(i.paddingTop) || 0) * this.scaleY, d = (parseInt(i.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != u || this.paddingBottom != d) && (this.paddingTop = u, this.paddingBottom = d, h |= 10), this.editorWidth != e.scrollDOM.clientWidth && (n.lineWrapping && (a = !0), this.editorWidth = e.scrollDOM.clientWidth, h |= 8);
    let p = e.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != p && (this.scrollAnchorHeight = -1, this.scrollTop = p), this.scrolledToBottom = qO(e.scrollDOM);
    let f = (this.printing ? Bv : Lv)(t, this.paddingTop), m = f.top - this.pixelViewport.top, g = f.bottom - this.pixelViewport.bottom;
    this.pixelViewport = f;
    let b = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (b != this.inView && (this.inView = b, b && (a = !0)), !this.inView && !this.scrollTarget)
      return 0;
    let v = l.width;
    if ((this.contentDOMWidth != v || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = l.width, this.editorHeight = e.scrollDOM.clientHeight, h |= 8), a) {
      let $ = e.docView.measureVisibleLineHeights(this.viewport);
      if (n.mustRefreshForHeights($) && (o = !0), o || n.lineWrapping && Math.abs(v - this.contentDOMWidth) > n.charWidth) {
        let { lineHeight: x, charWidth: Q, textHeight: P } = e.docView.measureTextSize();
        o = x > 0 && n.refresh(s, x, Q, P, v / Q, $), o && (e.docView.minWidth = 0, h |= 8);
      }
      m > 0 && g > 0 ? c = Math.max(m, g) : m < 0 && g < 0 && (c = Math.min(m, g)), n.heightChanged = !1;
      for (let x of this.viewports) {
        let Q = x.from == this.viewport.from ? $ : e.docView.measureVisibleLineHeights(x);
        this.heightMap = (o ? Be.empty().applyChanges(this.stateDeco, K.empty, this.heightOracle, [new bt(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(n, 0, o, new Yv(x.from, Q));
      }
      n.heightChanged && (h |= 2);
    }
    let k = !this.viewportIsAppropriate(this.viewport, c) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return k && (this.viewport = this.getViewport(c, this.scrollTarget)), this.updateForViewport(), (h & 2 || k) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(o ? [] : this.lineGaps, e)), h |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), h;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, t) {
    let i = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), n = this.heightMap, s = this.heightOracle, { visibleTop: o, visibleBottom: l } = this, a = new Ws(n.lineAt(o - i * 1e3, ae.ByHeight, s, 0, 0).from, n.lineAt(l + (1 - i) * 1e3, ae.ByHeight, s, 0, 0).to);
    if (t) {
      let { head: h } = t.range;
      if (h < a.from || h > a.to) {
        let c = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), u = n.lineAt(h, ae.ByPos, s, 0, 0), d;
        t.y == "center" ? d = (u.top + u.bottom) / 2 - c / 2 : t.y == "start" || t.y == "nearest" && h < a.from ? d = u.top : d = u.bottom - c, a = new Ws(n.lineAt(d - 1e3 / 2, ae.ByHeight, s, 0, 0).from, n.lineAt(d + c + 1e3 / 2, ae.ByHeight, s, 0, 0).to);
      }
    }
    return a;
  }
  mapViewport(e, t) {
    let i = t.mapPos(e.from, -1), n = t.mapPos(e.to, 1);
    return new Ws(this.heightMap.lineAt(i, ae.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(n, ae.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e, to: t }, i = 0) {
    if (!this.inView)
      return !0;
    let { top: n } = this.heightMap.lineAt(e, ae.ByPos, this.heightOracle, 0, 0), { bottom: s } = this.heightMap.lineAt(t, ae.ByPos, this.heightOracle, 0, 0), { visibleTop: o, visibleBottom: l } = this;
    return (e == 0 || n <= o - Math.max(10, Math.min(
      -i,
      250
      /* VP.MaxCoverMargin */
    ))) && (t == this.state.doc.length || s >= l + Math.max(10, Math.min(
      i,
      250
      /* VP.MaxCoverMargin */
    ))) && n > o - 2 * 1e3 && s < l + 2 * 1e3;
  }
  mapLineGaps(e, t) {
    if (!e.length || t.empty)
      return e;
    let i = [];
    for (let n of e)
      t.touchesRange(n.from, n.to) || i.push(new Hl(t.mapPos(n.from), t.mapPos(n.to), n.size));
    return i;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e, t) {
    let i = this.heightOracle.lineWrapping, n = i ? 1e4 : 2e3, s = n >> 1, o = n << 1;
    if (this.defaultTextDirection != ce.LTR && !i)
      return [];
    let l = [], a = (h, c, u, d) => {
      if (c - h < s)
        return;
      let p = this.state.selection.main, f = [p.from];
      p.empty || f.push(p.to);
      for (let g of f)
        if (g > h && g < c) {
          a(h, g - 10, u, d), a(g + 10, c, u, d);
          return;
        }
      let m = Uv(e, (g) => g.from >= u.from && g.to <= u.to && Math.abs(g.from - h) < s && Math.abs(g.to - c) < s && !f.some((b) => g.from < b && g.to > b));
      if (!m) {
        if (c < u.to && t && i && t.visibleRanges.some((g) => g.from <= c && g.to >= c)) {
          let g = t.moveToLineBoundary(S.cursor(c), !1, !0).head;
          g > h && (c = g);
        }
        m = new Hl(h, c, this.gapSize(u, h, c, d));
      }
      l.push(m);
    };
    for (let h of this.viewportLines) {
      if (h.length < o)
        continue;
      let c = Iv(h.from, h.to, this.stateDeco);
      if (c.total < o)
        continue;
      let u = this.scrollTarget ? this.scrollTarget.range.head : null, d, p;
      if (i) {
        let f = n / this.heightOracle.lineLength * this.heightOracle.lineHeight, m, g;
        if (u != null) {
          let b = Ms(c, u), v = ((this.visibleBottom - this.visibleTop) / 2 + f) / h.height;
          m = b - v, g = b + v;
        } else
          m = (this.visibleTop - h.top - f) / h.height, g = (this.visibleBottom - h.top + f) / h.height;
        d = Vs(c, m), p = Vs(c, g);
      } else {
        let f = c.total * this.heightOracle.charWidth, m = n * this.heightOracle.charWidth, g, b;
        if (u != null) {
          let v = Ms(c, u), k = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + m) / f;
          g = v - k, b = v + k;
        } else
          g = (this.pixelViewport.left - m) / f, b = (this.pixelViewport.right + m) / f;
        d = Vs(c, g), p = Vs(c, b);
      }
      d > h.from && a(h.from, d, h, c), p < h.to && a(p, h.to, h, c);
    }
    return l;
  }
  gapSize(e, t, i, n) {
    let s = Ms(n, i) - Ms(n, t);
    return this.heightOracle.lineWrapping ? e.height * s : n.total * this.heightOracle.charWidth * s;
  }
  updateLineGaps(e) {
    Hl.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = E.set(e.map((t) => t.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges() {
    let e = this.stateDeco;
    this.lineGaps.length && (e = e.concat(this.lineGapDeco));
    let t = [];
    H.spans(e, this.viewport.from, this.viewport.to, {
      span(n, s) {
        t.push({ from: n, to: s });
      },
      point() {
      }
    }, 20);
    let i = t.length != this.visibleRanges.length || this.visibleRanges.some((n, s) => n.from != t[s].from || n.to != t[s].to);
    return this.visibleRanges = t, i ? 4 : 0;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((t) => t.from <= e && t.to >= e) || Qn(this.heightMap.lineAt(e, ae.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return Qn(this.heightMap.lineAt(this.scaler.fromDOM(e), ae.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(e) {
    let t = this.lineBlockAtHeight(e + 8);
    return t.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? t : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return Qn(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class Ws {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
}
function Iv(r, e, t) {
  let i = [], n = r, s = 0;
  return H.spans(t, r, e, {
    span() {
    },
    point(o, l) {
      o > n && (i.push({ from: n, to: o }), s += o - n), n = l;
    }
  }, 20), n < e && (i.push({ from: n, to: e }), s += e - n), { total: s, ranges: i };
}
function Vs({ total: r, ranges: e }, t) {
  if (t <= 0)
    return e[0].from;
  if (t >= 1)
    return e[e.length - 1].to;
  let i = Math.floor(r * t);
  for (let n = 0; ; n++) {
    let { from: s, to: o } = e[n], l = o - s;
    if (i <= l)
      return s + i;
    i -= l;
  }
}
function Ms(r, e) {
  let t = 0;
  for (let { from: i, to: n } of r.ranges) {
    if (e <= n) {
      t += e - i;
      break;
    }
    t += n - i;
  }
  return t / r.total;
}
function Uv(r, e) {
  for (let t of r)
    if (e(t))
      return t;
}
const Td = {
  toDOM(r) {
    return r;
  },
  fromDOM(r) {
    return r;
  },
  scale: 1
};
class Gv {
  constructor(e, t, i) {
    let n = 0, s = 0, o = 0;
    this.viewports = i.map(({ from: l, to: a }) => {
      let h = t.lineAt(l, ae.ByPos, e, 0, 0).top, c = t.lineAt(a, ae.ByPos, e, 0, 0).bottom;
      return n += c - h, { from: l, to: a, top: h, bottom: c, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - n) / (t.height - n);
    for (let l of this.viewports)
      l.domTop = o + (l.top - s) * this.scale, o = l.domBottom = l.domTop + (l.bottom - l.top), s = l.bottom;
  }
  toDOM(e) {
    for (let t = 0, i = 0, n = 0; ; t++) {
      let s = t < this.viewports.length ? this.viewports[t] : null;
      if (!s || e < s.top)
        return n + (e - i) * this.scale;
      if (e <= s.bottom)
        return s.domTop + (e - s.top);
      i = s.bottom, n = s.domBottom;
    }
  }
  fromDOM(e) {
    for (let t = 0, i = 0, n = 0; ; t++) {
      let s = t < this.viewports.length ? this.viewports[t] : null;
      if (!s || e < s.domTop)
        return i + (e - n) / this.scale;
      if (e <= s.domBottom)
        return s.top + (e - s.domTop);
      i = s.bottom, n = s.domBottom;
    }
  }
}
function Qn(r, e) {
  if (e.scale == 1)
    return r;
  let t = e.toDOM(r.top), i = e.toDOM(r.bottom);
  return new jt(r.from, r.length, t, i - t, Array.isArray(r._content) ? r._content.map((n) => Qn(n, e)) : r._content);
}
const js = /* @__PURE__ */ _.define({ combine: (r) => r.join(" ") }), Oh = /* @__PURE__ */ _.define({ combine: (r) => r.indexOf(!0) > -1 }), mh = /* @__PURE__ */ Er.newName(), Sm = /* @__PURE__ */ Er.newName(), km = /* @__PURE__ */ Er.newName(), $m = { "&light": "." + Sm, "&dark": "." + km };
function gh(r, e, t) {
  return new Er(e, {
    finish(i) {
      return /&/.test(i) ? i.replace(/&\w*/, (n) => {
        if (n == "&")
          return r;
        if (!t || !t[n])
          throw new RangeError(`Unsupported selector: ${n}`);
        return t[n];
      }) : r + " " + i;
    }
  });
}
const Nv = /* @__PURE__ */ gh("." + mh, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-highlightSpace:before": {
    content: "attr(data-display)",
    position: "absolute",
    pointerEvents: "none",
    color: "#888"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, $m), Pn = "￿";
class Fv {
  constructor(e, t) {
    this.points = e, this.text = "", this.lineSeparator = t.facet(U.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += Pn;
  }
  readRange(e, t) {
    if (!e)
      return this;
    let i = e.parentNode;
    for (let n = e; ; ) {
      this.findPointBefore(i, n);
      let s = this.text.length;
      this.readNode(n);
      let o = n.nextSibling;
      if (o == t)
        break;
      let l = he.get(n), a = he.get(o);
      (l && a ? l.breakAfter : (l ? l.breakAfter : Cd(n)) || Cd(o) && (n.nodeName != "BR" || n.cmIgnore) && this.text.length > s) && this.lineBreak(), n = o;
    }
    return this.findPointBefore(i, t), this;
  }
  readTextNode(e) {
    let t = e.nodeValue;
    for (let i of this.points)
      i.node == e && (i.pos = this.text.length + Math.min(i.offset, t.length));
    for (let i = 0, n = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let s = -1, o = 1, l;
      if (this.lineSeparator ? (s = t.indexOf(this.lineSeparator, i), o = this.lineSeparator.length) : (l = n.exec(t)) && (s = l.index, o = l[0].length), this.append(t.slice(i, s < 0 ? t.length : s)), s < 0)
        break;
      if (this.lineBreak(), o > 1)
        for (let a of this.points)
          a.node == e && a.pos > this.text.length && (a.pos -= o - 1);
      i = s + o;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let t = he.get(e), i = t && t.overrideDOMText;
    if (i != null) {
      this.findPointInside(e, i.length);
      for (let n = i.iter(); !n.next().done; )
        n.lineBreak ? this.lineBreak() : this.append(n.value);
    } else
      e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, t) {
    for (let i of this.points)
      i.node == e && e.childNodes[i.offset] == t && (i.pos = this.text.length);
  }
  findPointInside(e, t) {
    for (let i of this.points)
      (e.nodeType == 3 ? i.node == e : e.contains(i.node)) && (i.pos = this.text.length + (Hv(e, i.node, i.offset) ? t : 0));
  }
}
function Hv(r, e, t) {
  for (; ; ) {
    if (!e || t < or(e))
      return !1;
    if (e == r)
      return !0;
    t = Nn(e) + 1, e = e.parentNode;
  }
}
function Cd(r) {
  return r.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(r.nodeName);
}
class Xd {
  constructor(e, t) {
    this.node = e, this.offset = t, this.pos = -1;
  }
}
class Kv {
  constructor(e, t, i, n) {
    this.typeOver = n, this.bounds = null, this.text = "";
    let { impreciseHead: s, impreciseAnchor: o } = e.docView;
    if (e.state.readOnly && t > -1)
      this.newSel = null;
    else if (t > -1 && (this.bounds = e.docView.domBoundsAround(t, i, 0))) {
      let l = s || o ? [] : tx(e), a = new Fv(l, e.state);
      a.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = a.text, this.newSel = rx(l, this.bounds.from);
    } else {
      let l = e.observer.selectionRange, a = s && s.node == l.focusNode && s.offset == l.focusOffset || !th(e.contentDOM, l.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(l.focusNode, l.focusOffset), h = o && o.node == l.anchorNode && o.offset == l.anchorOffset || !th(e.contentDOM, l.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(l.anchorNode, l.anchorOffset), c = e.viewport;
      if (R.ios && e.state.selection.main.empty && a != h && (c.from > 0 || c.to < e.state.doc.length)) {
        let u = c.from - Math.min(a, h), d = c.to - Math.max(a, h);
        (u == 0 || u == 1) && (d == 0 || d == -1) && (a = 0, h = e.state.doc.length);
      }
      this.newSel = S.single(h, a);
    }
  }
}
function Qm(r, e) {
  let t, { newSel: i } = e, n = r.state.selection.main, s = r.inputState.lastKeyTime > Date.now() - 100 ? r.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: o, to: l } = e.bounds, a = n.from, h = null;
    (s === 8 || R.android && e.text.length < l - o) && (a = n.to, h = "end");
    let c = ex(r.state.doc.sliceString(o, l, Pn), e.text, a - o, h);
    c && (R.chrome && s == 13 && c.toB == c.from + 2 && e.text.slice(c.from, c.toB) == Pn + Pn && c.toB--, t = {
      from: o + c.from,
      to: o + c.toA,
      insert: K.of(e.text.slice(c.from, c.toB).split(Pn))
    });
  } else
    i && (!r.hasFocus && r.state.facet(fl) || i.main.eq(n)) && (i = null);
  if (!t && !i)
    return !1;
  if (!t && e.typeOver && !n.empty && i && i.main.empty ? t = { from: n.from, to: n.to, insert: r.state.doc.slice(n.from, n.to) } : t && t.from >= n.from && t.to <= n.to && (t.from != n.from || t.to != n.to) && n.to - n.from - (t.to - t.from) <= 4 ? t = {
    from: n.from,
    to: n.to,
    insert: r.state.doc.slice(n.from, t.from).append(t.insert).append(r.state.doc.slice(t.to, n.to))
  } : (R.mac || R.android) && t && t.from == t.to && t.from == n.head - 1 && /^\. ?$/.test(t.insert.toString()) && r.contentDOM.getAttribute("autocorrect") == "off" ? (i && t.insert.length == 2 && (i = S.single(i.main.anchor - 1, i.main.head - 1)), t = { from: n.from, to: n.to, insert: K.of([" "]) }) : R.chrome && t && t.from == t.to && t.from == n.head && t.insert.toString() == `
 ` && r.lineWrapping && (i && (i = S.single(i.main.anchor - 1, i.main.head - 1)), t = { from: n.from, to: n.to, insert: K.of([" "]) }), t) {
    if (R.ios && r.inputState.flushIOSKey() || R.android && (t.from == n.from && t.to == n.to && t.insert.length == 1 && t.insert.lines == 2 && Zi(r.contentDOM, "Enter", 13) || (t.from == n.from - 1 && t.to == n.to && t.insert.length == 0 || s == 8 && t.insert.length < t.to - t.from && t.to > n.head) && Zi(r.contentDOM, "Backspace", 8) || t.from == n.from && t.to == n.to + 1 && t.insert.length == 0 && Zi(r.contentDOM, "Delete", 46)))
      return !0;
    let o = t.insert.toString();
    r.inputState.composing >= 0 && r.inputState.composing++;
    let l, a = () => l || (l = Jv(r, t, i));
    return r.state.facet(tm).some((h) => h(r, t.from, t.to, o, a)) || r.dispatch(a()), !0;
  } else if (i && !i.main.eq(n)) {
    let o = !1, l = "select";
    return r.inputState.lastSelectionTime > Date.now() - 50 && (r.inputState.lastSelectionOrigin == "select" && (o = !0), l = r.inputState.lastSelectionOrigin), r.dispatch({ selection: i, scrollIntoView: o, userEvent: l }), !0;
  } else
    return !1;
}
function Jv(r, e, t) {
  let i, n = r.state, s = n.selection.main;
  if (e.from >= s.from && e.to <= s.to && e.to - e.from >= (s.to - s.from) / 3 && (!t || t.main.empty && t.main.from == e.from + e.insert.length) && r.inputState.composing < 0) {
    let l = s.from < e.from ? n.sliceDoc(s.from, e.from) : "", a = s.to > e.to ? n.sliceDoc(e.to, s.to) : "";
    i = n.replaceSelection(r.state.toText(l + e.insert.sliceString(0, void 0, r.state.lineBreak) + a));
  } else {
    let l = n.changes(e), a = t && t.main.to <= l.newLength ? t.main : void 0;
    if (n.selection.ranges.length > 1 && r.inputState.composing >= 0 && e.to <= s.to && e.to >= s.to - 10) {
      let h = r.state.sliceDoc(e.from, e.to), c, u = t && cm(r, t.main.head);
      if (u) {
        let f = e.insert.length - (e.to - e.from);
        c = { from: u.from, to: u.to - f };
      } else
        c = r.state.doc.lineAt(s.head);
      let d = s.to - e.to, p = s.to - s.from;
      i = n.changeByRange((f) => {
        if (f.from == s.from && f.to == s.to)
          return { changes: l, range: a || f.map(l) };
        let m = f.to - d, g = m - h.length;
        if (f.to - f.from != p || r.state.sliceDoc(g, m) != h || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        f.to >= c.from && f.from <= c.to)
          return { range: f };
        let b = n.changes({ from: g, to: m, insert: e.insert }), v = f.to - s.to;
        return {
          changes: b,
          range: a ? S.range(Math.max(0, a.anchor + v), Math.max(0, a.head + v)) : f.map(b)
        };
      });
    } else
      i = {
        changes: l,
        selection: a && n.selection.replaceRange(a)
      };
  }
  let o = "input.type";
  return (r.composing || r.inputState.compositionPendingChange && r.inputState.compositionEndedAt > Date.now() - 50) && (r.inputState.compositionPendingChange = !1, o += ".compose", r.inputState.compositionFirstChange && (o += ".start", r.inputState.compositionFirstChange = !1)), n.update(i, { userEvent: o, scrollIntoView: !0 });
}
function ex(r, e, t, i) {
  let n = Math.min(r.length, e.length), s = 0;
  for (; s < n && r.charCodeAt(s) == e.charCodeAt(s); )
    s++;
  if (s == n && r.length == e.length)
    return null;
  let o = r.length, l = e.length;
  for (; o > 0 && l > 0 && r.charCodeAt(o - 1) == e.charCodeAt(l - 1); )
    o--, l--;
  if (i == "end") {
    let a = Math.max(0, s - Math.min(o, l));
    t -= o + a - s;
  }
  if (o < s && r.length < e.length) {
    let a = t <= s && t >= o ? s - t : 0;
    s -= a, l = s + (l - o), o = s;
  } else if (l < s) {
    let a = t <= s && t >= l ? s - t : 0;
    s -= a, o = s + (o - l), l = s;
  }
  return { from: s, toA: o, toB: l };
}
function tx(r) {
  let e = [];
  if (r.root.activeElement != r.contentDOM)
    return e;
  let { anchorNode: t, anchorOffset: i, focusNode: n, focusOffset: s } = r.observer.selectionRange;
  return t && (e.push(new Xd(t, i)), (n != t || s != i) && e.push(new Xd(n, s))), e;
}
function rx(r, e) {
  if (r.length == 0)
    return null;
  let t = r[0].pos, i = r.length == 2 ? r[1].pos : t;
  return t > -1 && i > -1 ? S.single(t + e, i + e) : null;
}
const ix = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, Kl = R.ie && R.ie_version <= 11;
class nx {
  constructor(e) {
    this.view = e, this.active = !1, this.selectionRange = new My(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((t) => {
      for (let i of t)
        this.queue.push(i);
      (R.ie && R.ie_version <= 11 || R.ios && e.composing) && t.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), Kl && (this.onCharData = (t) => {
      this.queue.push({
        target: t.target,
        type: "characterData",
        oldValue: t.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var t;
      ((t = this.view.docView) === null || t === void 0 ? void 0 : t.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((t) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), t.length > 0 && t[t.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((t) => {
      t.length > 0 && t[t.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint() {
    this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500);
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((t, i) => t != e[i]))) {
      this.gapIntersection.disconnect();
      for (let t of e)
        this.gapIntersection.observe(t);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let t = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: i } = this, n = this.selectionRange;
    if (i.state.facet(fl) ? i.root.activeElement != this.dom : !uo(i.dom, n))
      return;
    let s = n.anchorNode && i.docView.nearest(n.anchorNode);
    if (s && s.ignoreEvent(e)) {
      t || (this.selectionChanged = !1);
      return;
    }
    (R.ie && R.ie_version <= 11 || R.android && R.chrome) && !i.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    n.focusNode && qn(n.focusNode, n.focusOffset, n.anchorNode, n.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this, t = R.safari && e.root.nodeType == 11 && zy(this.dom.ownerDocument) == this.dom && sx(this.view) || Zo(e.root);
    if (!t || this.selectionRange.eq(t))
      return !1;
    let i = uo(this.dom, t);
    return i && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && Ly(this.dom, t) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(t), i && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, t) {
    this.selectionRange.set(e.node, e.offset, t.node, t.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, t = null;
    for (let i = this.dom; i; )
      if (i.nodeType == 1)
        !t && e < this.scrollTargets.length && this.scrollTargets[e] == i ? e++ : t || (t = this.scrollTargets.slice(0, e)), t && t.push(i), i = i.assignedSlot || i.parentNode;
      else if (i.nodeType == 11)
        i = i.host;
      else
        break;
    if (e < this.scrollTargets.length && !t && (t = this.scrollTargets.slice(0, e)), t) {
      for (let i of this.scrollTargets)
        i.removeEventListener("scroll", this.onScroll);
      for (let i of this.scrollTargets = t)
        i.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, ix), Kl && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), Kl && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(e, t) {
    var i;
    if (!this.delayedAndroidKey) {
      let n = () => {
        let s = this.delayedAndroidKey;
        s && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = s.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && s.force && Zi(this.dom, s.key, s.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(n);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: t,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((i = this.delayedAndroidKey) === null || i === void 0) && i.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords())
      this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let t = -1, i = -1, n = !1;
    for (let s of e) {
      let o = this.readMutation(s);
      o && (o.typeOver && (n = !0), t == -1 ? { from: t, to: i } = o : (t = Math.min(o.from, t), i = Math.max(o.to, i)));
    }
    return { from: t, to: i, typeOver: n };
  }
  readChange() {
    let { from: e, to: t, typeOver: i } = this.processRecords(), n = this.selectionChanged && uo(this.dom, this.selectionRange);
    if (e < 0 && !n)
      return null;
    e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let s = new Kv(this.view, e, t, i);
    return this.view.docView.domChanged = { newSel: s.newSel ? s.newSel.main : null }, s;
  }
  // Apply pending changes, if any
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    e && this.readSelectionRange();
    let t = this.readChange();
    if (!t)
      return this.view.requestMeasure(), !1;
    let i = this.view.state, n = Qm(this.view, t);
    return this.view.state == i && this.view.update([]), n;
  }
  readMutation(e) {
    let t = this.view.docView.nearest(e.target);
    if (!t || t.ignoreMutation(e))
      return null;
    if (t.markDirty(e.type == "attributes"), e.type == "attributes" && (t.flags |= 4), e.type == "childList") {
      let i = Zd(t, e.previousSibling || e.target.previousSibling, -1), n = Zd(t, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: i ? t.posAfter(i) : t.posAtStart,
        to: n ? t.posBefore(n) : t.posAtEnd,
        typeOver: !1
      };
    } else
      return e.type == "characterData" ? { from: t.posAtStart, to: t.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  destroy() {
    var e, t, i;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (t = this.gapIntersection) === null || t === void 0 || t.disconnect(), (i = this.resizeScroll) === null || i === void 0 || i.disconnect();
    for (let n of this.scrollTargets)
      n.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey);
  }
}
function Zd(r, e, t) {
  for (; e; ) {
    let i = he.get(e);
    if (i && i.parent == r)
      return i;
    let n = e.parentNode;
    e = n != r.dom ? n : t > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function sx(r) {
  let e = null;
  function t(a) {
    a.preventDefault(), a.stopImmediatePropagation(), e = a.getTargetRanges()[0];
  }
  if (r.contentDOM.addEventListener("beforeinput", t, !0), r.dom.ownerDocument.execCommand("indent"), r.contentDOM.removeEventListener("beforeinput", t, !0), !e)
    return null;
  let i = e.startContainer, n = e.startOffset, s = e.endContainer, o = e.endOffset, l = r.docView.domAtPos(r.state.selection.main.anchor);
  return qn(l.node, l.offset, s, o) && ([i, n, s, o] = [s, o, i, n]), { anchorNode: i, anchorOffset: n, focusNode: s, focusOffset: o };
}
class Z {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(e = {}) {
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), e.parent && e.parent.appendChild(this.dom);
    let { dispatch: t } = e;
    this.dispatchTransactions = e.dispatchTransactions || t && ((i) => i.forEach((n) => t(n, this))) || ((i) => this.update(i)), this.dispatch = this.dispatch.bind(this), this._root = e.root || jy(e.parent) || document, this.viewState = new Pd(e.state || U.create(e)), e.scrollTo && e.scrollTo.is(qs) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(kn).map((i) => new Gl(i));
    for (let i of this.plugins)
      i.update(this);
    this.observer = new nx(this), this.inputState = new yv(this), this.inputState.ensureHandlers(this.plugins), this.docView = new hd(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure();
  }
  dispatch(...e) {
    let t = e.length == 1 && e[0] instanceof we ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
    this.dispatchTransactions(t, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let t = !1, i = !1, n, s = this.state;
    for (let d of e) {
      if (d.startState != s)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      s = d.state;
    }
    if (this.destroyed) {
      this.viewState.state = s;
      return;
    }
    let o = this.hasFocus, l = 0, a = null;
    e.some((d) => d.annotation(wm)) ? (this.inputState.notifiedFocused = o, l = 1) : o != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = o, a = ym(s, o), a || (l = 1));
    let h = this.observer.delayedAndroidKey, c = null;
    if (h ? (this.observer.clearDelayedAndroidKey(), c = this.observer.readChange(), (c && !this.state.doc.eq(s.doc) || !this.state.selection.eq(s.selection)) && (c = null)) : this.observer.clear(), s.facet(U.phrases) != this.state.facet(U.phrases))
      return this.setState(s);
    n = _o.create(this, s, e), n.flags |= l;
    let u = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let d of e) {
        if (u && (u = u.map(d.changes)), d.scrollIntoView) {
          let { main: p } = d.state.selection;
          u = new _i(p.empty ? p : S.cursor(p.head, p.head > p.anchor ? -1 : 1));
        }
        for (let p of d.effects)
          p.is(qs) && (u = p.value.clip(this.state));
      }
      this.viewState.update(n, u), this.bidiCache = Ro.update(this.bidiCache, n.changes), n.empty || (this.updatePlugins(n), this.inputState.update(n)), t = this.docView.update(n), this.state.facet($n) != this.styleModules && this.mountStyles(), i = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(t, e.some((d) => d.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (n.startState.facet(js) != n.state.facet(js) && (this.viewState.mustMeasureContent = !0), (t || i || u || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), !n.empty)
      for (let d of this.state.facet(uh))
        try {
          d(n);
        } catch (p) {
          gt(this.state, p, "update listener");
        }
    (a || c) && Promise.resolve().then(() => {
      a && this.state == a.startState && this.dispatch(a), c && !Qm(this, c) && h.force && Zi(this.contentDOM, h.key, h.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let t = this.hasFocus;
    try {
      for (let i of this.plugins)
        i.destroy(this);
      this.viewState = new Pd(e), this.plugins = e.facet(kn).map((i) => new Gl(i)), this.pluginMap.clear();
      for (let i of this.plugins)
        i.update(this);
      this.docView.destroy(), this.docView = new hd(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    t && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let t = e.startState.facet(kn), i = e.state.facet(kn);
    if (t != i) {
      let n = [];
      for (let s of i) {
        let o = t.indexOf(s);
        if (o < 0)
          n.push(new Gl(s));
        else {
          let l = this.plugins[o];
          l.mustUpdate = e, n.push(l);
        }
      }
      for (let s of this.plugins)
        s.mustUpdate != e && s.destroy(this);
      this.plugins = n, this.pluginMap.clear();
    } else
      for (let n of this.plugins)
        n.mustUpdate = e;
    for (let n = 0; n < this.plugins.length; n++)
      this.plugins[n].update(this);
    t != i && this.inputState.ensureHandlers(this.plugins);
  }
  /**
  @internal
  */
  measure(e = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, e && this.observer.forceFlush();
    let t = null, i = this.scrollDOM, n = i.scrollTop * this.scaleY, { scrollAnchorPos: s, scrollAnchorHeight: o } = this.viewState;
    Math.abs(n - this.viewState.scrollTop) > 1 && (o = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let l = 0; ; l++) {
        if (o < 0)
          if (qO(i))
            s = -1, o = this.viewState.heightMap.height;
          else {
            let p = this.viewState.scrollAnchorAt(n);
            s = p.from, o = p.top;
          }
        this.updateState = 1;
        let a = this.viewState.measure(this);
        if (!a && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (l > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let h = [];
        a & 4 || ([this.measureRequests, h] = [h, this.measureRequests]);
        let c = h.map((p) => {
          try {
            return p.read(this);
          } catch (f) {
            return gt(this.state, f), _d;
          }
        }), u = _o.create(this, this.state, []), d = !1;
        u.flags |= a, t ? t.flags |= a : t = u, this.updateState = 2, u.empty || (this.updatePlugins(u), this.inputState.update(u), this.updateAttrs(), d = this.docView.update(u));
        for (let p = 0; p < h.length; p++)
          if (c[p] != _d)
            try {
              let f = h[p];
              f.write && f.write(c[p], this);
            } catch (f) {
              gt(this.state, f);
            }
        if (d && this.docView.updateSelection(!0), !u.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, o = -1;
              continue;
            } else {
              let f = (s < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(s).top) - o;
              if (f > 1 || f < -1) {
                n = n + f, i.scrollTop = n / this.scaleY, o = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (t && !t.empty)
      for (let l of this.state.facet(uh))
        l(t);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return mh + " " + (this.state.facet(Oh) ? km : Sm) + " " + this.state.facet(js);
  }
  updateAttrs() {
    let e = Rd(this, sm, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), t = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      translate: "no",
      contenteditable: this.state.facet(fl) ? "true" : "false",
      class: "cm-content",
      style: `${R.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (t["aria-readonly"] = "true"), Rd(this, gc, t);
    let i = this.observer.ignore(() => {
      let n = oh(this.contentDOM, this.contentAttrs, t), s = oh(this.dom, this.editorAttrs, e);
      return n || s;
    });
    return this.editorAttrs = e, this.contentAttrs = t, i;
  }
  showAnnouncements(e) {
    let t = !0;
    for (let i of e)
      for (let n of i.effects)
        if (n.is(Z.announce)) {
          t && (this.announceDOM.textContent = ""), t = !1;
          let s = this.announceDOM.appendChild(document.createElement("div"));
          s.textContent = n.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet($n);
    let e = this.state.facet(Z.cspNonce);
    Er.mount(this.root, this.styleModules.concat(Nv).reverse(), e ? { nonce: e } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let t = 0; t < this.measureRequests.length; t++)
          if (this.measureRequests[t].key === e.key) {
            this.measureRequests[t] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e) {
    let t = this.pluginMap.get(e);
    return (t === void 0 || t && t.spec != e) && this.pluginMap.set(e, t = this.plugins.find((i) => i.spec == e) || null), t && t.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e, t, i) {
    return Fl(this, e, Od(this, e, t, i));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e, t) {
    return Fl(this, e, Od(this, e, t, (i) => bv(this, e.head, i)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(e, t) {
    let i = this.bidiSpans(e), n = this.textDirectionAt(e.from), s = i[t ? i.length - 1 : 0];
    return S.cursor(s.side(t, n) + e.from, s.forward(!t, n) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e, t, i = !0) {
    return gv(this, e, t, i);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e, t, i) {
    return Fl(this, e, wv(this, e, t, i));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e, t = 0) {
    return this.docView.posFromDOM(e, t);
  }
  posAtCoords(e, t = !0) {
    return this.readMeasured(), dm(this, e, t);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e, t = 1) {
    this.readMeasured();
    let i = this.docView.coordsAt(e, t);
    if (!i || i.left == i.right)
      return i;
    let n = this.state.doc.lineAt(e), s = this.bidiSpans(n), o = s[Sr.find(s, e - n.from, -1, t)];
    return dl(i, o.dir == ce.LTR == t > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(e) {
    return !this.state.facet(im) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e) {
    if (e.length > ox)
      return NO(e.length);
    let t = this.textDirectionAt(e.from), i;
    for (let s of this.bidiCache)
      if (s.from == e.from && s.dir == t && (s.fresh || GO(s.isolates, i = ad(this, e))))
        return s.order;
    i || (i = ad(this, e));
    let n = tv(e.text, t, i);
    return this.bidiCache.push(new Ro(e.from, e.to, t, i, !0, n)), n;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || R.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      AO(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e, t = {}) {
    return qs.of(new _i(typeof e == "number" ? S.cursor(e) : e, t.y, t.x, t.yMargin, t.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: e, scrollLeft: t } = this.scrollDOM, i = this.viewState.scrollAnchorAt(e);
    return qs.of(new _i(S.cursor(i.from), "start", "start", i.top - e, t, !0));
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(e) {
    return ge.define(() => ({}), { eventHandlers: e });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(e) {
    return ge.define(() => ({}), { eventObservers: e });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
  added—need to be explicitly differentiated by adding an `&` to
  the selector for that element—for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e, t) {
    let i = Er.newName(), n = [js.of(i), $n.of(gh(`.${i}`, e))];
    return t && t.dark && n.push(Oh.of(!0)), n;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e) {
    return Lr.lowest($n.of(gh("." + mh, e, $m)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(e) {
    var t;
    let i = e.querySelector(".cm-content"), n = i && he.get(i) || he.get(e);
    return ((t = n == null ? void 0 : n.rootView) === null || t === void 0 ? void 0 : t.view) || null;
  }
}
Z.styleModule = $n;
Z.inputHandler = tm;
Z.focusChangeEffect = rm;
Z.perLineTextDirection = im;
Z.exceptionSink = em;
Z.updateListener = uh;
Z.editable = fl;
Z.mouseSelectionStyle = JO;
Z.dragMovesSelection = KO;
Z.clickAddsSelectionRange = HO;
Z.decorations = Fn;
Z.outerDecorations = om;
Z.atomicRanges = bc;
Z.bidiIsolatedRanges = lm;
Z.scrollMargins = am;
Z.darkTheme = Oh;
Z.cspNonce = /* @__PURE__ */ _.define({ combine: (r) => r.length ? r[0] : "" });
Z.contentAttributes = gc;
Z.editorAttributes = sm;
Z.lineWrapping = /* @__PURE__ */ Z.contentAttributes.of({ class: "cm-lineWrapping" });
Z.announce = /* @__PURE__ */ j.define();
const ox = 4096, _d = {};
class Ro {
  constructor(e, t, i, n, s, o) {
    this.from = e, this.to = t, this.dir = i, this.isolates = n, this.fresh = s, this.order = o;
  }
  static update(e, t) {
    if (t.empty && !e.some((s) => s.fresh))
      return e;
    let i = [], n = e.length ? e[e.length - 1].dir : ce.LTR;
    for (let s = Math.max(0, e.length - 10); s < e.length; s++) {
      let o = e[s];
      o.dir == n && !t.touchesRange(o.from, o.to) && i.push(new Ro(t.mapPos(o.from, 1), t.mapPos(o.to, -1), o.dir, o.isolates, !1, o.order));
    }
    return i;
  }
}
function Rd(r, e, t) {
  for (let i = r.state.facet(e), n = i.length - 1; n >= 0; n--) {
    let s = i[n], o = typeof s == "function" ? s(r) : s;
    o && sh(o, t);
  }
  return t;
}
const lx = R.mac ? "mac" : R.windows ? "win" : R.linux ? "linux" : "key";
function ax(r, e) {
  const t = r.split(/-(?!$)/);
  let i = t[t.length - 1];
  i == "Space" && (i = " ");
  let n, s, o, l;
  for (let a = 0; a < t.length - 1; ++a) {
    const h = t[a];
    if (/^(cmd|meta|m)$/i.test(h))
      l = !0;
    else if (/^a(lt)?$/i.test(h))
      n = !0;
    else if (/^(c|ctrl|control)$/i.test(h))
      s = !0;
    else if (/^s(hift)?$/i.test(h))
      o = !0;
    else if (/^mod$/i.test(h))
      e == "mac" ? l = !0 : s = !0;
    else
      throw new Error("Unrecognized modifier name: " + h);
  }
  return n && (i = "Alt-" + i), s && (i = "Ctrl-" + i), l && (i = "Meta-" + i), o && (i = "Shift-" + i), i;
}
function Ls(r, e, t) {
  return e.altKey && (r = "Alt-" + r), e.ctrlKey && (r = "Ctrl-" + r), e.metaKey && (r = "Meta-" + r), t !== !1 && e.shiftKey && (r = "Shift-" + r), r;
}
const hx = /* @__PURE__ */ Lr.default(/* @__PURE__ */ Z.domEventHandlers({
  keydown(r, e) {
    return Tm(Pm(e.state), r, e, "editor");
  }
})), tn = /* @__PURE__ */ _.define({ enables: hx }), Ad = /* @__PURE__ */ new WeakMap();
function Pm(r) {
  let e = r.facet(tn), t = Ad.get(e);
  return t || Ad.set(e, t = dx(e.reduce((i, n) => i.concat(n), []))), t;
}
function cx(r, e, t) {
  return Tm(Pm(r.state), e, r, t);
}
let yr = null;
const ux = 4e3;
function dx(r, e = lx) {
  let t = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null), n = (o, l) => {
    let a = i[o];
    if (a == null)
      i[o] = l;
    else if (a != l)
      throw new Error("Key binding " + o + " is used both as a regular binding and as a multi-stroke prefix");
  }, s = (o, l, a, h, c) => {
    var u, d;
    let p = t[o] || (t[o] = /* @__PURE__ */ Object.create(null)), f = l.split(/ (?!$)/).map((b) => ax(b, e));
    for (let b = 1; b < f.length; b++) {
      let v = f.slice(0, b).join(" ");
      n(v, !0), p[v] || (p[v] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(k) => {
          let $ = yr = { view: k, prefix: v, scope: o };
          return setTimeout(() => {
            yr == $ && (yr = null);
          }, ux), !0;
        }]
      });
    }
    let m = f.join(" ");
    n(m, !1);
    let g = p[m] || (p[m] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((d = (u = p._any) === null || u === void 0 ? void 0 : u.run) === null || d === void 0 ? void 0 : d.slice()) || []
    });
    a && g.run.push(a), h && (g.preventDefault = !0), c && (g.stopPropagation = !0);
  };
  for (let o of r) {
    let l = o.scope ? o.scope.split(" ") : ["editor"];
    if (o.any)
      for (let h of l) {
        let c = t[h] || (t[h] = /* @__PURE__ */ Object.create(null));
        c._any || (c._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        for (let u in c)
          c[u].run.push(o.any);
      }
    let a = o[e] || o.key;
    if (a)
      for (let h of l)
        s(h, a, o.run, o.preventDefault, o.stopPropagation), o.shift && s(h, "Shift-" + a, o.shift, o.preventDefault, o.stopPropagation);
  }
  return t;
}
function Tm(r, e, t, i) {
  let n = qy(e), s = Te(n, 0), o = dt(s) == n.length && n != " ", l = "", a = !1, h = !1, c = !1;
  yr && yr.view == t && yr.scope == i && (l = yr.prefix + " ", fm.indexOf(e.keyCode) < 0 && (h = !0, yr = null));
  let u = /* @__PURE__ */ new Set(), d = (g) => {
    if (g) {
      for (let b of g.run)
        if (!u.has(b) && (u.add(b), b(t, e)))
          return g.stopPropagation && (c = !0), !0;
      g.preventDefault && (g.stopPropagation && (c = !0), h = !0);
    }
    return !1;
  }, p = r[i], f, m;
  return p && (d(p[l + Ls(n, e, !o)]) ? a = !0 : o && (e.altKey || e.metaKey || e.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(R.windows && e.ctrlKey && e.altKey) && (f = qr[e.keyCode]) && f != n ? (d(p[l + Ls(f, e, !0)]) || e.shiftKey && (m = Gn[e.keyCode]) != n && m != f && d(p[l + Ls(m, e, !1)])) && (a = !0) : o && e.shiftKey && d(p[l + Ls(n, e, !0)]) && (a = !0), !a && d(p._any) && (a = !0)), h && (a = !0), a && c && e.stopPropagation(), a;
}
class Ss {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(e, t, i, n, s) {
    this.className = e, this.left = t, this.top = i, this.width = n, this.height = s;
  }
  draw() {
    let e = document.createElement("div");
    return e.className = this.className, this.adjust(e), e;
  }
  update(e, t) {
    return t.className != this.className ? !1 : (this.adjust(e), !0);
  }
  adjust(e) {
    e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(e, t, i) {
    if (i.empty) {
      let n = e.coordsAtPos(i.head, i.assoc || 1);
      if (!n)
        return [];
      let s = Cm(e);
      return [new Ss(t, n.left - s.left, n.top - s.top, null, n.bottom - n.top)];
    } else
      return px(e, t, i);
  }
}
function Cm(r) {
  let e = r.scrollDOM.getBoundingClientRect();
  return { left: (r.textDirection == ce.LTR ? e.left : e.right - r.scrollDOM.clientWidth * r.scaleX) - r.scrollDOM.scrollLeft * r.scaleX, top: e.top - r.scrollDOM.scrollTop * r.scaleY };
}
function Ed(r, e, t) {
  let i = S.cursor(e);
  return {
    from: Math.max(t.from, r.moveToLineBoundary(i, !1, !0).from),
    to: Math.min(t.to, r.moveToLineBoundary(i, !0, !0).from),
    type: Le.Text
  };
}
function px(r, e, t) {
  if (t.to <= r.viewport.from || t.from >= r.viewport.to)
    return [];
  let i = Math.max(t.from, r.viewport.from), n = Math.min(t.to, r.viewport.to), s = r.textDirection == ce.LTR, o = r.contentDOM, l = o.getBoundingClientRect(), a = Cm(r), h = o.querySelector(".cm-line"), c = h && window.getComputedStyle(h), u = l.left + (c ? parseInt(c.paddingLeft) + Math.min(0, parseInt(c.textIndent)) : 0), d = l.right - (c ? parseInt(c.paddingRight) : 0), p = ph(r, i), f = ph(r, n), m = p.type == Le.Text ? p : null, g = f.type == Le.Text ? f : null;
  if (m && (r.lineWrapping || p.widgetLineBreaks) && (m = Ed(r, i, m)), g && (r.lineWrapping || f.widgetLineBreaks) && (g = Ed(r, n, g)), m && g && m.from == g.from)
    return v(k(t.from, t.to, m));
  {
    let x = m ? k(t.from, null, m) : $(p, !1), Q = g ? k(null, t.to, g) : $(f, !0), P = [];
    return (m || p).to < (g || f).from - (m && g ? 1 : 0) || p.widgetLineBreaks > 1 && x.bottom + r.defaultLineHeight / 2 < Q.top ? P.push(b(u, x.bottom, d, Q.top)) : x.bottom < Q.top && r.elementAtHeight((x.bottom + Q.top) / 2).type == Le.Text && (x.bottom = Q.top = (x.bottom + Q.top) / 2), v(x).concat(P).concat(v(Q));
  }
  function b(x, Q, P, z) {
    return new Ss(
      e,
      x - a.left,
      Q - a.top - 0.01,
      P - x,
      z - Q + 0.01
      /* C.Epsilon */
    );
  }
  function v({ top: x, bottom: Q, horizontal: P }) {
    let z = [];
    for (let V = 0; V < P.length; V += 2)
      z.push(b(P[V], x, P[V + 1], Q));
    return z;
  }
  function k(x, Q, P) {
    let z = 1e9, V = -1e9, L = [];
    function M(W, G, le, ue, Me) {
      let ht = r.coordsAtPos(W, W == P.to ? -2 : 2), xe = r.coordsAtPos(le, le == P.from ? 2 : -2);
      !ht || !xe || (z = Math.min(ht.top, xe.top, z), V = Math.max(ht.bottom, xe.bottom, V), Me == ce.LTR ? L.push(s && G ? u : ht.left, s && ue ? d : xe.right) : L.push(!s && ue ? u : xe.left, !s && G ? d : ht.right));
    }
    let q = x ?? P.from, F = Q ?? P.to;
    for (let W of r.visibleRanges)
      if (W.to > q && W.from < F)
        for (let G = Math.max(W.from, q), le = Math.min(W.to, F); ; ) {
          let ue = r.state.doc.lineAt(G);
          for (let Me of r.bidiSpans(ue)) {
            let ht = Me.from + ue.from, xe = Me.to + ue.from;
            if (ht >= le)
              break;
            xe > G && M(Math.max(ht, G), x == null && ht <= q, Math.min(xe, le), Q == null && xe >= F, Me.dir);
          }
          if (G = ue.to + 1, G >= le)
            break;
        }
    return L.length == 0 && M(q, x == null, F, Q == null, r.textDirection), { top: z, bottom: V, horizontal: L };
  }
  function $(x, Q) {
    let P = l.top + (Q ? x.top : x.bottom);
    return { top: P, bottom: P, horizontal: [] };
  }
}
function fx(r, e) {
  return r.constructor == e.constructor && r.eq(e);
}
class Ox {
  constructor(e, t) {
    this.view = e, this.layer = t, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), t.above && this.dom.classList.add("cm-layer-above"), t.class && this.dom.classList.add(t.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), t.mount && t.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(Oo) != e.state.facet(Oo) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(), e.view.requestMeasure(this.measureReq));
  }
  setOrder(e) {
    let t = 0, i = e.facet(Oo);
    for (; t < i.length && i[t] != this.layer; )
      t++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - t);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX: e, scaleY: t } = this.view;
    (e != this.scaleX || t != this.scaleY) && (this.scaleX = e, this.scaleY = t, this.dom.style.transform = `scale(${1 / e}, ${1 / t})`);
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((t, i) => !fx(t, this.drawn[i]))) {
      let t = this.dom.firstChild, i = 0;
      for (let n of e)
        n.update && t && n.constructor && this.drawn[i].constructor && n.update(t, this.drawn[i]) ? (t = t.nextSibling, i++) : this.dom.insertBefore(n.draw(), t);
      for (; t; ) {
        let n = t.nextSibling;
        t.remove(), t = n;
      }
      this.drawn = e;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const Oo = /* @__PURE__ */ _.define();
function Xm(r) {
  return [
    ge.define((e) => new Ox(e, r)),
    Oo.of(r)
  ];
}
const Zm = !R.ios, Hn = /* @__PURE__ */ _.define({
  combine(r) {
    return _t(r, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (e, t) => Math.min(e, t),
      drawRangeCursor: (e, t) => e || t
    });
  }
});
function mx(r = {}) {
  return [
    Hn.of(r),
    gx,
    bx,
    wx,
    nm.of(!0)
  ];
}
function _m(r) {
  return r.startState.facet(Hn) != r.state.facet(Hn);
}
const gx = /* @__PURE__ */ Xm({
  above: !0,
  markers(r) {
    let { state: e } = r, t = e.facet(Hn), i = [];
    for (let n of e.selection.ranges) {
      let s = n == e.selection.main;
      if (n.empty ? !s || Zm : t.drawRangeCursor) {
        let o = s ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", l = n.empty ? n : S.cursor(n.head, n.head > n.anchor ? -1 : 1);
        for (let a of Ss.forRange(r, o, l))
          i.push(a);
      }
    }
    return i;
  },
  update(r, e) {
    r.transactions.some((i) => i.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let t = _m(r);
    return t && qd(r.state, e), r.docChanged || r.selectionSet || t;
  },
  mount(r, e) {
    qd(e.state, r);
  },
  class: "cm-cursorLayer"
});
function qd(r, e) {
  e.style.animationDuration = r.facet(Hn).cursorBlinkRate + "ms";
}
const bx = /* @__PURE__ */ Xm({
  above: !1,
  markers(r) {
    return r.state.selection.ranges.map((e) => e.empty ? [] : Ss.forRange(r, "cm-selectionBackground", e)).reduce((e, t) => e.concat(t));
  },
  update(r, e) {
    return r.docChanged || r.selectionSet || r.viewportChanged || _m(r);
  },
  class: "cm-selectionLayer"
}), bh = {
  ".cm-line": {
    "& ::selection": { backgroundColor: "transparent !important" },
    "&::selection": { backgroundColor: "transparent !important" }
  }
};
Zm && (bh[".cm-line"].caretColor = "transparent !important", bh[".cm-content"] = { caretColor: "transparent !important" });
const wx = /* @__PURE__ */ Lr.highest(/* @__PURE__ */ Z.theme(bh)), Rm = /* @__PURE__ */ j.define({
  map(r, e) {
    return r == null ? null : e.mapPos(r);
  }
}), Tn = /* @__PURE__ */ Qe.define({
  create() {
    return null;
  },
  update(r, e) {
    return r != null && (r = e.changes.mapPos(r)), e.effects.reduce((t, i) => i.is(Rm) ? i.value : t, r);
  }
}), yx = /* @__PURE__ */ ge.fromClass(class {
  constructor(r) {
    this.view = r, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(r) {
    var e;
    let t = r.state.field(Tn);
    t == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (r.startState.field(Tn) != t || r.docChanged || r.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: r } = this, e = r.state.field(Tn), t = e != null && r.coordsAtPos(e);
    if (!t)
      return null;
    let i = r.scrollDOM.getBoundingClientRect();
    return {
      left: t.left - i.left + r.scrollDOM.scrollLeft * r.scaleX,
      top: t.top - i.top + r.scrollDOM.scrollTop * r.scaleY,
      height: t.bottom - t.top
    };
  }
  drawCursor(r) {
    if (this.cursor) {
      let { scaleX: e, scaleY: t } = this.view;
      r ? (this.cursor.style.left = r.left / e + "px", this.cursor.style.top = r.top / t + "px", this.cursor.style.height = r.height / t + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(r) {
    this.view.state.field(Tn) != r && this.view.dispatch({ effects: Rm.of(r) });
  }
}, {
  eventObservers: {
    dragover(r) {
      this.setDropPos(this.view.posAtCoords({ x: r.clientX, y: r.clientY }));
    },
    dragleave(r) {
      (r.target == this.view.contentDOM || !this.view.contentDOM.contains(r.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function vx() {
  return [Tn, yx];
}
function zd(r, e, t, i, n) {
  e.lastIndex = 0;
  for (let s = r.iterRange(t, i), o = t, l; !s.next().done; o += s.value.length)
    if (!s.lineBreak)
      for (; l = e.exec(s.value); )
        n(o + l.index, l);
}
function xx(r, e) {
  let t = r.visibleRanges;
  if (t.length == 1 && t[0].from == r.viewport.from && t[0].to == r.viewport.to)
    return t;
  let i = [];
  for (let { from: n, to: s } of t)
    n = Math.max(r.state.doc.lineAt(n).from, n - e), s = Math.min(r.state.doc.lineAt(s).to, s + e), i.length && i[i.length - 1].to >= n ? i[i.length - 1].to = s : i.push({ from: n, to: s });
  return i;
}
class Sx {
  /**
  Create a decorator.
  */
  constructor(e) {
    const { regexp: t, decoration: i, decorate: n, boundary: s, maxLength: o = 1e3 } = e;
    if (!t.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = t, n)
      this.addMatch = (l, a, h, c) => n(c, h, h + l[0].length, l, a);
    else if (typeof i == "function")
      this.addMatch = (l, a, h, c) => {
        let u = i(l, a, h);
        u && c(h, h + l[0].length, u);
      };
    else if (i)
      this.addMatch = (l, a, h, c) => c(h, h + l[0].length, i);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = s, this.maxLength = o;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(e) {
    let t = new sr(), i = t.add.bind(t);
    for (let { from: n, to: s } of xx(e, this.maxLength))
      zd(e.state.doc, this.regexp, n, s, (o, l) => this.addMatch(l, e, o, i));
    return t.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(e, t) {
    let i = 1e9, n = -1;
    return e.docChanged && e.changes.iterChanges((s, o, l, a) => {
      a > e.view.viewport.from && l < e.view.viewport.to && (i = Math.min(l, i), n = Math.max(a, n));
    }), e.viewportChanged || n - i > 1e3 ? this.createDeco(e.view) : n > -1 ? this.updateRange(e.view, t.map(e.changes), i, n) : t;
  }
  updateRange(e, t, i, n) {
    for (let s of e.visibleRanges) {
      let o = Math.max(s.from, i), l = Math.min(s.to, n);
      if (l > o) {
        let a = e.state.doc.lineAt(o), h = a.to < l ? e.state.doc.lineAt(l) : a, c = Math.max(s.from, a.from), u = Math.min(s.to, h.to);
        if (this.boundary) {
          for (; o > a.from; o--)
            if (this.boundary.test(a.text[o - 1 - a.from])) {
              c = o;
              break;
            }
          for (; l < h.to; l++)
            if (this.boundary.test(h.text[l - h.from])) {
              u = l;
              break;
            }
        }
        let d = [], p, f = (m, g, b) => d.push(b.range(m, g));
        if (a == h)
          for (this.regexp.lastIndex = c - a.from; (p = this.regexp.exec(a.text)) && p.index < u - a.from; )
            this.addMatch(p, e, p.index + a.from, f);
        else
          zd(e.state.doc, this.regexp, c, u, (m, g) => this.addMatch(g, e, m, f));
        t = t.update({ filterFrom: c, filterTo: u, filter: (m, g) => m < c || g > u, add: d });
      }
    }
    return t;
  }
}
const wh = /x/.unicode != null ? "gu" : "g", kx = /* @__PURE__ */ new RegExp(`[\0-\b
--­؜​‎‏\u2028\u2029‭‮⁦⁧⁩\uFEFF￹-￼]`, wh), $x = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let Jl = null;
function Qx() {
  var r;
  if (Jl == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    Jl = ((r = e.tabSize) !== null && r !== void 0 ? r : e.MozTabSize) != null;
  }
  return Jl || !1;
}
const mo = /* @__PURE__ */ _.define({
  combine(r) {
    let e = _t(r, {
      render: null,
      specialChars: kx,
      addSpecialChars: null
    });
    return (e.replaceTabs = !Qx()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, wh)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, wh)), e;
  }
});
function Px(r = {}) {
  return [mo.of(r), Tx()];
}
let Yd = null;
function Tx() {
  return Yd || (Yd = ge.fromClass(class {
    constructor(r) {
      this.view = r, this.decorations = E.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(r.state.facet(mo)), this.decorations = this.decorator.createDeco(r);
    }
    makeDecorator(r) {
      return new Sx({
        regexp: r.specialChars,
        decoration: (e, t, i) => {
          let { doc: n } = t.state, s = Te(e[0], 0);
          if (s == 9) {
            let o = n.lineAt(i), l = t.state.tabSize, a = Tt(o.text, l, i - o.from);
            return E.replace({
              widget: new _x((l - a % l) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[s] || (this.decorationCache[s] = E.replace({ widget: new Zx(r, s) }));
        },
        boundary: r.replaceTabs ? void 0 : /[^]/
      });
    }
    update(r) {
      let e = r.state.facet(mo);
      r.startState.facet(mo) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(r.view)) : this.decorations = this.decorator.updateDeco(r, this.decorations);
    }
  }, {
    decorations: (r) => r.decorations
  }));
}
const Cx = "•";
function Xx(r) {
  return r >= 32 ? Cx : r == 10 ? "␤" : String.fromCharCode(9216 + r);
}
class Zx extends Kt {
  constructor(e, t) {
    super(), this.options = e, this.code = t;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let t = Xx(this.code), i = e.state.phrase("Control character") + " " + ($x[this.code] || "0x" + this.code.toString(16)), n = this.options.render && this.options.render(this.code, i, t);
    if (n)
      return n;
    let s = document.createElement("span");
    return s.textContent = t, s.title = i, s.setAttribute("aria-label", i), s.className = "cm-specialChar", s;
  }
  ignoreEvent() {
    return !1;
  }
}
class _x extends Kt {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return !1;
  }
}
function Rx() {
  return Ex;
}
const Ax = /* @__PURE__ */ E.line({ class: "cm-activeLine" }), Ex = /* @__PURE__ */ ge.fromClass(class {
  constructor(r) {
    this.decorations = this.getDeco(r);
  }
  update(r) {
    (r.docChanged || r.selectionSet) && (this.decorations = this.getDeco(r.view));
  }
  getDeco(r) {
    let e = -1, t = [];
    for (let i of r.state.selection.ranges) {
      let n = r.lineBlockAt(i.head);
      n.from > e && (t.push(Ax.range(n.from)), e = n.from);
    }
    return E.set(t);
  }
}, {
  decorations: (r) => r.decorations
});
class qx extends Kt {
  constructor(e) {
    super(), this.content = e;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.className = "cm-placeholder", e.style.pointerEvents = "none", e.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : this.content), typeof this.content == "string" ? e.setAttribute("aria-label", "placeholder " + this.content) : e.setAttribute("aria-hidden", "true"), e;
  }
  coordsAt(e) {
    let t = e.firstChild ? Bi(e.firstChild) : [];
    if (!t.length)
      return null;
    let i = window.getComputedStyle(e.parentNode), n = dl(t[0], i.direction != "rtl"), s = parseInt(i.lineHeight);
    return n.bottom - n.top > s * 1.5 ? { left: n.left, right: n.right, top: n.top, bottom: n.top + s } : n;
  }
  ignoreEvent() {
    return !1;
  }
}
function ea(r) {
  return ge.fromClass(class {
    constructor(e) {
      this.view = e, this.placeholder = r ? E.set([E.widget({ widget: new qx(r), side: 1 }).range(0)]) : E.none;
    }
    get decorations() {
      return this.view.state.doc.length ? E.none : this.placeholder;
    }
  }, { decorations: (e) => e.decorations });
}
const yh = 2e3;
function zx(r, e, t) {
  let i = Math.min(e.line, t.line), n = Math.max(e.line, t.line), s = [];
  if (e.off > yh || t.off > yh || e.col < 0 || t.col < 0) {
    let o = Math.min(e.off, t.off), l = Math.max(e.off, t.off);
    for (let a = i; a <= n; a++) {
      let h = r.doc.line(a);
      h.length <= l && s.push(S.range(h.from + o, h.to + l));
    }
  } else {
    let o = Math.min(e.col, t.col), l = Math.max(e.col, t.col);
    for (let a = i; a <= n; a++) {
      let h = r.doc.line(a), c = Ka(h.text, o, r.tabSize, !0);
      if (c < 0)
        s.push(S.cursor(h.to));
      else {
        let u = Ka(h.text, l, r.tabSize);
        s.push(S.range(h.from + c, h.from + u));
      }
    }
  }
  return s;
}
function Yx(r, e) {
  let t = r.coordsAtPos(r.viewport.from);
  return t ? Math.round(Math.abs((t.left - e) / r.defaultCharacterWidth)) : -1;
}
function Wd(r, e) {
  let t = r.posAtCoords({ x: e.clientX, y: e.clientY }, !1), i = r.state.doc.lineAt(t), n = t - i.from, s = n > yh ? -1 : n == i.length ? Yx(r, e.clientX) : Tt(i.text, r.state.tabSize, t - i.from);
  return { line: i.number, col: s, off: n };
}
function Wx(r, e) {
  let t = Wd(r, e), i = r.state.selection;
  return t ? {
    update(n) {
      if (n.docChanged) {
        let s = n.changes.mapPos(n.startState.doc.line(t.line).from), o = n.state.doc.lineAt(s);
        t = { line: o.number, col: t.col, off: Math.min(t.off, o.length) }, i = i.map(n.changes);
      }
    },
    get(n, s, o) {
      let l = Wd(r, n);
      if (!l)
        return i;
      let a = zx(r.state, t, l);
      return a.length ? o ? S.create(a.concat(i.ranges)) : S.create(a) : i;
    }
  } : null;
}
function Vx(r) {
  let e = (r == null ? void 0 : r.eventFilter) || ((t) => t.altKey && t.button == 0);
  return Z.mouseSelectionStyle.of((t, i) => e(i) ? Wx(t, i) : null);
}
const Mx = {
  Alt: [18, (r) => !!r.altKey],
  Control: [17, (r) => !!r.ctrlKey],
  Shift: [16, (r) => !!r.shiftKey],
  Meta: [91, (r) => !!r.metaKey]
}, jx = { style: "cursor: crosshair" };
function Lx(r = {}) {
  let [e, t] = Mx[r.key || "Alt"], i = ge.fromClass(class {
    constructor(n) {
      this.view = n, this.isDown = !1;
    }
    set(n) {
      this.isDown != n && (this.isDown = n, this.view.update([]));
    }
  }, {
    eventObservers: {
      keydown(n) {
        this.set(n.keyCode == e || t(n));
      },
      keyup(n) {
        (n.keyCode == e || !t(n)) && this.set(!1);
      },
      mousemove(n) {
        this.set(t(n));
      }
    }
  });
  return [
    i,
    Z.contentAttributes.of((n) => {
      var s;
      return !((s = n.plugin(i)) === null || s === void 0) && s.isDown ? jx : null;
    })
  ];
}
const On = "-10000px";
class Am {
  constructor(e, t, i) {
    this.facet = t, this.createTooltipView = i, this.input = e.state.facet(t), this.tooltips = this.input.filter((n) => n), this.tooltipViews = this.tooltips.map(i);
  }
  update(e, t) {
    var i;
    let n = e.state.facet(this.facet), s = n.filter((a) => a);
    if (n === this.input) {
      for (let a of this.tooltipViews)
        a.update && a.update(e);
      return !1;
    }
    let o = [], l = t ? [] : null;
    for (let a = 0; a < s.length; a++) {
      let h = s[a], c = -1;
      if (h) {
        for (let u = 0; u < this.tooltips.length; u++) {
          let d = this.tooltips[u];
          d && d.create == h.create && (c = u);
        }
        if (c < 0)
          o[a] = this.createTooltipView(h), l && (l[a] = !!h.above);
        else {
          let u = o[a] = this.tooltipViews[c];
          l && (l[a] = t[c]), u.update && u.update(e);
        }
      }
    }
    for (let a of this.tooltipViews)
      o.indexOf(a) < 0 && (a.dom.remove(), (i = a.destroy) === null || i === void 0 || i.call(a));
    return t && (l.forEach((a, h) => t[h] = a), t.length = l.length), this.input = n, this.tooltips = s, this.tooltipViews = o, !0;
  }
}
function Bx(r) {
  let { win: e } = r;
  return { top: 0, left: 0, bottom: e.innerHeight, right: e.innerWidth };
}
const ta = /* @__PURE__ */ _.define({
  combine: (r) => {
    var e, t, i;
    return {
      position: R.ios ? "absolute" : ((e = r.find((n) => n.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((t = r.find((n) => n.parent)) === null || t === void 0 ? void 0 : t.parent) || null,
      tooltipSpace: ((i = r.find((n) => n.tooltipSpace)) === null || i === void 0 ? void 0 : i.tooltipSpace) || Bx
    };
  }
}), Vd = /* @__PURE__ */ new WeakMap(), yc = /* @__PURE__ */ ge.fromClass(class {
  constructor(r) {
    this.view = r, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = r.state.facet(ta);
    this.position = e.position, this.parent = e.parent, this.classes = r.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.manager = new Am(r, vc, (t) => this.createTooltip(t)), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((t) => {
      Date.now() > this.lastTransaction - 50 && t.length > 0 && t[t.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), r.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let r of this.manager.tooltipViews)
        this.intersectionObserver.observe(r.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(r) {
    r.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(r, this.above);
    e && this.observeIntersection();
    let t = e || r.geometryChanged, i = r.state.facet(ta);
    if (i.position != this.position && !this.madeAbsolute) {
      this.position = i.position;
      for (let n of this.manager.tooltipViews)
        n.dom.style.position = this.position;
      t = !0;
    }
    if (i.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = i.parent, this.createContainer();
      for (let n of this.manager.tooltipViews)
        this.container.appendChild(n.dom);
      t = !0;
    } else
      this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    t && this.maybeMeasure();
  }
  createTooltip(r) {
    let e = r.create(this.view);
    if (e.dom.classList.add("cm-tooltip"), r.arrow && !e.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let t = document.createElement("div");
      t.className = "cm-tooltip-arrow", e.dom.appendChild(t);
    }
    return e.dom.style.position = this.position, e.dom.style.top = On, e.dom.style.left = "0px", this.container.appendChild(e.dom), e.mount && e.mount(this.view), e;
  }
  destroy() {
    var r, e;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let t of this.manager.tooltipViews)
      t.dom.remove(), (r = t.destroy) === null || r === void 0 || r.call(t);
    this.parent && this.container.remove(), (e = this.intersectionObserver) === null || e === void 0 || e.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let r = this.view.dom.getBoundingClientRect(), e = 1, t = 1, i = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: n } = this.manager.tooltipViews[0];
      if (R.gecko)
        i = n.offsetParent != this.container.ownerDocument.body;
      else if (n.style.top == On && n.style.left == "0px") {
        let s = n.getBoundingClientRect();
        i = Math.abs(s.top + 1e4) > 1 || Math.abs(s.left) > 1;
      }
    }
    if (i || this.position == "absolute")
      if (this.parent) {
        let n = this.parent.getBoundingClientRect();
        n.width && n.height && (e = n.width / this.parent.offsetWidth, t = n.height / this.parent.offsetHeight);
      } else
        ({ scaleX: e, scaleY: t } = this.view.viewState);
    return {
      editor: r,
      parent: this.parent ? this.container.getBoundingClientRect() : r,
      pos: this.manager.tooltips.map((n, s) => {
        let o = this.manager.tooltipViews[s];
        return o.getCoords ? o.getCoords(n.pos) : this.view.coordsAtPos(n.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: n }) => n.getBoundingClientRect()),
      space: this.view.state.facet(ta).tooltipSpace(this.view),
      scaleX: e,
      scaleY: t,
      makeAbsolute: i
    };
  }
  writeMeasure(r) {
    var e;
    if (r.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let l of this.manager.tooltipViews)
        l.dom.style.position = "absolute";
    }
    let { editor: t, space: i, scaleX: n, scaleY: s } = r, o = [];
    for (let l = 0; l < this.manager.tooltips.length; l++) {
      let a = this.manager.tooltips[l], h = this.manager.tooltipViews[l], { dom: c } = h, u = r.pos[l], d = r.size[l];
      if (!u || u.bottom <= Math.max(t.top, i.top) || u.top >= Math.min(t.bottom, i.bottom) || u.right < Math.max(t.left, i.left) - 0.1 || u.left > Math.min(t.right, i.right) + 0.1) {
        c.style.top = On;
        continue;
      }
      let p = a.arrow ? h.dom.querySelector(".cm-tooltip-arrow") : null, f = p ? 7 : 0, m = d.right - d.left, g = (e = Vd.get(h)) !== null && e !== void 0 ? e : d.bottom - d.top, b = h.offset || Ix, v = this.view.textDirection == ce.LTR, k = d.width > i.right - i.left ? v ? i.left : i.right - d.width : v ? Math.min(u.left - (p ? 14 : 0) + b.x, i.right - m) : Math.max(i.left, u.left - m + (p ? 14 : 0) - b.x), $ = this.above[l];
      !a.strictSide && ($ ? u.top - (d.bottom - d.top) - b.y < i.top : u.bottom + (d.bottom - d.top) + b.y > i.bottom) && $ == i.bottom - u.bottom > u.top - i.top && ($ = this.above[l] = !$);
      let x = ($ ? u.top - i.top : i.bottom - u.bottom) - f;
      if (x < g && h.resize !== !1) {
        if (x < this.view.defaultLineHeight) {
          c.style.top = On;
          continue;
        }
        Vd.set(h, g), c.style.height = (g = x) / s + "px";
      } else
        c.style.height && (c.style.height = "");
      let Q = $ ? u.top - g - f - b.y : u.bottom + f + b.y, P = k + m;
      if (h.overlap !== !0)
        for (let z of o)
          z.left < P && z.right > k && z.top < Q + g && z.bottom > Q && (Q = $ ? z.top - g - 2 - f : z.bottom + f + 2);
      if (this.position == "absolute" ? (c.style.top = (Q - r.parent.top) / s + "px", c.style.left = (k - r.parent.left) / n + "px") : (c.style.top = Q / s + "px", c.style.left = k / n + "px"), p) {
        let z = u.left + (v ? b.x : -b.x) - (k + 14 - 7);
        p.style.left = z / n + "px";
      }
      h.overlap !== !0 && o.push({ left: k, top: Q, right: P, bottom: Q + g }), c.classList.toggle("cm-tooltip-above", $), c.classList.toggle("cm-tooltip-below", !$), h.positioned && h.positioned(r.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let r of this.manager.tooltipViews)
        r.dom.style.top = On;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
}), Dx = /* @__PURE__ */ Z.baseTheme({
  ".cm-tooltip": {
    zIndex: 100,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), Ix = { x: 0, y: 0 }, vc = /* @__PURE__ */ _.define({
  enables: [yc, Dx]
}), Ao = /* @__PURE__ */ _.define();
class Ol {
  // Needs to be static so that host tooltip instances always match
  static create(e) {
    return new Ol(e);
  }
  constructor(e) {
    this.view = e, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new Am(e, Ao, (t) => this.createHostedView(t));
  }
  createHostedView(e) {
    let t = e.create(this.view);
    return t.dom.classList.add("cm-tooltip-section"), this.dom.appendChild(t.dom), this.mounted && t.mount && t.mount(this.view), t;
  }
  mount(e) {
    for (let t of this.manager.tooltipViews)
      t.mount && t.mount(e);
    this.mounted = !0;
  }
  positioned(e) {
    for (let t of this.manager.tooltipViews)
      t.positioned && t.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
  destroy() {
    var e;
    for (let t of this.manager.tooltipViews)
      (e = t.destroy) === null || e === void 0 || e.call(t);
  }
  passProp(e) {
    let t;
    for (let i of this.manager.tooltipViews) {
      let n = i[e];
      if (n !== void 0) {
        if (t === void 0)
          t = n;
        else if (t !== n)
          return;
      }
    }
    return t;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
}
const Ux = /* @__PURE__ */ vc.compute([Ao], (r) => {
  let e = r.facet(Ao).filter((t) => t);
  return e.length === 0 ? null : {
    pos: Math.min(...e.map((t) => t.pos)),
    end: Math.max(...e.map((t) => {
      var i;
      return (i = t.end) !== null && i !== void 0 ? i : t.pos;
    })),
    create: Ol.create,
    above: e[0].above,
    arrow: e.some((t) => t.arrow)
  };
});
class Gx {
  constructor(e, t, i, n, s) {
    this.view = e, this.source = t, this.field = i, this.setHover = n, this.hoverTime = s, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active)
      return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: e, lastMove: t } = this, i = e.docView.nearest(t.target);
    if (!i)
      return;
    let n, s = 1;
    if (i instanceof xr)
      n = i.posAtStart;
    else {
      if (n = e.posAtCoords(t), n == null)
        return;
      let l = e.coordsAtPos(n);
      if (!l || t.y < l.top || t.y > l.bottom || t.x < l.left - e.defaultCharacterWidth || t.x > l.right + e.defaultCharacterWidth)
        return;
      let a = e.bidiSpans(e.state.doc.lineAt(n)).find((c) => c.from <= n && c.to >= n), h = a && a.dir == ce.RTL ? -1 : 1;
      s = t.x < l.left ? -h : h;
    }
    let o = this.source(e, n, s);
    if (o != null && o.then) {
      let l = this.pending = { pos: n };
      o.then((a) => {
        this.pending == l && (this.pending = null, a && e.dispatch({ effects: this.setHover.of(a) }));
      }, (a) => gt(e.state, a, "hover tooltip"));
    } else
      o && e.dispatch({ effects: this.setHover.of(o) });
  }
  get tooltip() {
    let e = this.view.plugin(yc), t = e ? e.manager.tooltips.findIndex((i) => i.create == Ol.create) : -1;
    return t > -1 ? e.manager.tooltipViews[t] : null;
  }
  mousemove(e) {
    var t;
    this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let { active: i, tooltip: n } = this;
    if (i && n && !Nx(n.dom, e) || this.pending) {
      let { pos: s } = i || this.pending, o = (t = i == null ? void 0 : i.end) !== null && t !== void 0 ? t : s;
      (s == o ? this.view.posAtCoords(this.lastMove) != s : !Fx(this.view, s, o, e.clientX, e.clientY)) && (this.view.dispatch({ effects: this.setHover.of(null) }), this.pending = null);
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
    let { active: t } = this;
    if (t) {
      let { tooltip: i } = this;
      i && i.dom.contains(e.relatedTarget) ? this.watchTooltipLeave(i.dom) : this.view.dispatch({ effects: this.setHover.of(null) });
    }
  }
  watchTooltipLeave(e) {
    let t = (i) => {
      e.removeEventListener("mouseleave", t), this.active && !this.view.dom.contains(i.relatedTarget) && this.view.dispatch({ effects: this.setHover.of(null) });
    };
    e.addEventListener("mouseleave", t);
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
const Bs = 4;
function Nx(r, e) {
  let t = r.getBoundingClientRect();
  return e.clientX >= t.left - Bs && e.clientX <= t.right + Bs && e.clientY >= t.top - Bs && e.clientY <= t.bottom + Bs;
}
function Fx(r, e, t, i, n, s) {
  let o = r.scrollDOM.getBoundingClientRect(), l = r.documentTop + r.documentPadding.top + r.contentHeight;
  if (o.left > i || o.right < i || o.top > n || Math.min(o.bottom, l) < n)
    return !1;
  let a = r.posAtCoords({ x: i, y: n }, !1);
  return a >= e && a <= t;
}
function Hx(r, e = {}) {
  let t = j.define(), i = Qe.define({
    create() {
      return null;
    },
    update(n, s) {
      if (n && (e.hideOnChange && (s.docChanged || s.selection) || e.hideOn && e.hideOn(s, n)))
        return null;
      if (n && s.docChanged) {
        let o = s.changes.mapPos(n.pos, -1, Xe.TrackDel);
        if (o == null)
          return null;
        let l = Object.assign(/* @__PURE__ */ Object.create(null), n);
        l.pos = o, n.end != null && (l.end = s.changes.mapPos(n.end)), n = l;
      }
      for (let o of s.effects)
        o.is(t) && (n = o.value), o.is(Kx) && (n = null);
      return n;
    },
    provide: (n) => Ao.from(n)
  });
  return [
    i,
    ge.define((n) => new Gx(
      n,
      r,
      i,
      t,
      e.hoverTime || 300
      /* Hover.Time */
    )),
    Ux
  ];
}
function Em(r, e) {
  let t = r.plugin(yc);
  if (!t)
    return null;
  let i = t.manager.tooltips.indexOf(e);
  return i < 0 ? null : t.manager.tooltipViews[i];
}
const Kx = /* @__PURE__ */ j.define(), Md = /* @__PURE__ */ _.define({
  combine(r) {
    let e, t;
    for (let i of r)
      e = e || i.topContainer, t = t || i.bottomContainer;
    return { topContainer: e, bottomContainer: t };
  }
});
function Kn(r, e) {
  let t = r.plugin(qm), i = t ? t.specs.indexOf(e) : -1;
  return i > -1 ? t.panels[i] : null;
}
const qm = /* @__PURE__ */ ge.fromClass(class {
  constructor(r) {
    this.input = r.state.facet(Jn), this.specs = this.input.filter((t) => t), this.panels = this.specs.map((t) => t(r));
    let e = r.state.facet(Md);
    this.top = new Ds(r, !0, e.topContainer), this.bottom = new Ds(r, !1, e.bottomContainer), this.top.sync(this.panels.filter((t) => t.top)), this.bottom.sync(this.panels.filter((t) => !t.top));
    for (let t of this.panels)
      t.dom.classList.add("cm-panel"), t.mount && t.mount();
  }
  update(r) {
    let e = r.state.facet(Md);
    this.top.container != e.topContainer && (this.top.sync([]), this.top = new Ds(r.view, !0, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new Ds(r.view, !1, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let t = r.state.facet(Jn);
    if (t != this.input) {
      let i = t.filter((a) => a), n = [], s = [], o = [], l = [];
      for (let a of i) {
        let h = this.specs.indexOf(a), c;
        h < 0 ? (c = a(r.view), l.push(c)) : (c = this.panels[h], c.update && c.update(r)), n.push(c), (c.top ? s : o).push(c);
      }
      this.specs = i, this.panels = n, this.top.sync(s), this.bottom.sync(o);
      for (let a of l)
        a.dom.classList.add("cm-panel"), a.mount && a.mount();
    } else
      for (let i of this.panels)
        i.update && i.update(r);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (r) => Z.scrollMargins.of((e) => {
    let t = e.plugin(r);
    return t && { top: t.top.scrollMargin(), bottom: t.bottom.scrollMargin() };
  })
});
class Ds {
  constructor(e, t, i) {
    this.view = e, this.top = t, this.container = i, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(e) {
    for (let t of this.panels)
      t.destroy && e.indexOf(t) < 0 && t.destroy();
    this.panels = e, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let t = this.container || this.view.dom;
      t.insertBefore(this.dom, this.top ? t.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let t of this.panels)
      if (t.dom.parentNode == this.dom) {
        for (; e != t.dom; )
          e = jd(e);
        e = e.nextSibling;
      } else
        this.dom.insertBefore(t.dom, e);
    for (; e; )
      e = jd(e);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" "))
        e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" "))
        e && this.container.classList.add(e);
    }
  }
}
function jd(r) {
  let e = r.nextSibling;
  return r.remove(), e;
}
const Jn = /* @__PURE__ */ _.define({
  enables: qm
});
class hr extends ci {
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e) {
  }
}
hr.prototype.elementClass = "";
hr.prototype.toDOM = void 0;
hr.prototype.mapMode = Xe.TrackBefore;
hr.prototype.startSide = hr.prototype.endSide = -1;
hr.prototype.point = !0;
const go = /* @__PURE__ */ _.define(), Jx = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => H.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
}, Yn = /* @__PURE__ */ _.define();
function eS(r) {
  return [zm(), Yn.of(Object.assign(Object.assign({}, Jx), r))];
}
const vh = /* @__PURE__ */ _.define({
  combine: (r) => r.some((e) => e)
});
function zm(r) {
  let e = [
    tS
  ];
  return r && r.fixed === !1 && e.push(vh.of(!0)), e;
}
const tS = /* @__PURE__ */ ge.fromClass(class {
  constructor(r) {
    this.view = r, this.prevViewport = r.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = r.state.facet(Yn).map((e) => new Bd(r, e));
    for (let e of this.gutters)
      this.dom.appendChild(e.dom);
    this.fixed = !r.state.facet(vh), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), r.scrollDOM.insertBefore(this.dom, r.contentDOM);
  }
  update(r) {
    if (this.updateGutters(r)) {
      let e = this.prevViewport, t = r.view.viewport, i = Math.min(e.to, t.to) - Math.max(e.from, t.from);
      this.syncGutters(i < (t.to - t.from) * 0.8);
    }
    r.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight + "px"), this.view.state.facet(vh) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = r.view.viewport;
  }
  syncGutters(r) {
    let e = this.dom.nextSibling;
    r && this.dom.remove();
    let t = H.iter(this.view.state.facet(go), this.view.viewport.from), i = [], n = this.gutters.map((s) => new rS(s, this.view.viewport, -this.view.documentPadding.top));
    for (let s of this.view.viewportLineBlocks)
      if (i.length && (i = []), Array.isArray(s.type)) {
        let o = !0;
        for (let l of s.type)
          if (l.type == Le.Text && o) {
            xh(t, i, l.from);
            for (let a of n)
              a.line(this.view, l, i);
            o = !1;
          } else if (l.widget)
            for (let a of n)
              a.widget(this.view, l);
      } else if (s.type == Le.Text) {
        xh(t, i, s.from);
        for (let o of n)
          o.line(this.view, s, i);
      } else if (s.widget)
        for (let o of n)
          o.widget(this.view, s);
    for (let s of n)
      s.finish();
    r && this.view.scrollDOM.insertBefore(this.dom, e);
  }
  updateGutters(r) {
    let e = r.startState.facet(Yn), t = r.state.facet(Yn), i = r.docChanged || r.heightChanged || r.viewportChanged || !H.eq(r.startState.facet(go), r.state.facet(go), r.view.viewport.from, r.view.viewport.to);
    if (e == t)
      for (let n of this.gutters)
        n.update(r) && (i = !0);
    else {
      i = !0;
      let n = [];
      for (let s of t) {
        let o = e.indexOf(s);
        o < 0 ? n.push(new Bd(this.view, s)) : (this.gutters[o].update(r), n.push(this.gutters[o]));
      }
      for (let s of this.gutters)
        s.dom.remove(), n.indexOf(s) < 0 && s.destroy();
      for (let s of n)
        this.dom.appendChild(s.dom);
      this.gutters = n;
    }
    return i;
  }
  destroy() {
    for (let r of this.gutters)
      r.destroy();
    this.dom.remove();
  }
}, {
  provide: (r) => Z.scrollMargins.of((e) => {
    let t = e.plugin(r);
    return !t || t.gutters.length == 0 || !t.fixed ? null : e.textDirection == ce.LTR ? { left: t.dom.offsetWidth * e.scaleX } : { right: t.dom.offsetWidth * e.scaleX };
  })
});
function Ld(r) {
  return Array.isArray(r) ? r : [r];
}
function xh(r, e, t) {
  for (; r.value && r.from <= t; )
    r.from == t && e.push(r.value), r.next();
}
class rS {
  constructor(e, t, i) {
    this.gutter = e, this.height = i, this.i = 0, this.cursor = H.iter(e.markers, t.from);
  }
  addElement(e, t, i) {
    let { gutter: n } = this, s = (t.top - this.height) / e.scaleY, o = t.height / e.scaleY;
    if (this.i == n.elements.length) {
      let l = new Ym(e, o, s, i);
      n.elements.push(l), n.dom.appendChild(l.dom);
    } else
      n.elements[this.i].update(e, o, s, i);
    this.height = t.bottom, this.i++;
  }
  line(e, t, i) {
    let n = [];
    xh(this.cursor, n, t.from), i.length && (n = n.concat(i));
    let s = this.gutter.config.lineMarker(e, t, n);
    s && n.unshift(s);
    let o = this.gutter;
    n.length == 0 && !o.config.renderEmptyElements || this.addElement(e, t, n);
  }
  widget(e, t) {
    let i = this.gutter.config.widgetMarker(e, t.widget, t);
    i && this.addElement(e, t, [i]);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let t = e.elements.pop();
      e.dom.removeChild(t.dom), t.destroy();
    }
  }
}
class Bd {
  constructor(e, t) {
    this.view = e, this.config = t, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let i in t.domEventHandlers)
      this.dom.addEventListener(i, (n) => {
        let s = n.target, o;
        if (s != this.dom && this.dom.contains(s)) {
          for (; s.parentNode != this.dom; )
            s = s.parentNode;
          let a = s.getBoundingClientRect();
          o = (a.top + a.bottom) / 2;
        } else
          o = n.clientY;
        let l = e.lineBlockAtHeight(o - e.documentTop);
        t.domEventHandlers[i](e, l, n) && n.preventDefault();
      });
    this.markers = Ld(t.markers(e)), t.initialSpacer && (this.spacer = new Ym(e, 0, 0, [t.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let t = this.markers;
    if (this.markers = Ld(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let n = this.config.updateSpacer(this.spacer.markers[0], e);
      n != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [n]);
    }
    let i = e.view.viewport;
    return !H.eq(this.markers, t, i.from, i.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
}
class Ym {
  constructor(e, t, i, n) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, t, i, n);
  }
  update(e, t, i, n) {
    this.height != t && (this.height = t, this.dom.style.height = t + "px"), this.above != i && (this.dom.style.marginTop = (this.above = i) ? i + "px" : ""), iS(this.markers, n) || this.setMarkers(e, n);
  }
  setMarkers(e, t) {
    let i = "cm-gutterElement", n = this.dom.firstChild;
    for (let s = 0, o = 0; ; ) {
      let l = o, a = s < t.length ? t[s++] : null, h = !1;
      if (a) {
        let c = a.elementClass;
        c && (i += " " + c);
        for (let u = o; u < this.markers.length; u++)
          if (this.markers[u].compare(a)) {
            l = u, h = !0;
            break;
          }
      } else
        l = this.markers.length;
      for (; o < l; ) {
        let c = this.markers[o++];
        if (c.toDOM) {
          c.destroy(n);
          let u = n.nextSibling;
          n.remove(), n = u;
        }
      }
      if (!a)
        break;
      a.toDOM && (h ? n = n.nextSibling : this.dom.insertBefore(a.toDOM(e), n)), h && o++;
    }
    this.dom.className = i, this.markers = t;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function iS(r, e) {
  if (r.length != e.length)
    return !1;
  for (let t = 0; t < r.length; t++)
    if (!r[t].compare(e[t]))
      return !1;
  return !0;
}
const nS = /* @__PURE__ */ _.define(), $i = /* @__PURE__ */ _.define({
  combine(r) {
    return _t(r, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, t) {
        let i = Object.assign({}, e);
        for (let n in t) {
          let s = i[n], o = t[n];
          i[n] = s ? (l, a, h) => s(l, a, h) || o(l, a, h) : o;
        }
        return i;
      }
    });
  }
});
class ra extends hr {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function ia(r, e) {
  return r.state.facet($i).formatNumber(e, r.state);
}
const sS = /* @__PURE__ */ Yn.compute([$i], (r) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(nS);
  },
  lineMarker(e, t, i) {
    return i.some((n) => n.toDOM) ? null : new ra(ia(e, e.state.doc.lineAt(t.from).number));
  },
  widgetMarker: () => null,
  lineMarkerChange: (e) => e.startState.facet($i) != e.state.facet($i),
  initialSpacer(e) {
    return new ra(ia(e, Dd(e.state.doc.lines)));
  },
  updateSpacer(e, t) {
    let i = ia(t.view, Dd(t.view.state.doc.lines));
    return i == e.number ? e : new ra(i);
  },
  domEventHandlers: r.facet($i).domEventHandlers
}));
function Cn(r = {}) {
  return [
    $i.of(r),
    zm(),
    sS
  ];
}
function Dd(r) {
  let e = 9;
  for (; e < r; )
    e = e * 10 + 9;
  return e;
}
const oS = /* @__PURE__ */ new class extends hr {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), lS = /* @__PURE__ */ go.compute(["selection"], (r) => {
  let e = [], t = -1;
  for (let i of r.selection.ranges) {
    let n = r.doc.lineAt(i.head).from;
    n > t && (t = n, e.push(oS.range(n)));
  }
  return H.of(e);
});
function aS() {
  return lS;
}
const Wm = 1024;
let hS = 0;
class ft {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
}
class Y {
  /**
  Create a new node prop type.
  */
  constructor(e = {}) {
    this.id = hS++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = ye.match(e)), (t) => {
      let i = e(t);
      return i === void 0 ? null : [this, i];
    };
  }
}
Y.closedBy = new Y({ deserialize: (r) => r.split(" ") });
Y.openedBy = new Y({ deserialize: (r) => r.split(" ") });
Y.group = new Y({ deserialize: (r) => r.split(" ") });
Y.isolate = new Y({ deserialize: (r) => {
  if (r && r != "rtl" && r != "ltr" && r != "auto")
    throw new RangeError("Invalid value for isolate: " + r);
  return r || "auto";
} });
Y.contextHash = new Y({ perNode: !0 });
Y.lookAhead = new Y({ perNode: !0 });
Y.mounted = new Y({ perNode: !0 });
class es {
  constructor(e, t, i) {
    this.tree = e, this.overlay = t, this.parser = i;
  }
  /**
  @internal
  */
  static get(e) {
    return e && e.props && e.props[Y.mounted.id];
  }
}
const cS = /* @__PURE__ */ Object.create(null);
class ye {
  /**
  @internal
  */
  constructor(e, t, i, n = 0) {
    this.name = e, this.props = t, this.id = i, this.flags = n;
  }
  /**
  Define a node type.
  */
  static define(e) {
    let t = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : cS, i = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), n = new ye(e.name || "", t, e.id, i);
    if (e.props) {
      for (let s of e.props)
        if (Array.isArray(s) || (s = s(n)), s) {
          if (s[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          t[s[0].id] = s[1];
        }
    }
    return n;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(e) {
    return this.props[e.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return !0;
      let t = this.prop(Y.group);
      return t ? t.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(e) {
    let t = /* @__PURE__ */ Object.create(null);
    for (let i in e)
      for (let n of i.split(" "))
        t[n] = e[i];
    return (i) => {
      for (let n = i.prop(Y.group), s = -1; s < (n ? n.length : 0); s++) {
        let o = t[s < 0 ? i.name : n[s]];
        if (o)
          return o;
      }
    };
  }
}
ye.none = new ye(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class rn {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(e) {
    this.types = e;
    for (let t = 0; t < e.length; t++)
      if (e[t].id != t)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...e) {
    let t = [];
    for (let i of this.types) {
      let n = null;
      for (let s of e) {
        let o = s(i);
        o && (n || (n = Object.assign({}, i.props)), n[o[0].id] = o[1]);
      }
      t.push(n ? new ye(i.name, n, i.id, i.flags) : i);
    }
    return new rn(t);
  }
}
const Is = /* @__PURE__ */ new WeakMap(), Id = /* @__PURE__ */ new WeakMap();
var ne;
(function(r) {
  r[r.ExcludeBuffers = 1] = "ExcludeBuffers", r[r.IncludeAnonymous = 2] = "IncludeAnonymous", r[r.IgnoreMounts = 4] = "IgnoreMounts", r[r.IgnoreOverlays = 8] = "IgnoreOverlays";
})(ne || (ne = {}));
class D {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(e, t, i, n, s) {
    if (this.type = e, this.children = t, this.positions = i, this.length = n, this.props = null, s && s.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [o, l] of s)
        this.props[typeof o == "number" ? o : o.id] = l;
    }
  }
  /**
  @internal
  */
  toString() {
    let e = es.get(this);
    if (e && !e.overlay)
      return e.tree.toString();
    let t = "";
    for (let i of this.children) {
      let n = i.toString();
      n && (t && (t += ","), t += n);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (t.length ? "(" + t + ")" : "") : t;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(e = 0) {
    return new Eo(this.topNode, e);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(e, t = 0, i = 0) {
    let n = Is.get(this) || this.topNode, s = new Eo(n);
    return s.moveTo(e, t), Is.set(this, s._tree), s;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new Ye(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(e, t = 0) {
    let i = ts(Is.get(this) || this.topNode, e, t, !1);
    return Is.set(this, i), i;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(e, t = 0) {
    let i = ts(Id.get(this) || this.topNode, e, t, !0);
    return Id.set(this, i), i;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(e, t = 0) {
    return pS(this, e, t);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(e) {
    let { enter: t, leave: i, from: n = 0, to: s = this.length } = e, o = e.mode || 0, l = (o & ne.IncludeAnonymous) > 0;
    for (let a = this.cursor(o | ne.IncludeAnonymous); ; ) {
      let h = !1;
      if (a.from <= s && a.to >= n && (!l && a.type.isAnonymous || t(a) !== !1)) {
        if (a.firstChild())
          continue;
        h = !0;
      }
      for (; h && i && (l || !a.type.isAnonymous) && i(a), !a.nextSibling(); ) {
        if (!a.parent())
          return;
        h = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let e = [];
    if (this.props)
      for (let t in this.props)
        e.push([+t, this.props[t]]);
    return e;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(e = {}) {
    return this.children.length <= 8 ? this : kc(ye.none, this.children, this.positions, 0, this.children.length, 0, this.length, (t, i, n) => new D(this.type, t, i, n, this.propValues), e.makeTree || ((t, i, n) => new D(ye.none, t, i, n)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(e) {
    return fS(e);
  }
}
D.empty = new D(ye.none, [], [], 0);
class xc {
  constructor(e, t) {
    this.buffer = e, this.index = t;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new xc(this.buffer, this.index);
  }
}
class Yr {
  /**
  Create a tree buffer.
  */
  constructor(e, t, i) {
    this.buffer = e, this.length = t, this.set = i;
  }
  /**
  @internal
  */
  get type() {
    return ye.none;
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    for (let t = 0; t < this.buffer.length; )
      e.push(this.childString(t)), t = this.buffer[t + 3];
    return e.join(",");
  }
  /**
  @internal
  */
  childString(e) {
    let t = this.buffer[e], i = this.buffer[e + 3], n = this.set.types[t], s = n.name;
    if (/\W/.test(s) && !n.isError && (s = JSON.stringify(s)), e += 4, i == e)
      return s;
    let o = [];
    for (; e < i; )
      o.push(this.childString(e)), e = this.buffer[e + 3];
    return s + "(" + o.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(e, t, i, n, s) {
    let { buffer: o } = this, l = -1;
    for (let a = e; a != t && !(Vm(s, n, o[a + 1], o[a + 2]) && (l = a, i > 0)); a = o[a + 3])
      ;
    return l;
  }
  /**
  @internal
  */
  slice(e, t, i) {
    let n = this.buffer, s = new Uint16Array(t - e), o = 0;
    for (let l = e, a = 0; l < t; ) {
      s[a++] = n[l++], s[a++] = n[l++] - i;
      let h = s[a++] = n[l++] - i;
      s[a++] = n[l++] - e, o = Math.max(o, h);
    }
    return new Yr(s, o, this.set);
  }
}
function Vm(r, e, t, i) {
  switch (r) {
    case -2:
      return t < e;
    case -1:
      return i >= e && t < e;
    case 0:
      return t < e && i > e;
    case 1:
      return t <= e && i > e;
    case 2:
      return i > e;
    case 4:
      return !0;
  }
}
function ts(r, e, t, i) {
  for (var n; r.from == r.to || (t < 1 ? r.from >= e : r.from > e) || (t > -1 ? r.to <= e : r.to < e); ) {
    let o = !i && r instanceof Ye && r.index < 0 ? null : r.parent;
    if (!o)
      return r;
    r = o;
  }
  let s = i ? 0 : ne.IgnoreOverlays;
  if (i)
    for (let o = r, l = o.parent; l; o = l, l = o.parent)
      o instanceof Ye && o.index < 0 && ((n = l.enter(e, t, s)) === null || n === void 0 ? void 0 : n.from) != o.from && (r = l);
  for (; ; ) {
    let o = r.enter(e, t, s);
    if (!o)
      return r;
    r = o;
  }
}
class Mm {
  cursor(e = 0) {
    return new Eo(this, e);
  }
  getChild(e, t = null, i = null) {
    let n = Ud(this, e, t, i);
    return n.length ? n[0] : null;
  }
  getChildren(e, t = null, i = null) {
    return Ud(this, e, t, i);
  }
  resolve(e, t = 0) {
    return ts(this, e, t, !1);
  }
  resolveInner(e, t = 0) {
    return ts(this, e, t, !0);
  }
  matchContext(e) {
    return Sh(this, e);
  }
  enterUnfinishedNodesBefore(e) {
    let t = this.childBefore(e), i = this;
    for (; t; ) {
      let n = t.lastChild;
      if (!n || n.to != t.to)
        break;
      n.type.isError && n.from == n.to ? (i = t, t = n.prevSibling) : t = n;
    }
    return i;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class Ye extends Mm {
  constructor(e, t, i, n) {
    super(), this._tree = e, this.from = t, this.index = i, this._parent = n;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, t, i, n, s = 0) {
    for (let o = this; ; ) {
      for (let { children: l, positions: a } = o._tree, h = t > 0 ? l.length : -1; e != h; e += t) {
        let c = l[e], u = a[e] + o.from;
        if (Vm(n, i, u, u + c.length)) {
          if (c instanceof Yr) {
            if (s & ne.ExcludeBuffers)
              continue;
            let d = c.findChild(0, c.buffer.length, t, i - u, n);
            if (d > -1)
              return new Lt(new uS(o, c, e, u), null, d);
          } else if (s & ne.IncludeAnonymous || !c.type.isAnonymous || Sc(c)) {
            let d;
            if (!(s & ne.IgnoreMounts) && (d = es.get(c)) && !d.overlay)
              return new Ye(d.tree, u, e, o);
            let p = new Ye(c, u, e, o);
            return s & ne.IncludeAnonymous || !p.type.isAnonymous ? p : p.nextChild(t < 0 ? c.children.length - 1 : 0, t, i, n);
          }
        }
      }
      if (s & ne.IncludeAnonymous || !o.type.isAnonymous || (o.index >= 0 ? e = o.index + t : e = t < 0 ? -1 : o._parent._tree.children.length, o = o._parent, !o))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.nextChild(
      0,
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, t, i = 0) {
    let n;
    if (!(i & ne.IgnoreOverlays) && (n = es.get(this._tree)) && n.overlay) {
      let s = e - this.from;
      for (let { from: o, to: l } of n.overlay)
        if ((t > 0 ? o <= s : o < s) && (t < 0 ? l >= s : l > s))
          return new Ye(n.tree, n.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, t, i);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}
function Ud(r, e, t, i) {
  let n = r.cursor(), s = [];
  if (!n.firstChild())
    return s;
  if (t != null) {
    for (let o = !1; !o; )
      if (o = n.type.is(t), !n.nextSibling())
        return s;
  }
  for (; ; ) {
    if (i != null && n.type.is(i))
      return s;
    if (n.type.is(e) && s.push(n.node), !n.nextSibling())
      return i == null ? s : [];
  }
}
function Sh(r, e, t = e.length - 1) {
  for (let i = r.parent; t >= 0; i = i.parent) {
    if (!i)
      return !1;
    if (!i.type.isAnonymous) {
      if (e[t] && e[t] != i.name)
        return !1;
      t--;
    }
  }
  return !0;
}
class uS {
  constructor(e, t, i, n) {
    this.parent = e, this.buffer = t, this.index = i, this.start = n;
  }
}
class Lt extends Mm {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, t, i) {
    super(), this.context = e, this._parent = t, this.index = i, this.type = e.buffer.set.types[e.buffer.buffer[i]];
  }
  child(e, t, i) {
    let { buffer: n } = this.context, s = n.findChild(this.index + 4, n.buffer[this.index + 3], e, t - this.context.start, i);
    return s < 0 ? null : new Lt(this.context, this, s);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.child(
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.child(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, t, i = 0) {
    if (i & ne.ExcludeBuffers)
      return null;
    let { buffer: n } = this.context, s = n.findChild(this.index + 4, n.buffer[this.index + 3], t > 0 ? 1 : -1, e - this.context.start, t);
    return s < 0 ? null : new Lt(this.context, this, s);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e,
      e,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e } = this.context, t = e.buffer[this.index + 3];
    return t < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new Lt(this.context, this._parent, t) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, t = this._parent ? this._parent.index + 4 : 0;
    return this.index == t ? this.externalSibling(-1) : new Lt(this.context, this._parent, e.findChild(
      t,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], t = [], { buffer: i } = this.context, n = this.index + 4, s = i.buffer[this.index + 3];
    if (s > n) {
      let o = i.buffer[this.index + 1];
      e.push(i.slice(n, s, o)), t.push(0);
    }
    return new D(this.type, e, t, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function jm(r) {
  if (!r.length)
    return null;
  let e = 0, t = r[0];
  for (let s = 1; s < r.length; s++) {
    let o = r[s];
    (o.from > t.from || o.to < t.to) && (t = o, e = s);
  }
  let i = t instanceof Ye && t.index < 0 ? null : t.parent, n = r.slice();
  return i ? n[e] = i : n.splice(e, 1), new dS(n, t);
}
class dS {
  constructor(e, t) {
    this.heads = e, this.node = t;
  }
  get next() {
    return jm(this.heads);
  }
}
function pS(r, e, t) {
  let i = r.resolveInner(e, t), n = null;
  for (let s = i instanceof Ye ? i : i.context.parent; s; s = s.parent)
    if (s.index < 0) {
      let o = s.parent;
      (n || (n = [i])).push(o.resolve(e, t)), s = o;
    } else {
      let o = es.get(s.tree);
      if (o && o.overlay && o.overlay[0].from <= e && o.overlay[o.overlay.length - 1].to >= e) {
        let l = new Ye(o.tree, o.overlay[0].from + s.from, -1, s);
        (n || (n = [i])).push(ts(l, e, t, !1));
      }
    }
  return n ? jm(n) : i;
}
class Eo {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(e, t = 0) {
    if (this.mode = t, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof Ye)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let i = e._parent; i; i = i._parent)
        this.stack.unshift(i.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1;
  }
  yieldBuf(e, t) {
    this.index = e;
    let { start: i, buffer: n } = this.buffer;
    return this.type = t || n.set.types[n.buffer[e]], this.from = i + n.buffer[e + 1], this.to = i + n.buffer[e + 2], !0;
  }
  /**
  @internal
  */
  yield(e) {
    return e ? e instanceof Ye ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(e, t, i) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, t, i, this.mode));
    let { buffer: n } = this.buffer, s = n.findChild(this.index + 4, n.buffer[this.index + 3], e, t - this.buffer.start, i);
    return s < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(s));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(e) {
    return this.enterChild(
      1,
      e,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(e) {
    return this.enterChild(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(e, t, i = this.mode) {
    return this.buffer ? i & ne.ExcludeBuffers ? !1 : this.enterChild(1, e, t) : this.yield(this._tree.enter(e, t, i));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & ne.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & ne.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  /**
  @internal
  */
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;
    let { buffer: t } = this.buffer, i = this.stack.length - 1;
    if (e < 0) {
      let n = i < 0 ? 0 : this.stack[i] + 4;
      if (this.index != n)
        return this.yieldBuf(t.findChild(
          n,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let n = t.buffer[this.index + 3];
      if (n < (i < 0 ? t.buffer.length : t.buffer[this.stack[i] + 3]))
        return this.yieldBuf(n);
    }
    return i < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let t, i, { buffer: n } = this;
    if (n) {
      if (e > 0) {
        if (this.index < n.buffer.buffer.length)
          return !1;
      } else
        for (let s = 0; s < this.index; s++)
          if (n.buffer.buffer[s + 3] < this.index)
            return !1;
      ({ index: t, parent: i } = n);
    } else
      ({ index: t, _parent: i } = this._tree);
    for (; i; { index: t, _parent: i } = i)
      if (t > -1)
        for (let s = t + e, o = e < 0 ? -1 : i._tree.children.length; s != o; s += e) {
          let l = i._tree.children[s];
          if (this.mode & ne.IncludeAnonymous || l instanceof Yr || !l.type.isAnonymous || Sc(l))
            return !1;
        }
    return !0;
  }
  move(e, t) {
    if (t && this.enterChild(
      e,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(e))
        return !0;
      if (this.atLastNode(e) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(e = !0) {
    return this.move(1, e);
  }
  /**
  Move to the next node in a last-to-first pre-order traveral. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(e = !0) {
    return this.move(-1, e);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(e, t = 0) {
    for (; (this.from == this.to || (t < 1 ? this.from >= e : this.from > e) || (t > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, t); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, t = null, i = 0;
    if (e && e.context == this.buffer)
      e:
        for (let n = this.index, s = this.stack.length; s >= 0; ) {
          for (let o = e; o; o = o._parent)
            if (o.index == n) {
              if (n == this.index)
                return o;
              t = o, i = s + 1;
              break e;
            }
          n = this.stack[--s];
        }
    for (let n = i; n < this.stack.length; n++)
      t = new Lt(this.buffer, t, this.stack[n]);
    return this.bufferNode = new Lt(this.buffer, t, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(e, t) {
    for (let i = 0; ; ) {
      let n = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          i++;
          continue;
        }
        this.type.isAnonymous || (n = !0);
      }
      for (; n && t && t(this), n = this.type.isAnonymous, !this.nextSibling(); ) {
        if (!i)
          return;
        this.parent(), i--, n = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given context—a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(e) {
    if (!this.buffer)
      return Sh(this.node, e);
    let { buffer: t } = this.buffer, { types: i } = t.set;
    for (let n = e.length - 1, s = this.stack.length - 1; n >= 0; s--) {
      if (s < 0)
        return Sh(this.node, e, n);
      let o = i[t.buffer[this.stack[s]]];
      if (!o.isAnonymous) {
        if (e[n] && e[n] != o.name)
          return !1;
        n--;
      }
    }
    return !0;
  }
}
function Sc(r) {
  return r.children.some((e) => e instanceof Yr || !e.type.isAnonymous || Sc(e));
}
function fS(r) {
  var e;
  let { buffer: t, nodeSet: i, maxBufferLength: n = Wm, reused: s = [], minRepeatType: o = i.types.length } = r, l = Array.isArray(t) ? new xc(t, t.length) : t, a = i.types, h = 0, c = 0;
  function u(x, Q, P, z, V, L) {
    let { id: M, start: q, end: F, size: W } = l, G = c;
    for (; W < 0; )
      if (l.next(), W == -1) {
        let xe = s[M];
        P.push(xe), z.push(q - x);
        return;
      } else if (W == -3) {
        h = M;
        return;
      } else if (W == -4) {
        c = M;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${W}`);
    let le = a[M], ue, Me, ht = q - x;
    if (F - q <= n && (Me = g(l.pos - Q, V))) {
      let xe = new Uint16Array(Me.size - Me.skip), ct = l.pos - Me.size, At = xe.length;
      for (; l.pos > ct; )
        At = b(Me.start, xe, At);
      ue = new Yr(xe, F - Me.start, i), ht = Me.start - x;
    } else {
      let xe = l.pos - W;
      l.next();
      let ct = [], At = [], Ur = M >= o ? M : -1, bi = 0, Cs = F;
      for (; l.pos > xe; )
        Ur >= 0 && l.id == Ur && l.size >= 0 ? (l.end <= Cs - n && (f(ct, At, q, bi, l.end, Cs, Ur, G), bi = ct.length, Cs = l.end), l.next()) : L > 2500 ? d(q, xe, ct, At) : u(q, xe, ct, At, Ur, L + 1);
      if (Ur >= 0 && bi > 0 && bi < ct.length && f(ct, At, q, bi, q, Cs, Ur, G), ct.reverse(), At.reverse(), Ur > -1 && bi > 0) {
        let fu = p(le);
        ue = kc(le, ct, At, 0, ct.length, 0, F - q, fu, fu);
      } else
        ue = m(le, ct, At, F - q, G - F);
    }
    P.push(ue), z.push(ht);
  }
  function d(x, Q, P, z) {
    let V = [], L = 0, M = -1;
    for (; l.pos > Q; ) {
      let { id: q, start: F, end: W, size: G } = l;
      if (G > 4)
        l.next();
      else {
        if (M > -1 && F < M)
          break;
        M < 0 && (M = W - n), V.push(q, F, W), L++, l.next();
      }
    }
    if (L) {
      let q = new Uint16Array(L * 4), F = V[V.length - 2];
      for (let W = V.length - 3, G = 0; W >= 0; W -= 3)
        q[G++] = V[W], q[G++] = V[W + 1] - F, q[G++] = V[W + 2] - F, q[G++] = G;
      P.push(new Yr(q, V[2] - F, i)), z.push(F - x);
    }
  }
  function p(x) {
    return (Q, P, z) => {
      let V = 0, L = Q.length - 1, M, q;
      if (L >= 0 && (M = Q[L]) instanceof D) {
        if (!L && M.type == x && M.length == z)
          return M;
        (q = M.prop(Y.lookAhead)) && (V = P[L] + M.length + q);
      }
      return m(x, Q, P, z, V);
    };
  }
  function f(x, Q, P, z, V, L, M, q) {
    let F = [], W = [];
    for (; x.length > z; )
      F.push(x.pop()), W.push(Q.pop() + P - V);
    x.push(m(i.types[M], F, W, L - V, q - L)), Q.push(V - P);
  }
  function m(x, Q, P, z, V = 0, L) {
    if (h) {
      let M = [Y.contextHash, h];
      L = L ? [M].concat(L) : [M];
    }
    if (V > 25) {
      let M = [Y.lookAhead, V];
      L = L ? [M].concat(L) : [M];
    }
    return new D(x, Q, P, z, L);
  }
  function g(x, Q) {
    let P = l.fork(), z = 0, V = 0, L = 0, M = P.end - n, q = { size: 0, start: 0, skip: 0 };
    e:
      for (let F = P.pos - x; P.pos > F; ) {
        let W = P.size;
        if (P.id == Q && W >= 0) {
          q.size = z, q.start = V, q.skip = L, L += 4, z += 4, P.next();
          continue;
        }
        let G = P.pos - W;
        if (W < 0 || G < F || P.start < M)
          break;
        let le = P.id >= o ? 4 : 0, ue = P.start;
        for (P.next(); P.pos > G; ) {
          if (P.size < 0)
            if (P.size == -3)
              le += 4;
            else
              break e;
          else
            P.id >= o && (le += 4);
          P.next();
        }
        V = ue, z += W, L += le;
      }
    return (Q < 0 || z == x) && (q.size = z, q.start = V, q.skip = L), q.size > 4 ? q : void 0;
  }
  function b(x, Q, P) {
    let { id: z, start: V, end: L, size: M } = l;
    if (l.next(), M >= 0 && z < o) {
      let q = P;
      if (M > 4) {
        let F = l.pos - (M - 4);
        for (; l.pos > F; )
          P = b(x, Q, P);
      }
      Q[--P] = q, Q[--P] = L - x, Q[--P] = V - x, Q[--P] = z;
    } else
      M == -3 ? h = z : M == -4 && (c = z);
    return P;
  }
  let v = [], k = [];
  for (; l.pos > 0; )
    u(r.start || 0, r.bufferStart || 0, v, k, -1, 0);
  let $ = (e = r.length) !== null && e !== void 0 ? e : v.length ? k[0] + v[0].length : 0;
  return new D(a[r.topID], v.reverse(), k.reverse(), $);
}
const Gd = /* @__PURE__ */ new WeakMap();
function bo(r, e) {
  if (!r.isAnonymous || e instanceof Yr || e.type != r)
    return 1;
  let t = Gd.get(e);
  if (t == null) {
    t = 1;
    for (let i of e.children) {
      if (i.type != r || !(i instanceof D)) {
        t = 1;
        break;
      }
      t += bo(r, i);
    }
    Gd.set(e, t);
  }
  return t;
}
function kc(r, e, t, i, n, s, o, l, a) {
  let h = 0;
  for (let f = i; f < n; f++)
    h += bo(r, e[f]);
  let c = Math.ceil(
    h * 1.5 / 8
    /* Balance.BranchFactor */
  ), u = [], d = [];
  function p(f, m, g, b, v) {
    for (let k = g; k < b; ) {
      let $ = k, x = m[k], Q = bo(r, f[k]);
      for (k++; k < b; k++) {
        let P = bo(r, f[k]);
        if (Q + P >= c)
          break;
        Q += P;
      }
      if (k == $ + 1) {
        if (Q > c) {
          let P = f[$];
          p(P.children, P.positions, 0, P.children.length, m[$] + v);
          continue;
        }
        u.push(f[$]);
      } else {
        let P = m[k - 1] + f[k - 1].length - x;
        u.push(kc(r, f, m, $, k, x, P, null, a));
      }
      d.push(x + v - s);
    }
  }
  return p(e, t, i, n, 0), (l || a)(u, d, o);
}
class $c {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(e, t, i) {
    let n = this.map.get(e);
    n || this.map.set(e, n = /* @__PURE__ */ new Map()), n.set(t, i);
  }
  getBuffer(e, t) {
    let i = this.map.get(e);
    return i && i.get(t);
  }
  /**
  Set the value for this syntax node.
  */
  set(e, t) {
    e instanceof Lt ? this.setBuffer(e.context.buffer, e.index, t) : e instanceof Ye && this.map.set(e.tree, t);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(e) {
    return e instanceof Lt ? this.getBuffer(e.context.buffer, e.index) : e instanceof Ye ? this.map.get(e.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(e, t) {
    e.buffer ? this.setBuffer(e.buffer.buffer, e.index, t) : this.map.set(e.tree, t);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(e) {
    return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree);
  }
}
class ir {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(e, t, i, n, s = !1, o = !1) {
    this.from = e, this.to = t, this.tree = i, this.offset = n, this.open = (s ? 1 : 0) | (o ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(e, t = [], i = !1) {
    let n = [new ir(0, e.length, e, 0, !1, i)];
    for (let s of t)
      s.to > e.length && n.push(s);
    return n;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(e, t, i = 128) {
    if (!t.length)
      return e;
    let n = [], s = 1, o = e.length ? e[0] : null;
    for (let l = 0, a = 0, h = 0; ; l++) {
      let c = l < t.length ? t[l] : null, u = c ? c.fromA : 1e9;
      if (u - a >= i)
        for (; o && o.from < u; ) {
          let d = o;
          if (a >= d.from || u <= d.to || h) {
            let p = Math.max(d.from, a) - h, f = Math.min(d.to, u) - h;
            d = p >= f ? null : new ir(p, f, d.tree, d.offset + h, l > 0, !!c);
          }
          if (d && n.push(d), o.to > u)
            break;
          o = s < e.length ? e[s++] : null;
        }
      if (!c)
        break;
      a = c.toA, h = c.toA - c.toB;
    }
    return n;
  }
}
class ml {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(e, t, i) {
    return typeof e == "string" && (e = new OS(e)), i = i ? i.length ? i.map((n) => new ft(n.from, n.to)) : [new ft(0, 0)] : [new ft(0, e.length)], this.createParse(e, t || [], i);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(e, t, i) {
    let n = this.startParse(e, t, i);
    for (; ; ) {
      let s = n.advance();
      if (s)
        return s;
    }
  }
}
class OS {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, t) {
    return this.string.slice(e, t);
  }
}
function Lm(r) {
  return (e, t, i, n) => new gS(e, r, t, i, n);
}
class Nd {
  constructor(e, t, i, n, s) {
    this.parser = e, this.parse = t, this.overlay = i, this.target = n, this.from = s;
  }
}
function Fd(r) {
  if (!r.length || r.some((e) => e.from >= e.to))
    throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(r));
}
class mS {
  constructor(e, t, i, n, s, o, l) {
    this.parser = e, this.predicate = t, this.mounts = i, this.index = n, this.start = s, this.target = o, this.prev = l, this.depth = 0, this.ranges = [];
  }
}
const kh = new Y({ perNode: !0 });
class gS {
  constructor(e, t, i, n, s) {
    this.nest = t, this.input = i, this.fragments = n, this.ranges = s, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = e;
  }
  advance() {
    if (this.baseParse) {
      let i = this.baseParse.advance();
      if (!i)
        return null;
      if (this.baseParse = null, this.baseTree = i, this.startInner(), this.stoppedAt != null)
        for (let n of this.inner)
          n.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let i = this.baseTree;
      return this.stoppedAt != null && (i = new D(i.type, i.children, i.positions, i.length, i.propValues.concat([[kh, this.stoppedAt]]))), i;
    }
    let e = this.inner[this.innerDone], t = e.parse.advance();
    if (t) {
      this.innerDone++;
      let i = Object.assign(/* @__PURE__ */ Object.create(null), e.target.props);
      i[Y.mounted.id] = new es(t, e.overlay, e.parser), e.target.props = i;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let e = this.input.length;
    for (let t = this.innerDone; t < this.inner.length; t++)
      this.inner[t].from < e && (e = Math.min(e, this.inner[t].parse.parsedPos));
    return e;
  }
  stopAt(e) {
    if (this.stoppedAt = e, this.baseParse)
      this.baseParse.stopAt(e);
    else
      for (let t = this.innerDone; t < this.inner.length; t++)
        this.inner[t].parse.stopAt(e);
  }
  startInner() {
    let e = new yS(this.fragments), t = null, i = null, n = new Eo(new Ye(this.baseTree, this.ranges[0].from, 0, null), ne.IncludeAnonymous | ne.IgnoreMounts);
    e:
      for (let s, o; ; ) {
        let l = !0, a;
        if (this.stoppedAt != null && n.from >= this.stoppedAt)
          l = !1;
        else if (e.hasNode(n)) {
          if (t) {
            let h = t.mounts.find((c) => c.frag.from <= n.from && c.frag.to >= n.to && c.mount.overlay);
            if (h)
              for (let c of h.mount.overlay) {
                let u = c.from + h.pos, d = c.to + h.pos;
                u >= n.from && d <= n.to && !t.ranges.some((p) => p.from < d && p.to > u) && t.ranges.push({ from: u, to: d });
              }
          }
          l = !1;
        } else if (i && (o = bS(i.ranges, n.from, n.to)))
          l = o != 2;
        else if (!n.type.isAnonymous && (s = this.nest(n, this.input)) && (n.from < n.to || !s.overlay)) {
          n.tree || wS(n);
          let h = e.findMounts(n.from, s.parser);
          if (typeof s.overlay == "function")
            t = new mS(s.parser, s.overlay, h, this.inner.length, n.from, n.tree, t);
          else {
            let c = Jd(this.ranges, s.overlay || (n.from < n.to ? [new ft(n.from, n.to)] : []));
            c.length && Fd(c), (c.length || !s.overlay) && this.inner.push(new Nd(s.parser, c.length ? s.parser.startParse(this.input, ep(h, c), c) : s.parser.startParse(""), s.overlay ? s.overlay.map((u) => new ft(u.from - n.from, u.to - n.from)) : null, n.tree, c.length ? c[0].from : n.from)), s.overlay ? c.length && (i = { ranges: c, depth: 0, prev: i }) : l = !1;
          }
        } else
          t && (a = t.predicate(n)) && (a === !0 && (a = new ft(n.from, n.to)), a.from < a.to && t.ranges.push(a));
        if (l && n.firstChild())
          t && t.depth++, i && i.depth++;
        else
          for (; !n.nextSibling(); ) {
            if (!n.parent())
              break e;
            if (t && !--t.depth) {
              let h = Jd(this.ranges, t.ranges);
              h.length && (Fd(h), this.inner.splice(t.index, 0, new Nd(t.parser, t.parser.startParse(this.input, ep(t.mounts, h), h), t.ranges.map((c) => new ft(c.from - t.start, c.to - t.start)), t.target, h[0].from))), t = t.prev;
            }
            i && !--i.depth && (i = i.prev);
          }
      }
  }
}
function bS(r, e, t) {
  for (let i of r) {
    if (i.from >= t)
      break;
    if (i.to > e)
      return i.from <= e && i.to >= t ? 2 : 1;
  }
  return 0;
}
function Hd(r, e, t, i, n, s) {
  if (e < t) {
    let o = r.buffer[e + 1];
    i.push(r.slice(e, t, o)), n.push(o - s);
  }
}
function wS(r) {
  let { node: e } = r, t = [], i = e.context.buffer;
  do
    t.push(r.index), r.parent();
  while (!r.tree);
  let n = r.tree, s = n.children.indexOf(i), o = n.children[s], l = o.buffer, a = [s];
  function h(c, u, d, p, f, m) {
    let g = t[m], b = [], v = [];
    Hd(o, c, g, b, v, p);
    let k = l[g + 1], $ = l[g + 2];
    a.push(b.length);
    let x = m ? h(g + 4, l[g + 3], o.set.types[l[g]], k, $ - k, m - 1) : e.toTree();
    return b.push(x), v.push(k - p), Hd(o, l[g + 3], u, b, v, p), new D(d, b, v, f);
  }
  n.children[s] = h(0, l.length, ye.none, 0, o.length, t.length - 1);
  for (let c of a) {
    let u = r.tree.children[c], d = r.tree.positions[c];
    r.yield(new Ye(u, d + r.from, c, r._tree));
  }
}
class Kd {
  constructor(e, t) {
    this.offset = t, this.done = !1, this.cursor = e.cursor(ne.IncludeAnonymous | ne.IgnoreMounts);
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(e) {
    let { cursor: t } = this, i = e - this.offset;
    for (; !this.done && t.from < i; )
      t.to >= e && t.enter(i, 1, ne.IgnoreOverlays | ne.ExcludeBuffers) || t.next(!1) || (this.done = !0);
  }
  hasNode(e) {
    if (this.moveTo(e.from), !this.done && this.cursor.from + this.offset == e.from && this.cursor.tree)
      for (let t = this.cursor.tree; ; ) {
        if (t == e.tree)
          return !0;
        if (t.children.length && t.positions[0] == 0 && t.children[0] instanceof D)
          t = t.children[0];
        else
          break;
      }
    return !1;
  }
}
let yS = class {
  constructor(e) {
    var t;
    if (this.fragments = e, this.curTo = 0, this.fragI = 0, e.length) {
      let i = this.curFrag = e[0];
      this.curTo = (t = i.tree.prop(kh)) !== null && t !== void 0 ? t : i.to, this.inner = new Kd(i.tree, -i.offset);
    } else
      this.curFrag = this.inner = null;
  }
  hasNode(e) {
    for (; this.curFrag && e.from >= this.curTo; )
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= e.from && this.curTo >= e.to && this.inner.hasNode(e);
  }
  nextFrag() {
    var e;
    if (this.fragI++, this.fragI == this.fragments.length)
      this.curFrag = this.inner = null;
    else {
      let t = this.curFrag = this.fragments[this.fragI];
      this.curTo = (e = t.tree.prop(kh)) !== null && e !== void 0 ? e : t.to, this.inner = new Kd(t.tree, -t.offset);
    }
  }
  findMounts(e, t) {
    var i;
    let n = [];
    if (this.inner) {
      this.inner.cursor.moveTo(e, 1);
      for (let s = this.inner.cursor.node; s; s = s.parent) {
        let o = (i = s.tree) === null || i === void 0 ? void 0 : i.prop(Y.mounted);
        if (o && o.parser == t)
          for (let l = this.fragI; l < this.fragments.length; l++) {
            let a = this.fragments[l];
            if (a.from >= s.to)
              break;
            a.tree == this.curFrag.tree && n.push({
              frag: a,
              pos: s.from - a.offset,
              mount: o
            });
          }
      }
    }
    return n;
  }
};
function Jd(r, e) {
  let t = null, i = e;
  for (let n = 1, s = 0; n < r.length; n++) {
    let o = r[n - 1].to, l = r[n].from;
    for (; s < i.length; s++) {
      let a = i[s];
      if (a.from >= l)
        break;
      a.to <= o || (t || (i = t = e.slice()), a.from < o ? (t[s] = new ft(a.from, o), a.to > l && t.splice(s + 1, 0, new ft(l, a.to))) : a.to > l ? t[s--] = new ft(l, a.to) : t.splice(s--, 1));
    }
  }
  return i;
}
function vS(r, e, t, i) {
  let n = 0, s = 0, o = !1, l = !1, a = -1e9, h = [];
  for (; ; ) {
    let c = n == r.length ? 1e9 : o ? r[n].to : r[n].from, u = s == e.length ? 1e9 : l ? e[s].to : e[s].from;
    if (o != l) {
      let d = Math.max(a, t), p = Math.min(c, u, i);
      d < p && h.push(new ft(d, p));
    }
    if (a = Math.min(c, u), a == 1e9)
      break;
    c == a && (o ? (o = !1, n++) : o = !0), u == a && (l ? (l = !1, s++) : l = !0);
  }
  return h;
}
function ep(r, e) {
  let t = [];
  for (let { pos: i, mount: n, frag: s } of r) {
    let o = i + (n.overlay ? n.overlay[0].from : 0), l = o + n.tree.length, a = Math.max(s.from, o), h = Math.min(s.to, l);
    if (n.overlay) {
      let c = n.overlay.map((d) => new ft(d.from + i, d.to + i)), u = vS(e, c, a, h);
      for (let d = 0, p = a; ; d++) {
        let f = d == u.length, m = f ? h : u[d].from;
        if (m > p && t.push(new ir(p, m, n.tree, -o, s.from >= p || s.openStart, s.to <= m || s.openEnd)), f)
          break;
        p = u[d].to;
      }
    } else
      t.push(new ir(a, h, n.tree, -o, s.from >= o || s.openStart, s.to <= l || s.openEnd));
  }
  return t;
}
let xS = 0;
class $t {
  /**
  @internal
  */
  constructor(e, t, i) {
    this.set = e, this.base = t, this.modified = i, this.id = xS++;
  }
  /**
  Define a new tag. If `parent` is given, the tag is treated as a
  sub-tag of that parent, and
  [highlighters](#highlight.tagHighlighter) that don't mention
  this tag will try to fall back to the parent tag (or grandparent
  tag, etc).
  */
  static define(e) {
    if (e != null && e.base)
      throw new Error("Can not derive from a modified tag");
    let t = new $t([], null, []);
    if (t.set.push(t), e)
      for (let i of e.set)
        t.set.push(i);
    return t;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier() {
    let e = new qo();
    return (t) => t.modified.indexOf(e) > -1 ? t : qo.get(t.base || t, t.modified.concat(e).sort((i, n) => i.id - n.id));
  }
}
let SS = 0;
class qo {
  constructor() {
    this.instances = [], this.id = SS++;
  }
  static get(e, t) {
    if (!t.length)
      return e;
    let i = t[0].instances.find((l) => l.base == e && kS(t, l.modified));
    if (i)
      return i;
    let n = [], s = new $t(n, e, t);
    for (let l of t)
      l.instances.push(s);
    let o = $S(t);
    for (let l of e.set)
      if (!l.modified.length)
        for (let a of o)
          n.push(qo.get(l, a));
    return s;
  }
}
function kS(r, e) {
  return r.length == e.length && r.every((t, i) => t == e[i]);
}
function $S(r) {
  let e = [[]];
  for (let t = 0; t < r.length; t++)
    for (let i = 0, n = e.length; i < n; i++)
      e.push(e[i].concat(r[t]));
  return e.sort((t, i) => i.length - t.length);
}
function Jt(r) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in r) {
    let i = r[t];
    Array.isArray(i) || (i = [i]);
    for (let n of t.split(" "))
      if (n) {
        let s = [], o = 2, l = n;
        for (let u = 0; ; ) {
          if (l == "..." && u > 0 && u + 3 == n.length) {
            o = 1;
            break;
          }
          let d = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(l);
          if (!d)
            throw new RangeError("Invalid path: " + n);
          if (s.push(d[0] == "*" ? "" : d[0][0] == '"' ? JSON.parse(d[0]) : d[0]), u += d[0].length, u == n.length)
            break;
          let p = n[u++];
          if (u == n.length && p == "!") {
            o = 0;
            break;
          }
          if (p != "/")
            throw new RangeError("Invalid path: " + n);
          l = n.slice(u);
        }
        let a = s.length - 1, h = s[a];
        if (!h)
          throw new RangeError("Invalid path: " + n);
        let c = new zo(i, o, a > 0 ? s.slice(0, a) : null);
        e[h] = c.sort(e[h]);
      }
  }
  return Bm.add(e);
}
const Bm = new Y();
class zo {
  constructor(e, t, i, n) {
    this.tags = e, this.mode = t, this.context = i, this.next = n;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
zo.empty = new zo([], 2, null);
function Dm(r, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let s of r)
    if (!Array.isArray(s.tag))
      t[s.tag.id] = s.class;
    else
      for (let o of s.tag)
        t[o.id] = s.class;
  let { scope: i, all: n = null } = e || {};
  return {
    style: (s) => {
      let o = n;
      for (let l of s)
        for (let a of l.set) {
          let h = t[a.id];
          if (h) {
            o = o ? o + " " + h : h;
            break;
          }
        }
      return o;
    },
    scope: i
  };
}
function QS(r, e) {
  let t = null;
  for (let i of r) {
    let n = i.style(e);
    n && (t = t ? t + " " + n : n);
  }
  return t;
}
function PS(r, e, t, i = 0, n = r.length) {
  let s = new TS(i, Array.isArray(e) ? e : [e], t);
  s.highlightRange(r.cursor(), i, n, "", s.highlighters), s.flush(n);
}
class TS {
  constructor(e, t, i) {
    this.at = e, this.highlighters = t, this.span = i, this.class = "";
  }
  startSpan(e, t) {
    t != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = t);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, t, i, n, s) {
    let { type: o, from: l, to: a } = e;
    if (l >= i || a <= t)
      return;
    o.isTop && (s = this.highlighters.filter((p) => !p.scope || p.scope(o)));
    let h = n, c = CS(e) || zo.empty, u = QS(s, c.tags);
    if (u && (h && (h += " "), h += u, c.mode == 1 && (n += (n ? " " : "") + u)), this.startSpan(Math.max(t, l), h), c.opaque)
      return;
    let d = e.tree && e.tree.prop(Y.mounted);
    if (d && d.overlay) {
      let p = e.node.enter(d.overlay[0].from + l, 1), f = this.highlighters.filter((g) => !g.scope || g.scope(d.tree.type)), m = e.firstChild();
      for (let g = 0, b = l; ; g++) {
        let v = g < d.overlay.length ? d.overlay[g] : null, k = v ? v.from + l : a, $ = Math.max(t, b), x = Math.min(i, k);
        if ($ < x && m)
          for (; e.from < x && (this.highlightRange(e, $, x, n, s), this.startSpan(Math.min(x, e.to), h), !(e.to >= k || !e.nextSibling())); )
            ;
        if (!v || k > i)
          break;
        b = v.to + l, b > t && (this.highlightRange(p.cursor(), Math.max(t, v.from + l), Math.min(i, b), "", f), this.startSpan(Math.min(i, b), h));
      }
      m && e.parent();
    } else if (e.firstChild()) {
      d && (n = "");
      do
        if (!(e.to <= t)) {
          if (e.from >= i)
            break;
          this.highlightRange(e, t, i, n, s), this.startSpan(Math.min(i, e.to), h);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function CS(r) {
  let e = r.type.prop(Bm);
  for (; e && e.context && !r.matchContext(e.context); )
    e = e.next;
  return e || null;
}
const C = $t.define, Us = C(), gr = C(), tp = C(gr), rp = C(gr), br = C(), Gs = C(br), na = C(br), Wt = C(), Nr = C(Wt), qt = C(), zt = C(), $h = C(), mn = C($h), Ns = C(), O = {
  /**
  A comment.
  */
  comment: Us,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: C(Us),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: C(Us),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: C(Us),
  /**
  Any kind of identifier.
  */
  name: gr,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: C(gr),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: tp,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: C(tp),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: rp,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: C(rp),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: C(gr),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: C(gr),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: C(gr),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: C(gr),
  /**
  A literal value.
  */
  literal: br,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: Gs,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: C(Gs),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: C(Gs),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: C(Gs),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: na,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: C(na),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: C(na),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: C(br),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: C(br),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: C(br),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: C(br),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: C(br),
  /**
  A language keyword.
  */
  keyword: qt,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: C(qt),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: C(qt),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: C(qt),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: C(qt),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: C(qt),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: C(qt),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: C(qt),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: C(qt),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: C(qt),
  /**
  An operator.
  */
  operator: zt,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: C(zt),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: C(zt),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: C(zt),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: C(zt),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: C(zt),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: C(zt),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: C(zt),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: C(zt),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: C(zt),
  /**
  Program or markup punctuation.
  */
  punctuation: $h,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: C($h),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: mn,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: C(mn),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: C(mn),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: C(mn),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: C(mn),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: Wt,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: Nr,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: C(Nr),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: C(Nr),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: C(Nr),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: C(Nr),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: C(Nr),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: C(Nr),
  /**
  A prose separator (such as a horizontal rule).
  */
  contentSeparator: C(Wt),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: C(Wt),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: C(Wt),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: C(Wt),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: C(Wt),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: C(Wt),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: C(Wt),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: C(Wt),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: C(),
  /**
  Deleted text.
  */
  deleted: C(),
  /**
  Changed text.
  */
  changed: C(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: C(),
  /**
  Metadata or meta-instruction.
  */
  meta: Ns,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: C(Ns),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: C(Ns),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: C(Ns),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: $t.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: $t.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: $t.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: $t.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: $t.defineModifier(),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: $t.defineModifier()
};
Dm([
  { tag: O.link, class: "tok-link" },
  { tag: O.heading, class: "tok-heading" },
  { tag: O.emphasis, class: "tok-emphasis" },
  { tag: O.strong, class: "tok-strong" },
  { tag: O.keyword, class: "tok-keyword" },
  { tag: O.atom, class: "tok-atom" },
  { tag: O.bool, class: "tok-bool" },
  { tag: O.url, class: "tok-url" },
  { tag: O.labelName, class: "tok-labelName" },
  { tag: O.inserted, class: "tok-inserted" },
  { tag: O.deleted, class: "tok-deleted" },
  { tag: O.literal, class: "tok-literal" },
  { tag: O.string, class: "tok-string" },
  { tag: O.number, class: "tok-number" },
  { tag: [O.regexp, O.escape, O.special(O.string)], class: "tok-string2" },
  { tag: O.variableName, class: "tok-variableName" },
  { tag: O.local(O.variableName), class: "tok-variableName tok-local" },
  { tag: O.definition(O.variableName), class: "tok-variableName tok-definition" },
  { tag: O.special(O.variableName), class: "tok-variableName2" },
  { tag: O.definition(O.propertyName), class: "tok-propertyName tok-definition" },
  { tag: O.typeName, class: "tok-typeName" },
  { tag: O.namespace, class: "tok-namespace" },
  { tag: O.className, class: "tok-className" },
  { tag: O.macroName, class: "tok-macroName" },
  { tag: O.propertyName, class: "tok-propertyName" },
  { tag: O.operator, class: "tok-operator" },
  { tag: O.comment, class: "tok-comment" },
  { tag: O.meta, class: "tok-meta" },
  { tag: O.invalid, class: "tok-invalid" },
  { tag: O.punctuation, class: "tok-punctuation" }
]);
var sa;
const kr = /* @__PURE__ */ new Y();
function gl(r) {
  return _.define({
    combine: r ? (e) => e.concat(r) : void 0
  });
}
const Qc = /* @__PURE__ */ new Y();
class nt {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, t, i = [], n = "") {
    this.data = e, this.name = n, U.prototype.hasOwnProperty("tree") || Object.defineProperty(U.prototype, "tree", { get() {
      return te(this);
    } }), this.parser = t, this.extension = [
      Wr.of(this),
      U.languageData.of((s, o, l) => {
        let a = ip(s, o, l), h = a.type.prop(kr);
        if (!h)
          return [];
        let c = s.facet(h), u = a.type.prop(Qc);
        if (u) {
          let d = a.resolve(o - a.from, l);
          for (let p of u)
            if (p.test(d, s)) {
              let f = s.facet(p.facet);
              return p.type == "replace" ? f : f.concat(c);
            }
        }
        return c;
      })
    ].concat(i);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, t, i = -1) {
    return ip(e, t, i).type.prop(kr) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let t = e.facet(Wr);
    if ((t == null ? void 0 : t.data) == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!t || !t.allowsNesting)
      return [];
    let i = [], n = (s, o) => {
      if (s.prop(kr) == this.data) {
        i.push({ from: o, to: o + s.length });
        return;
      }
      let l = s.prop(Y.mounted);
      if (l) {
        if (l.tree.prop(kr) == this.data) {
          if (l.overlay)
            for (let a of l.overlay)
              i.push({ from: a.from + o, to: a.to + o });
          else
            i.push({ from: o, to: o + s.length });
          return;
        } else if (l.overlay) {
          let a = i.length;
          if (n(l.tree, l.overlay[0].from + o), i.length > a)
            return;
        }
      }
      for (let a = 0; a < s.children.length; a++) {
        let h = s.children[a];
        h instanceof D && n(h, s.positions[a] + o);
      }
    };
    return n(te(e), 0), i;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
nt.setState = /* @__PURE__ */ j.define();
function ip(r, e, t) {
  let i = r.facet(Wr), n = te(r).topNode;
  if (!i || i.allowsNesting)
    for (let s = n; s; s = s.enter(e, t, ne.ExcludeBuffers))
      s.type.isTop && (n = s);
  return n;
}
class Nt extends nt {
  constructor(e, t, i) {
    super(e, t, [], i), this.parser = t;
  }
  /**
  Define a language from a parser.
  */
  static define(e) {
    let t = gl(e.languageData);
    return new Nt(t, e.parser.configure({
      props: [kr.add((i) => i.isTop ? t : void 0)]
    }), e.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(e, t) {
    return new Nt(this.data, this.parser.configure(e), t || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function te(r) {
  let e = r.field(nt.state, !1);
  return e ? e.tree : D.empty;
}
class XS {
  /**
  Create an input object for the given document.
  */
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, t) {
    let i = this.cursorPos - this.string.length;
    return e < i || t >= this.cursorPos ? this.doc.sliceString(e, t) : this.string.slice(e - i, t - i);
  }
}
let gn = null;
class pi {
  constructor(e, t, i = [], n, s, o, l, a) {
    this.parser = e, this.state = t, this.fragments = i, this.tree = n, this.treeLen = s, this.viewport = o, this.skipped = l, this.scheduleOn = a, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, t, i) {
    return new pi(e, t, [], D.empty, 0, i, [], null);
  }
  startParse() {
    return this.parser.startParse(new XS(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, t) {
    return t != null && t >= this.state.doc.length && (t = void 0), this.tree != D.empty && this.isDone(t ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var i;
      if (typeof e == "number") {
        let n = Date.now() + e;
        e = () => Date.now() > n;
      }
      for (this.parse || (this.parse = this.startParse()), t != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > t) && t < this.state.doc.length && this.parse.stopAt(t); ; ) {
        let n = this.parse.advance();
        if (n)
          if (this.fragments = this.withoutTempSkipped(ir.addTree(n, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (i = this.parse.stoppedAt) !== null && i !== void 0 ? i : this.state.doc.length, this.tree = n, this.parse = null, this.treeLen < (t ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, t;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(t = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = t, this.fragments = this.withoutTempSkipped(ir.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let t = gn;
    gn = this;
    try {
      return e();
    } finally {
      gn = t;
    }
  }
  withoutTempSkipped(e) {
    for (let t; t = this.tempSkipped.pop(); )
      e = np(e, t.from, t.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, t) {
    let { fragments: i, tree: n, treeLen: s, viewport: o, skipped: l } = this;
    if (this.takeTree(), !e.empty) {
      let a = [];
      if (e.iterChangedRanges((h, c, u, d) => a.push({ fromA: h, toA: c, fromB: u, toB: d })), i = ir.applyChanges(i, a), n = D.empty, s = 0, o = { from: e.mapPos(o.from, -1), to: e.mapPos(o.to, 1) }, this.skipped.length) {
        l = [];
        for (let h of this.skipped) {
          let c = e.mapPos(h.from, 1), u = e.mapPos(h.to, -1);
          c < u && l.push({ from: c, to: u });
        }
      }
    }
    return new pi(this.parser, t, i, n, s, o, l, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let t = this.skipped.length;
    for (let i = 0; i < this.skipped.length; i++) {
      let { from: n, to: s } = this.skipped[i];
      n < e.to && s > e.from && (this.fragments = np(this.fragments, n, s), this.skipped.splice(i--, 1));
    }
    return this.skipped.length >= t ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, t) {
    this.skipped.push({ from: e, to: t });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends ml {
      createParse(t, i, n) {
        let s = n[0].from, o = n[n.length - 1].to;
        return {
          parsedPos: s,
          advance() {
            let a = gn;
            if (a) {
              for (let h of n)
                a.tempSkipped.push(h);
              e && (a.scheduleOn = a.scheduleOn ? Promise.all([a.scheduleOn, e]) : e);
            }
            return this.parsedPos = o, new D(ye.none, [], [], o - s);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let t = this.fragments;
    return this.treeLen >= e && t.length && t[0].from == 0 && t[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return gn;
  }
}
function np(r, e, t) {
  return ir.applyChanges(r, [{ fromA: e, toA: t, fromB: e, toB: t }]);
}
class Ii {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let t = this.context.changes(e.changes, e.state), i = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), t.viewport.to);
    return t.work(20, i) || t.takeTree(), new Ii(t);
  }
  static init(e) {
    let t = Math.min(3e3, e.doc.length), i = pi.create(e.facet(Wr).parser, e, { from: 0, to: t });
    return i.work(20, t) || i.takeTree(), new Ii(i);
  }
}
nt.state = /* @__PURE__ */ Qe.define({
  create: Ii.init,
  update(r, e) {
    for (let t of e.effects)
      if (t.is(nt.setState))
        return t.value;
    return e.startState.facet(Wr) != e.state.facet(Wr) ? Ii.init(e.state) : r.apply(e);
  }
});
let Im = (r) => {
  let e = setTimeout(
    () => r(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (Im = (r) => {
  let e = -1, t = setTimeout(
    () => {
      e = requestIdleCallback(r, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => e < 0 ? clearTimeout(t) : cancelIdleCallback(e);
});
const oa = typeof navigator < "u" && (!((sa = navigator.scheduling) === null || sa === void 0) && sa.isInputPending) ? () => navigator.scheduling.isInputPending() : null, ZS = /* @__PURE__ */ ge.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let t = this.view.state.field(nt.state).context;
    (t.updateViewport(e.view.viewport) || this.view.viewport.to > t.treeLen) && this.scheduleWork(), (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(t);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, t = e.field(nt.state);
    (t.tree != t.context.tree || !t.context.isDone(e.doc.length)) && (this.working = Im(this.work));
  }
  work(e) {
    this.working = null;
    let t = Date.now();
    if (this.chunkEnd < t && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = t + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: i, viewport: { to: n } } = this.view, s = i.field(nt.state);
    if (s.tree == s.context.tree && s.context.isDone(
      n + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let o = Date.now() + Math.min(this.chunkBudget, 100, e && !oa ? Math.max(25, e.timeRemaining() - 5) : 1e9), l = s.context.treeLen < n && i.doc.length > n + 1e3, a = s.context.work(() => oa && oa() || Date.now() > o, n + (l ? 0 : 1e5));
    this.chunkBudget -= Date.now() - t, (a || this.chunkBudget <= 0) && (s.context.takeTree(), this.view.dispatch({ effects: nt.setState.of(new Ii(s.context)) })), this.chunkBudget > 0 && !(a && !l) && this.scheduleWork(), this.checkAsyncSchedule(s.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((t) => gt(this.view.state, t)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), Wr = /* @__PURE__ */ _.define({
  combine(r) {
    return r.length ? r[0] : null;
  },
  enables: (r) => [
    nt.state,
    ZS,
    Z.contentAttributes.compute([r], (e) => {
      let t = e.facet(r);
      return t && t.name ? { "data-language": t.name } : {};
    })
  ]
});
class cr {
  /**
  Create a language support object.
  */
  constructor(e, t = []) {
    this.language = e, this.support = t, this.extension = [e, t];
  }
}
class Yo {
  constructor(e, t, i, n, s, o = void 0) {
    this.name = e, this.alias = t, this.extensions = i, this.filename = n, this.loadFunc = s, this.support = o, this.loading = null;
  }
  /**
  Start loading the the language. Will return a promise that
  resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)
  object when the language successfully loads.
  */
  load() {
    return this.loading || (this.loading = this.loadFunc().then((e) => this.support = e, (e) => {
      throw this.loading = null, e;
    }));
  }
  /**
  Create a language description.
  */
  static of(e) {
    let { load: t, support: i } = e;
    if (!t) {
      if (!i)
        throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
      t = () => Promise.resolve(i);
    }
    return new Yo(e.name, (e.alias || []).concat(e.name).map((n) => n.toLowerCase()), e.extensions || [], e.filename, t, i);
  }
  /**
  Look for a language in the given array of descriptions that
  matches the filename. Will first match
  [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,
  and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),
  and return the first language that matches.
  */
  static matchFilename(e, t) {
    for (let n of e)
      if (n.filename && n.filename.test(t))
        return n;
    let i = /\.([^.]+)$/.exec(t);
    if (i) {
      for (let n of e)
        if (n.extensions.indexOf(i[1]) > -1)
          return n;
    }
    return null;
  }
  /**
  Look for a language whose name or alias matches the the given
  name (case-insensitively). If `fuzzy` is true, and no direct
  matchs is found, this'll also search for a language whose name
  or alias occurs in the string (for names shorter than three
  characters, only when surrounded by non-word characters).
  */
  static matchLanguageName(e, t, i = !0) {
    t = t.toLowerCase();
    for (let n of e)
      if (n.alias.some((s) => s == t))
        return n;
    if (i)
      for (let n of e)
        for (let s of n.alias) {
          let o = t.indexOf(s);
          if (o > -1 && (s.length > 2 || !/\w/.test(t[o - 1]) && !/\w/.test(t[o + s.length])))
            return n;
        }
    return null;
  }
}
const Um = /* @__PURE__ */ _.define(), fi = /* @__PURE__ */ _.define({
  combine: (r) => {
    if (!r.length)
      return "  ";
    let e = r[0];
    if (!e || /\S/.test(e) || Array.from(e).some((t) => t != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(r[0]));
    return e;
  }
});
function ur(r) {
  let e = r.facet(fi);
  return e.charCodeAt(0) == 9 ? r.tabSize * e.length : e.length;
}
function rs(r, e) {
  let t = "", i = r.tabSize, n = r.facet(fi)[0];
  if (n == "	") {
    for (; e >= i; )
      t += "	", e -= i;
    n = " ";
  }
  for (let s = 0; s < e; s++)
    t += n;
  return t;
}
function Pc(r, e) {
  r instanceof U && (r = new bl(r));
  for (let i of r.state.facet(Um)) {
    let n = i(r, e);
    if (n !== void 0)
      return n;
  }
  let t = te(r.state);
  return t.length >= e ? _S(r, t, e) : null;
}
class bl {
  /**
  Create an indent context.
  */
  constructor(e, t = {}) {
    this.state = e, this.options = t, this.unit = ur(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, t = 1) {
    let i = this.state.doc.lineAt(e), { simulateBreak: n, simulateDoubleBreak: s } = this.options;
    return n != null && n >= i.from && n <= i.to ? s && n == e ? { text: "", from: e } : (t < 0 ? n < e : n <= e) ? { text: i.text.slice(n - i.from), from: n } : { text: i.text.slice(0, n - i.from), from: i.from } : i;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, t = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: i, from: n } = this.lineAt(e, t);
    return i.slice(e - n, Math.min(i.length, e + 100 - n));
  }
  /**
  Find the column for the given position.
  */
  column(e, t = 1) {
    let { text: i, from: n } = this.lineAt(e, t), s = this.countColumn(i, e - n), o = this.options.overrideIndentation ? this.options.overrideIndentation(n) : -1;
    return o > -1 && (s += o - this.countColumn(i, i.search(/\S|$/))), s;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, t = e.length) {
    return Tt(e, this.state.tabSize, t);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, t = 1) {
    let { text: i, from: n } = this.lineAt(e, t), s = this.options.overrideIndentation;
    if (s) {
      let o = s(n);
      if (o > -1)
        return o;
    }
    return this.countColumn(i, i.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const Br = /* @__PURE__ */ new Y();
function _S(r, e, t) {
  let i = e.resolveStack(t), n = i.node.enterUnfinishedNodesBefore(t);
  if (n != i.node) {
    let s = [];
    for (let o = n; o != i.node; o = o.parent)
      s.push(o);
    for (let o = s.length - 1; o >= 0; o--)
      i = { node: s[o], next: i };
  }
  return Gm(i, r, t);
}
function Gm(r, e, t) {
  for (let i = r; i; i = i.next) {
    let n = AS(i.node);
    if (n)
      return n(Tc.create(e, t, i));
  }
  return 0;
}
function RS(r) {
  return r.pos == r.options.simulateBreak && r.options.simulateDoubleBreak;
}
function AS(r) {
  let e = r.type.prop(Br);
  if (e)
    return e;
  let t = r.firstChild, i;
  if (t && (i = t.type.prop(Y.closedBy))) {
    let n = r.lastChild, s = n && i.indexOf(n.name) > -1;
    return (o) => Nm(o, !0, 1, void 0, s && !RS(o) ? n.from : void 0);
  }
  return r.parent == null ? ES : null;
}
function ES() {
  return 0;
}
class Tc extends bl {
  constructor(e, t, i) {
    super(e.state, e.options), this.base = e, this.pos = t, this.context = i;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(e, t, i) {
    return new Tc(e, t, i);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(e) {
    let t = this.state.doc.lineAt(e.from);
    for (; ; ) {
      let i = e.resolve(t.from);
      for (; i.parent && i.parent.from == i.from; )
        i = i.parent;
      if (qS(i, e))
        break;
      t = this.state.doc.lineAt(i.from);
    }
    return this.lineIndent(t.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return Gm(this.context.next, this.base, this.pos);
  }
}
function qS(r, e) {
  for (let t = e; t; t = t.parent)
    if (r == t)
      return !0;
  return !1;
}
function zS(r) {
  let e = r.node, t = e.childAfter(e.from), i = e.lastChild;
  if (!t)
    return null;
  let n = r.options.simulateBreak, s = r.state.doc.lineAt(t.from), o = n == null || n <= s.from ? s.to : Math.min(s.to, n);
  for (let l = t.to; ; ) {
    let a = e.childAfter(l);
    if (!a || a == i)
      return null;
    if (!a.type.isSkipped)
      return a.from < o ? t : null;
    l = a.to;
  }
}
function wo({ closing: r, align: e = !0, units: t = 1 }) {
  return (i) => Nm(i, e, t, r);
}
function Nm(r, e, t, i, n) {
  let s = r.textAfter, o = s.match(/^\s*/)[0].length, l = i && s.slice(o, o + i.length) == i || n == r.pos + o, a = e ? zS(r) : null;
  return a ? l ? r.column(a.from) : r.column(a.to) : r.baseIndent + (l ? 0 : r.unit * t);
}
const YS = (r) => r.baseIndent;
function si({ except: r, units: e = 1 } = {}) {
  return (t) => {
    let i = r && r.test(t.textAfter);
    return t.baseIndent + (i ? 0 : e * t.unit);
  };
}
const WS = 200;
function VS() {
  return U.transactionFilter.of((r) => {
    if (!r.docChanged || !r.isUserEvent("input.type") && !r.isUserEvent("input.complete"))
      return r;
    let e = r.startState.languageDataAt("indentOnInput", r.startState.selection.main.head);
    if (!e.length)
      return r;
    let t = r.newDoc, { head: i } = r.newSelection.main, n = t.lineAt(i);
    if (i > n.from + WS)
      return r;
    let s = t.sliceString(n.from, i);
    if (!e.some((h) => h.test(s)))
      return r;
    let { state: o } = r, l = -1, a = [];
    for (let { head: h } of o.selection.ranges) {
      let c = o.doc.lineAt(h);
      if (c.from == l)
        continue;
      l = c.from;
      let u = Pc(o, c.from);
      if (u == null)
        continue;
      let d = /^\s*/.exec(c.text)[0], p = rs(o, u);
      d != p && a.push({ from: c.from, to: c.from + d.length, insert: p });
    }
    return a.length ? [r, { changes: a, sequential: !0 }] : r;
  });
}
const Fm = /* @__PURE__ */ _.define(), fr = /* @__PURE__ */ new Y();
function wl(r) {
  let e = r.firstChild, t = r.lastChild;
  return e && e.to < t.from ? { from: e.to, to: t.type.isError ? r.to : t.from } : null;
}
function MS(r, e, t) {
  let i = te(r);
  if (i.length < t)
    return null;
  let n = i.resolveStack(t, 1), s = null;
  for (let o = n; o; o = o.next) {
    let l = o.node;
    if (l.to <= t || l.from > t)
      continue;
    if (s && l.from < e)
      break;
    let a = l.type.prop(fr);
    if (a && (l.to < i.length - 50 || i.length == r.doc.length || !jS(l))) {
      let h = a(l, r);
      h && h.from <= t && h.from >= e && h.to > t && (s = h);
    }
  }
  return s;
}
function jS(r) {
  let e = r.lastChild;
  return e && e.to == r.to && e.type.isError;
}
function Wo(r, e, t) {
  for (let i of r.facet(Fm)) {
    let n = i(r, e, t);
    if (n)
      return n;
  }
  return MS(r, e, t);
}
function Hm(r, e) {
  let t = e.mapPos(r.from, 1), i = e.mapPos(r.to, -1);
  return t >= i ? void 0 : { from: t, to: i };
}
const yl = /* @__PURE__ */ j.define({ map: Hm }), ks = /* @__PURE__ */ j.define({ map: Hm });
function Km(r) {
  let e = [];
  for (let { head: t } of r.state.selection.ranges)
    e.some((i) => i.from <= t && i.to >= t) || e.push(r.lineBlockAt(t));
  return e;
}
const Oi = /* @__PURE__ */ Qe.define({
  create() {
    return E.none;
  },
  update(r, e) {
    r = r.map(e.changes);
    for (let t of e.effects)
      if (t.is(yl) && !LS(r, t.value.from, t.value.to)) {
        let { preparePlaceholder: i } = e.state.facet(Cc), n = i ? E.replace({ widget: new NS(i(e.state, t.value)) }) : sp;
        r = r.update({ add: [n.range(t.value.from, t.value.to)] });
      } else
        t.is(ks) && (r = r.update({
          filter: (i, n) => t.value.from != i || t.value.to != n,
          filterFrom: t.value.from,
          filterTo: t.value.to
        }));
    if (e.selection) {
      let t = !1, { head: i } = e.selection.main;
      r.between(i, i, (n, s) => {
        n < i && s > i && (t = !0);
      }), t && (r = r.update({
        filterFrom: i,
        filterTo: i,
        filter: (n, s) => s <= i || n >= i
      }));
    }
    return r;
  },
  provide: (r) => Z.decorations.from(r),
  toJSON(r, e) {
    let t = [];
    return r.between(0, e.doc.length, (i, n) => {
      t.push(i, n);
    }), t;
  },
  fromJSON(r) {
    if (!Array.isArray(r) || r.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let e = [];
    for (let t = 0; t < r.length; ) {
      let i = r[t++], n = r[t++];
      if (typeof i != "number" || typeof n != "number")
        throw new RangeError("Invalid JSON for fold state");
      e.push(sp.range(i, n));
    }
    return E.set(e, !0);
  }
});
function Vo(r, e, t) {
  var i;
  let n = null;
  return (i = r.field(Oi, !1)) === null || i === void 0 || i.between(e, t, (s, o) => {
    (!n || n.from > s) && (n = { from: s, to: o });
  }), n;
}
function LS(r, e, t) {
  let i = !1;
  return r.between(e, e, (n, s) => {
    n == e && s == t && (i = !0);
  }), i;
}
function Jm(r, e) {
  return r.field(Oi, !1) ? e : e.concat(j.appendConfig.of(rg()));
}
const BS = (r) => {
  for (let e of Km(r)) {
    let t = Wo(r.state, e.from, e.to);
    if (t)
      return r.dispatch({ effects: Jm(r.state, [yl.of(t), eg(r, t)]) }), !0;
  }
  return !1;
}, DS = (r) => {
  if (!r.state.field(Oi, !1))
    return !1;
  let e = [];
  for (let t of Km(r)) {
    let i = Vo(r.state, t.from, t.to);
    i && e.push(ks.of(i), eg(r, i, !1));
  }
  return e.length && r.dispatch({ effects: e }), e.length > 0;
};
function eg(r, e, t = !0) {
  let i = r.state.doc.lineAt(e.from).number, n = r.state.doc.lineAt(e.to).number;
  return Z.announce.of(`${r.state.phrase(t ? "Folded lines" : "Unfolded lines")} ${i} ${r.state.phrase("to")} ${n}.`);
}
const IS = (r) => {
  let { state: e } = r, t = [];
  for (let i = 0; i < e.doc.length; ) {
    let n = r.lineBlockAt(i), s = Wo(e, n.from, n.to);
    s && t.push(yl.of(s)), i = (s ? r.lineBlockAt(s.to) : n).to + 1;
  }
  return t.length && r.dispatch({ effects: Jm(r.state, t) }), !!t.length;
}, US = (r) => {
  let e = r.state.field(Oi, !1);
  if (!e || !e.size)
    return !1;
  let t = [];
  return e.between(0, r.state.doc.length, (i, n) => {
    t.push(ks.of({ from: i, to: n }));
  }), r.dispatch({ effects: t }), !0;
}, tg = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: BS },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: DS },
  { key: "Ctrl-Alt-[", run: IS },
  { key: "Ctrl-Alt-]", run: US }
], GS = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: "…"
}, Cc = /* @__PURE__ */ _.define({
  combine(r) {
    return _t(r, GS);
  }
});
function rg(r) {
  let e = [Oi, KS];
  return r && e.push(Cc.of(r)), e;
}
function ig(r, e) {
  let { state: t } = r, i = t.facet(Cc), n = (o) => {
    let l = r.lineBlockAt(r.posAtDOM(o.target)), a = Vo(r.state, l.from, l.to);
    a && r.dispatch({ effects: ks.of(a) }), o.preventDefault();
  };
  if (i.placeholderDOM)
    return i.placeholderDOM(r, n, e);
  let s = document.createElement("span");
  return s.textContent = i.placeholderText, s.setAttribute("aria-label", t.phrase("folded code")), s.title = t.phrase("unfold"), s.className = "cm-foldPlaceholder", s.onclick = n, s;
}
const sp = /* @__PURE__ */ E.replace({ widget: /* @__PURE__ */ new class extends Kt {
  toDOM(r) {
    return ig(r, null);
  }
}() });
class NS extends Kt {
  constructor(e) {
    super(), this.value = e;
  }
  eq(e) {
    return this.value == e.value;
  }
  toDOM(e) {
    return ig(e, this.value);
  }
}
const FS = {
  openText: "⌄",
  closedText: "›",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
};
class la extends hr {
  constructor(e, t) {
    super(), this.config = e, this.open = t;
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let t = document.createElement("span");
    return t.textContent = this.open ? this.config.openText : this.config.closedText, t.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), t;
  }
}
function HS(r = {}) {
  let e = Object.assign(Object.assign({}, FS), r), t = new la(e, !0), i = new la(e, !1), n = ge.fromClass(class {
    constructor(o) {
      this.from = o.viewport.from, this.markers = this.buildMarkers(o);
    }
    update(o) {
      (o.docChanged || o.viewportChanged || o.startState.facet(Wr) != o.state.facet(Wr) || o.startState.field(Oi, !1) != o.state.field(Oi, !1) || te(o.startState) != te(o.state) || e.foldingChanged(o)) && (this.markers = this.buildMarkers(o.view));
    }
    buildMarkers(o) {
      let l = new sr();
      for (let a of o.viewportLineBlocks) {
        let h = Vo(o.state, a.from, a.to) ? i : Wo(o.state, a.from, a.to) ? t : null;
        h && l.add(a.from, a.from, h);
      }
      return l.finish();
    }
  }), { domEventHandlers: s } = e;
  return [
    n,
    eS({
      class: "cm-foldGutter",
      markers(o) {
        var l;
        return ((l = o.plugin(n)) === null || l === void 0 ? void 0 : l.markers) || H.empty;
      },
      initialSpacer() {
        return new la(e, !1);
      },
      domEventHandlers: Object.assign(Object.assign({}, s), { click: (o, l, a) => {
        if (s.click && s.click(o, l, a))
          return !0;
        let h = Vo(o.state, l.from, l.to);
        if (h)
          return o.dispatch({ effects: ks.of(h) }), !0;
        let c = Wo(o.state, l.from, l.to);
        return c ? (o.dispatch({ effects: yl.of(c) }), !0) : !1;
      } })
    }),
    rg()
  ];
}
const KS = /* @__PURE__ */ Z.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class $s {
  constructor(e, t) {
    this.specs = e;
    let i;
    function n(l) {
      let a = Er.newName();
      return (i || (i = /* @__PURE__ */ Object.create(null)))["." + a] = l, a;
    }
    const s = typeof t.all == "string" ? t.all : t.all ? n(t.all) : void 0, o = t.scope;
    this.scope = o instanceof nt ? (l) => l.prop(kr) == o.data : o ? (l) => l == o : void 0, this.style = Dm(e.map((l) => ({
      tag: l.tag,
      class: l.class || n(Object.assign({}, l, { tag: null }))
    })), {
      all: s
    }).style, this.module = i ? new Er(i) : null, this.themeType = t.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, t) {
    return new $s(e, t || {});
  }
}
const Qh = /* @__PURE__ */ _.define(), ng = /* @__PURE__ */ _.define({
  combine(r) {
    return r.length ? [r[0]] : null;
  }
});
function aa(r) {
  let e = r.facet(Qh);
  return e.length ? e : r.facet(ng);
}
function sg(r, e) {
  let t = [ek], i;
  return r instanceof $s && (r.module && t.push(Z.styleModule.of(r.module)), i = r.themeType), e != null && e.fallback ? t.push(ng.of(r)) : i ? t.push(Qh.computeN([Z.darkTheme], (n) => n.facet(Z.darkTheme) == (i == "dark") ? [r] : [])) : t.push(Qh.of(r)), t;
}
class JS {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = te(e.state), this.decorations = this.buildDeco(e, aa(e.state));
  }
  update(e) {
    let t = te(e.state), i = aa(e.state), n = i != aa(e.startState);
    t.length < e.view.viewport.to && !n && t.type == this.tree.type ? this.decorations = this.decorations.map(e.changes) : (t != this.tree || e.viewportChanged || n) && (this.tree = t, this.decorations = this.buildDeco(e.view, i));
  }
  buildDeco(e, t) {
    if (!t || !this.tree.length)
      return E.none;
    let i = new sr();
    for (let { from: n, to: s } of e.visibleRanges)
      PS(this.tree, t, (o, l, a) => {
        i.add(o, l, this.markCache[a] || (this.markCache[a] = E.mark({ class: a })));
      }, n, s);
    return i.finish();
  }
}
const ek = /* @__PURE__ */ Lr.high(/* @__PURE__ */ ge.fromClass(JS, {
  decorations: (r) => r.decorations
})), tk = /* @__PURE__ */ $s.define([
  {
    tag: O.meta,
    color: "#404740"
  },
  {
    tag: O.link,
    textDecoration: "underline"
  },
  {
    tag: O.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: O.emphasis,
    fontStyle: "italic"
  },
  {
    tag: O.strong,
    fontWeight: "bold"
  },
  {
    tag: O.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: O.keyword,
    color: "#708"
  },
  {
    tag: [O.atom, O.bool, O.url, O.contentSeparator, O.labelName],
    color: "#219"
  },
  {
    tag: [O.literal, O.inserted],
    color: "#164"
  },
  {
    tag: [O.string, O.deleted],
    color: "#a11"
  },
  {
    tag: [O.regexp, O.escape, /* @__PURE__ */ O.special(O.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ O.definition(O.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ O.local(O.variableName),
    color: "#30a"
  },
  {
    tag: [O.typeName, O.namespace],
    color: "#085"
  },
  {
    tag: O.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ O.special(O.variableName), O.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ O.definition(O.propertyName),
    color: "#00c"
  },
  {
    tag: O.comment,
    color: "#940"
  },
  {
    tag: O.invalid,
    color: "#f00"
  }
]), rk = /* @__PURE__ */ Z.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), og = 1e4, lg = "()[]{}", ag = /* @__PURE__ */ _.define({
  combine(r) {
    return _t(r, {
      afterCursor: !0,
      brackets: lg,
      maxScanDistance: og,
      renderMatch: sk
    });
  }
}), ik = /* @__PURE__ */ E.mark({ class: "cm-matchingBracket" }), nk = /* @__PURE__ */ E.mark({ class: "cm-nonmatchingBracket" });
function sk(r) {
  let e = [], t = r.matched ? ik : nk;
  return e.push(t.range(r.start.from, r.start.to)), r.end && e.push(t.range(r.end.from, r.end.to)), e;
}
const ok = /* @__PURE__ */ Qe.define({
  create() {
    return E.none;
  },
  update(r, e) {
    if (!e.docChanged && !e.selection)
      return r;
    let t = [], i = e.state.facet(ag);
    for (let n of e.state.selection.ranges) {
      if (!n.empty)
        continue;
      let s = Bt(e.state, n.head, -1, i) || n.head > 0 && Bt(e.state, n.head - 1, 1, i) || i.afterCursor && (Bt(e.state, n.head, 1, i) || n.head < e.state.doc.length && Bt(e.state, n.head + 1, -1, i));
      s && (t = t.concat(i.renderMatch(s, e.state)));
    }
    return E.set(t, !0);
  },
  provide: (r) => Z.decorations.from(r)
}), lk = [
  ok,
  rk
];
function ak(r = {}) {
  return [ag.of(r), lk];
}
const hg = /* @__PURE__ */ new Y();
function Ph(r, e, t) {
  let i = r.prop(e < 0 ? Y.openedBy : Y.closedBy);
  if (i)
    return i;
  if (r.name.length == 1) {
    let n = t.indexOf(r.name);
    if (n > -1 && n % 2 == (e < 0 ? 1 : 0))
      return [t[n + e]];
  }
  return null;
}
function Th(r) {
  let e = r.type.prop(hg);
  return e ? e(r.node) : r;
}
function Bt(r, e, t, i = {}) {
  let n = i.maxScanDistance || og, s = i.brackets || lg, o = te(r), l = o.resolveInner(e, t);
  for (let a = l; a; a = a.parent) {
    let h = Ph(a.type, t, s);
    if (h && a.from < a.to) {
      let c = Th(a);
      if (c && (t > 0 ? e >= c.from && e < c.to : e > c.from && e <= c.to))
        return hk(r, e, t, a, c, h, s);
    }
  }
  return ck(r, e, t, o, l.type, n, s);
}
function hk(r, e, t, i, n, s, o) {
  let l = i.parent, a = { from: n.from, to: n.to }, h = 0, c = l == null ? void 0 : l.cursor();
  if (c && (t < 0 ? c.childBefore(i.from) : c.childAfter(i.to)))
    do
      if (t < 0 ? c.to <= i.from : c.from >= i.to) {
        if (h == 0 && s.indexOf(c.type.name) > -1 && c.from < c.to) {
          let u = Th(c);
          return { start: a, end: u ? { from: u.from, to: u.to } : void 0, matched: !0 };
        } else if (Ph(c.type, t, o))
          h++;
        else if (Ph(c.type, -t, o)) {
          if (h == 0) {
            let u = Th(c);
            return {
              start: a,
              end: u && u.from < u.to ? { from: u.from, to: u.to } : void 0,
              matched: !1
            };
          }
          h--;
        }
      }
    while (t < 0 ? c.prevSibling() : c.nextSibling());
  return { start: a, matched: !1 };
}
function ck(r, e, t, i, n, s, o) {
  let l = t < 0 ? r.sliceDoc(e - 1, e) : r.sliceDoc(e, e + 1), a = o.indexOf(l);
  if (a < 0 || a % 2 == 0 != t > 0)
    return null;
  let h = { from: t < 0 ? e - 1 : e, to: t > 0 ? e + 1 : e }, c = r.doc.iterRange(e, t > 0 ? r.doc.length : 0), u = 0;
  for (let d = 0; !c.next().done && d <= s; ) {
    let p = c.value;
    t < 0 && (d += p.length);
    let f = e + d * t;
    for (let m = t > 0 ? 0 : p.length - 1, g = t > 0 ? p.length : -1; m != g; m += t) {
      let b = o.indexOf(p[m]);
      if (!(b < 0 || i.resolveInner(f + m, 1).type != n))
        if (b % 2 == 0 == t > 0)
          u++;
        else {
          if (u == 1)
            return { start: h, end: { from: f + m, to: f + m + 1 }, matched: b >> 1 == a >> 1 };
          u--;
        }
    }
    t > 0 && (d += p.length);
  }
  return c.done ? { start: h, matched: !1 } : null;
}
function op(r, e, t, i = 0, n = 0) {
  e == null && (e = r.search(/[^\s\u00a0]/), e == -1 && (e = r.length));
  let s = n;
  for (let o = i; o < e; o++)
    r.charCodeAt(o) == 9 ? s += t - s % t : s++;
  return s;
}
class cg {
  /**
  Create a stream.
  */
  constructor(e, t, i, n) {
    this.string = e, this.tabSize = t, this.indentUnit = i, this.overrideIndent = n, this.pos = 0, this.start = 0, this.lastColumnPos = 0, this.lastColumnValue = 0;
  }
  /**
  True if we are at the end of the line.
  */
  eol() {
    return this.pos >= this.string.length;
  }
  /**
  True if we are at the start of the line.
  */
  sol() {
    return this.pos == 0;
  }
  /**
  Get the next code unit after the current position, or undefined
  if we're at the end of the line.
  */
  peek() {
    return this.string.charAt(this.pos) || void 0;
  }
  /**
  Read the next code unit and advance `this.pos`.
  */
  next() {
    if (this.pos < this.string.length)
      return this.string.charAt(this.pos++);
  }
  /**
  Match the next character against the given string, regular
  expression, or predicate. Consume and return it if it matches.
  */
  eat(e) {
    let t = this.string.charAt(this.pos), i;
    if (typeof e == "string" ? i = t == e : i = t && (e instanceof RegExp ? e.test(t) : e(t)), i)
      return ++this.pos, t;
  }
  /**
  Continue matching characters that match the given string,
  regular expression, or predicate function. Return true if any
  characters were consumed.
  */
  eatWhile(e) {
    let t = this.pos;
    for (; this.eat(e); )
      ;
    return this.pos > t;
  }
  /**
  Consume whitespace ahead of `this.pos`. Return true if any was
  found.
  */
  eatSpace() {
    let e = this.pos;
    for (; /[\s\u00a0]/.test(this.string.charAt(this.pos)); )
      ++this.pos;
    return this.pos > e;
  }
  /**
  Move to the end of the line.
  */
  skipToEnd() {
    this.pos = this.string.length;
  }
  /**
  Move to directly before the given character, if found on the
  current line.
  */
  skipTo(e) {
    let t = this.string.indexOf(e, this.pos);
    if (t > -1)
      return this.pos = t, !0;
  }
  /**
  Move back `n` characters.
  */
  backUp(e) {
    this.pos -= e;
  }
  /**
  Get the column position at `this.pos`.
  */
  column() {
    return this.lastColumnPos < this.start && (this.lastColumnValue = op(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue;
  }
  /**
  Get the indentation column of the current line.
  */
  indentation() {
    var e;
    return (e = this.overrideIndent) !== null && e !== void 0 ? e : op(this.string, null, this.tabSize);
  }
  /**
  Match the input against the given string or regular expression
  (which should start with a `^`). Return true or the regexp match
  if it matches.
  
  Unless `consume` is set to `false`, this will move `this.pos`
  past the matched text.
  
  When matching a string `caseInsensitive` can be set to true to
  make the match case-insensitive.
  */
  match(e, t, i) {
    if (typeof e == "string") {
      let n = (o) => i ? o.toLowerCase() : o, s = this.string.substr(this.pos, e.length);
      return n(s) == n(e) ? (t !== !1 && (this.pos += e.length), !0) : null;
    } else {
      let n = this.string.slice(this.pos).match(e);
      return n && n.index > 0 ? null : (n && t !== !1 && (this.pos += n[0].length), n);
    }
  }
  /**
  Get the current token.
  */
  current() {
    return this.string.slice(this.start, this.pos);
  }
}
function uk(r) {
  return {
    name: r.name || "",
    token: r.token,
    blankLine: r.blankLine || (() => {
    }),
    startState: r.startState || (() => !0),
    copyState: r.copyState || dk,
    indent: r.indent || (() => null),
    languageData: r.languageData || {},
    tokenTable: r.tokenTable || _c
  };
}
function dk(r) {
  if (typeof r != "object")
    return r;
  let e = {};
  for (let t in r) {
    let i = r[t];
    e[t] = i instanceof Array ? i.slice() : i;
  }
  return e;
}
const lp = /* @__PURE__ */ new WeakMap();
class Xc extends nt {
  constructor(e) {
    let t = gl(e.languageData), i = uk(e), n, s = new class extends ml {
      createParse(o, l, a) {
        return new fk(n, o, l, a);
      }
    }();
    super(t, s, [Um.of((o, l) => this.getIndent(o, l))], e.name), this.topNode = gk(t), n = this, this.streamParser = i, this.stateAfter = new Y({ perNode: !0 }), this.tokenTable = e.tokenTable ? new fg(i.tokenTable) : mk;
  }
  /**
  Define a stream language.
  */
  static define(e) {
    return new Xc(e);
  }
  getIndent(e, t) {
    let i = te(e.state), n = i.resolve(t);
    for (; n && n.type != this.topNode; )
      n = n.parent;
    if (!n)
      return null;
    let s, { overrideIndentation: o } = e.options;
    o && (s = lp.get(e.state), s != null && s < t - 1e4 && (s = void 0));
    let l = Zc(this, i, 0, n.from, s ?? t), a, h;
    if (l ? (h = l.state, a = l.pos + 1) : (h = this.streamParser.startState(e.unit), a = 0), t - a > 1e4)
      return null;
    for (; a < t; ) {
      let u = e.state.doc.lineAt(a), d = Math.min(t, u.to);
      if (u.length) {
        let p = o ? o(u.from) : -1, f = new cg(u.text, e.state.tabSize, e.unit, p < 0 ? void 0 : p);
        for (; f.pos < d - u.from; )
          dg(this.streamParser.token, f, h);
      } else
        this.streamParser.blankLine(h, e.unit);
      if (d == t)
        break;
      a = u.to + 1;
    }
    let c = e.lineAt(t);
    return o && s == null && lp.set(e.state, c.from), this.streamParser.indent(h, /^\s*(.*)/.exec(c.text)[1], e);
  }
  get allowsNesting() {
    return !1;
  }
}
function Zc(r, e, t, i, n) {
  let s = t >= i && t + e.length <= n && e.prop(r.stateAfter);
  if (s)
    return { state: r.streamParser.copyState(s), pos: t + e.length };
  for (let o = e.children.length - 1; o >= 0; o--) {
    let l = e.children[o], a = t + e.positions[o], h = l instanceof D && a < n && Zc(r, l, a, i, n);
    if (h)
      return h;
  }
  return null;
}
function ug(r, e, t, i, n) {
  if (n && t <= 0 && i >= e.length)
    return e;
  !n && e.type == r.topNode && (n = !0);
  for (let s = e.children.length - 1; s >= 0; s--) {
    let o = e.positions[s], l = e.children[s], a;
    if (o < i && l instanceof D) {
      if (!(a = ug(r, l, t - o, i - o, n)))
        break;
      return n ? new D(e.type, e.children.slice(0, s).concat(a), e.positions.slice(0, s + 1), o + a.length) : a;
    }
  }
  return null;
}
function pk(r, e, t, i) {
  for (let n of e) {
    let s = n.from + (n.openStart ? 25 : 0), o = n.to - (n.openEnd ? 25 : 0), l = s <= t && o > t && Zc(r, n.tree, 0 - n.offset, t, o), a;
    if (l && (a = ug(r, n.tree, t + n.offset, l.pos + n.offset, !1)))
      return { state: l.state, tree: a };
  }
  return { state: r.streamParser.startState(i ? ur(i) : 4), tree: D.empty };
}
let fk = class {
  constructor(e, t, i, n) {
    this.lang = e, this.input = t, this.fragments = i, this.ranges = n, this.stoppedAt = null, this.chunks = [], this.chunkPos = [], this.chunk = [], this.chunkReused = void 0, this.rangeIndex = 0, this.to = n[n.length - 1].to;
    let s = pi.get(), o = n[0].from, { state: l, tree: a } = pk(e, i, o, s == null ? void 0 : s.state);
    this.state = l, this.parsedPos = this.chunkStart = o + a.length;
    for (let h = 0; h < a.children.length; h++)
      this.chunks.push(a.children[h]), this.chunkPos.push(a.positions[h]);
    s && this.parsedPos < s.viewport.from - 1e5 && (this.state = this.lang.streamParser.startState(ur(s.state)), s.skipUntilInView(this.parsedPos, s.viewport.from), this.parsedPos = s.viewport.from), this.moveRangeIndex();
  }
  advance() {
    let e = pi.get(), t = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt), i = Math.min(
      t,
      this.chunkStart + 2048
      /* C.ChunkSize */
    );
    for (e && (i = Math.min(i, e.viewport.to)); this.parsedPos < i; )
      this.parseLine(e);
    return this.chunkStart < this.parsedPos && this.finishChunk(), this.parsedPos >= t ? this.finish() : e && this.parsedPos >= e.viewport.to ? (e.skipUntilInView(this.parsedPos, t), this.finish()) : null;
  }
  stopAt(e) {
    this.stoppedAt = e;
  }
  lineAfter(e) {
    let t = this.input.chunk(e);
    if (this.input.lineChunks)
      t == `
` && (t = "");
    else {
      let i = t.indexOf(`
`);
      i > -1 && (t = t.slice(0, i));
    }
    return e + t.length <= this.to ? t : t.slice(0, this.to - e);
  }
  nextLine() {
    let e = this.parsedPos, t = this.lineAfter(e), i = e + t.length;
    for (let n = this.rangeIndex; ; ) {
      let s = this.ranges[n].to;
      if (s >= i || (t = t.slice(0, s - (i - t.length)), n++, n == this.ranges.length))
        break;
      let o = this.ranges[n].from, l = this.lineAfter(o);
      t += l, i = o + l.length;
    }
    return { line: t, end: i };
  }
  skipGapsTo(e, t, i) {
    for (; ; ) {
      let n = this.ranges[this.rangeIndex].to, s = e + t;
      if (i > 0 ? n > s : n >= s)
        break;
      let o = this.ranges[++this.rangeIndex].from;
      t += o - n;
    }
    return t;
  }
  moveRangeIndex() {
    for (; this.ranges[this.rangeIndex].to < this.parsedPos; )
      this.rangeIndex++;
  }
  emitToken(e, t, i, n, s) {
    if (this.ranges.length > 1) {
      s = this.skipGapsTo(t, s, 1), t += s;
      let o = this.chunk.length;
      s = this.skipGapsTo(i, s, -1), i += s, n += this.chunk.length - o;
    }
    return this.chunk.push(e, t, i, n), s;
  }
  parseLine(e) {
    let { line: t, end: i } = this.nextLine(), n = 0, { streamParser: s } = this.lang, o = new cg(t, e ? e.state.tabSize : 4, e ? ur(e.state) : 2);
    if (o.eol())
      s.blankLine(this.state, o.indentUnit);
    else
      for (; !o.eol(); ) {
        let l = dg(s.token, o, this.state);
        if (l && (n = this.emitToken(this.lang.tokenTable.resolve(l), this.parsedPos + o.start, this.parsedPos + o.pos, 4, n)), o.start > 1e4)
          break;
      }
    this.parsedPos = i, this.moveRangeIndex(), this.parsedPos < this.to && this.parsedPos++;
  }
  finishChunk() {
    let e = D.build({
      buffer: this.chunk,
      start: this.chunkStart,
      length: this.parsedPos - this.chunkStart,
      nodeSet: Ok,
      topID: 0,
      maxBufferLength: 2048,
      reused: this.chunkReused
    });
    e = new D(e.type, e.children, e.positions, e.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]), this.chunks.push(e), this.chunkPos.push(this.chunkStart - this.ranges[0].from), this.chunk = [], this.chunkReused = void 0, this.chunkStart = this.parsedPos;
  }
  finish() {
    return new D(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();
  }
};
function dg(r, e, t) {
  e.start = e.pos;
  for (let i = 0; i < 10; i++) {
    let n = r(e, t);
    if (e.pos > e.start)
      return n;
  }
  throw new Error("Stream parser failed to advance stream.");
}
const _c = /* @__PURE__ */ Object.create(null), is = [ye.none], Ok = /* @__PURE__ */ new rn(is), ap = [], hp = /* @__PURE__ */ Object.create(null), pg = /* @__PURE__ */ Object.create(null);
for (let [r, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  pg[r] = /* @__PURE__ */ Og(_c, e);
class fg {
  constructor(e) {
    this.extra = e, this.table = Object.assign(/* @__PURE__ */ Object.create(null), pg);
  }
  resolve(e) {
    return e ? this.table[e] || (this.table[e] = Og(this.extra, e)) : 0;
  }
}
const mk = /* @__PURE__ */ new fg(_c);
function ha(r, e) {
  ap.indexOf(r) > -1 || (ap.push(r), console.warn(e));
}
function Og(r, e) {
  let t = [];
  for (let l of e.split(" ")) {
    let a = [];
    for (let h of l.split(".")) {
      let c = r[h] || O[h];
      c ? typeof c == "function" ? a.length ? a = a.map(c) : ha(h, `Modifier ${h} used at start of tag`) : a.length ? ha(h, `Tag ${h} used as modifier`) : a = Array.isArray(c) ? c : [c] : ha(h, `Unknown highlighting tag ${h}`);
    }
    for (let h of a)
      t.push(h);
  }
  if (!t.length)
    return 0;
  let i = e.replace(/ /g, "_"), n = i + " " + t.map((l) => l.id), s = hp[n];
  if (s)
    return s.id;
  let o = hp[n] = ye.define({
    id: is.length,
    name: i,
    props: [Jt({ [i]: t })]
  });
  return is.push(o), o.id;
}
function gk(r) {
  let e = ye.define({ id: is.length, name: "Document", props: [kr.add(() => r)], top: !0 });
  return is.push(e), e;
}
ce.RTL, ce.LTR;
const mg = (r) => {
  let { state: e } = r, t = e.doc.lineAt(e.selection.main.from), i = Ac(r.state, t.from);
  return i.line ? bk(r) : i.block ? wk(r) : !1;
};
function Rc(r, e) {
  return ({ state: t, dispatch: i }) => {
    if (t.readOnly)
      return !1;
    let n = r(e, t);
    return n ? (i(t.update(n)), !0) : !1;
  };
}
const bk = /* @__PURE__ */ Rc(
  xk,
  0
  /* CommentOption.Toggle */
), gg = /* @__PURE__ */ Rc(
  bg,
  0
  /* CommentOption.Toggle */
), wk = /* @__PURE__ */ Rc(
  (r, e) => bg(r, e, vk(e)),
  0
  /* CommentOption.Toggle */
);
function Ac(r, e) {
  let t = r.languageDataAt("commentTokens", e);
  return t.length ? t[0] : {};
}
const bn = 50;
function yk(r, { open: e, close: t }, i, n) {
  let s = r.sliceDoc(i - bn, i), o = r.sliceDoc(n, n + bn), l = /\s*$/.exec(s)[0].length, a = /^\s*/.exec(o)[0].length, h = s.length - l;
  if (s.slice(h - e.length, h) == e && o.slice(a, a + t.length) == t)
    return {
      open: { pos: i - l, margin: l && 1 },
      close: { pos: n + a, margin: a && 1 }
    };
  let c, u;
  n - i <= 2 * bn ? c = u = r.sliceDoc(i, n) : (c = r.sliceDoc(i, i + bn), u = r.sliceDoc(n - bn, n));
  let d = /^\s*/.exec(c)[0].length, p = /\s*$/.exec(u)[0].length, f = u.length - p - t.length;
  return c.slice(d, d + e.length) == e && u.slice(f, f + t.length) == t ? {
    open: {
      pos: i + d + e.length,
      margin: /\s/.test(c.charAt(d + e.length)) ? 1 : 0
    },
    close: {
      pos: n - p - t.length,
      margin: /\s/.test(u.charAt(f - 1)) ? 1 : 0
    }
  } : null;
}
function vk(r) {
  let e = [];
  for (let t of r.selection.ranges) {
    let i = r.doc.lineAt(t.from), n = t.to <= i.to ? i : r.doc.lineAt(t.to), s = e.length - 1;
    s >= 0 && e[s].to > i.from ? e[s].to = n.to : e.push({ from: i.from + /^\s*/.exec(i.text)[0].length, to: n.to });
  }
  return e;
}
function bg(r, e, t = e.selection.ranges) {
  let i = t.map((s) => Ac(e, s.from).block);
  if (!i.every((s) => s))
    return null;
  let n = t.map((s, o) => yk(e, i[o], s.from, s.to));
  if (r != 2 && !n.every((s) => s))
    return { changes: e.changes(t.map((s, o) => n[o] ? [] : [{ from: s.from, insert: i[o].open + " " }, { from: s.to, insert: " " + i[o].close }])) };
  if (r != 1 && n.some((s) => s)) {
    let s = [];
    for (let o = 0, l; o < n.length; o++)
      if (l = n[o]) {
        let a = i[o], { open: h, close: c } = l;
        s.push({ from: h.pos - a.open.length, to: h.pos + h.margin }, { from: c.pos - c.margin, to: c.pos + a.close.length });
      }
    return { changes: s };
  }
  return null;
}
function xk(r, e, t = e.selection.ranges) {
  let i = [], n = -1;
  for (let { from: s, to: o } of t) {
    let l = i.length, a = 1e9, h = Ac(e, s).line;
    if (h) {
      for (let c = s; c <= o; ) {
        let u = e.doc.lineAt(c);
        if (u.from > n && (s == o || o > u.from)) {
          n = u.from;
          let d = /^\s*/.exec(u.text)[0].length, p = d == u.length, f = u.text.slice(d, d + h.length) == h ? d : -1;
          d < u.text.length && d < a && (a = d), i.push({ line: u, comment: f, token: h, indent: d, empty: p, single: !1 });
        }
        c = u.to + 1;
      }
      if (a < 1e9)
        for (let c = l; c < i.length; c++)
          i[c].indent < i[c].line.text.length && (i[c].indent = a);
      i.length == l + 1 && (i[l].single = !0);
    }
  }
  if (r != 2 && i.some((s) => s.comment < 0 && (!s.empty || s.single))) {
    let s = [];
    for (let { line: l, token: a, indent: h, empty: c, single: u } of i)
      (u || !c) && s.push({ from: l.from + h, insert: a + " " });
    let o = e.changes(s);
    return { changes: o, selection: e.selection.map(o, 1) };
  } else if (r != 1 && i.some((s) => s.comment >= 0)) {
    let s = [];
    for (let { line: o, comment: l, token: a } of i)
      if (l >= 0) {
        let h = o.from + l, c = h + a.length;
        o.text[c - o.from] == " " && c++, s.push({ from: h, to: c });
      }
    return { changes: s };
  }
  return null;
}
const Ch = /* @__PURE__ */ pr.define(), Sk = /* @__PURE__ */ pr.define(), kk = /* @__PURE__ */ _.define(), wg = /* @__PURE__ */ _.define({
  combine(r) {
    return _t(r, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (e, t) => t
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (e, t) => (i, n) => e(i, n) || t(i, n)
    });
  }
}), yg = /* @__PURE__ */ Qe.define({
  create() {
    return Dt.empty;
  },
  update(r, e) {
    let t = e.state.facet(wg), i = e.annotation(Ch);
    if (i) {
      let a = Ne.fromTransaction(e, i.selection), h = i.side, c = h == 0 ? r.undone : r.done;
      return a ? c = jo(c, c.length, t.minDepth, a) : c = xg(c, e.startState.selection), new Dt(h == 0 ? i.rest : c, h == 0 ? c : i.rest);
    }
    let n = e.annotation(Sk);
    if ((n == "full" || n == "before") && (r = r.isolate()), e.annotation(we.addToHistory) === !1)
      return e.changes.empty ? r : r.addMapping(e.changes.desc);
    let s = Ne.fromTransaction(e), o = e.annotation(we.time), l = e.annotation(we.userEvent);
    return s ? r = r.addChanges(s, o, l, t, e) : e.selection && (r = r.addSelection(e.startState.selection, o, l, t.newGroupDelay)), (n == "full" || n == "after") && (r = r.isolate()), r;
  },
  toJSON(r) {
    return { done: r.done.map((e) => e.toJSON()), undone: r.undone.map((e) => e.toJSON()) };
  },
  fromJSON(r) {
    return new Dt(r.done.map(Ne.fromJSON), r.undone.map(Ne.fromJSON));
  }
});
function $k(r = {}) {
  return [
    yg,
    wg.of(r),
    Z.domEventHandlers({
      beforeinput(e, t) {
        let i = e.inputType == "historyUndo" ? Ec : e.inputType == "historyRedo" ? Mo : null;
        return i ? (e.preventDefault(), i(t)) : !1;
      }
    })
  ];
}
function vl(r, e) {
  return function({ state: t, dispatch: i }) {
    if (!e && t.readOnly)
      return !1;
    let n = t.field(yg, !1);
    if (!n)
      return !1;
    let s = n.pop(r, t, e);
    return s ? (i(s), !0) : !1;
  };
}
const Ec = /* @__PURE__ */ vl(0, !1), Mo = /* @__PURE__ */ vl(1, !1), Qk = /* @__PURE__ */ vl(0, !0), Pk = /* @__PURE__ */ vl(1, !0);
class Ne {
  constructor(e, t, i, n, s) {
    this.changes = e, this.effects = t, this.mapped = i, this.startSelection = n, this.selectionsAfter = s;
  }
  setSelAfter(e) {
    return new Ne(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, t, i;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (t = this.mapped) === null || t === void 0 ? void 0 : t.toJSON(),
      startSelection: (i = this.startSelection) === null || i === void 0 ? void 0 : i.toJSON(),
      selectionsAfter: this.selectionsAfter.map((n) => n.toJSON())
    };
  }
  static fromJSON(e) {
    return new Ne(e.changes && ke.fromJSON(e.changes), [], e.mapped && It.fromJSON(e.mapped), e.startSelection && S.fromJSON(e.startSelection), e.selectionsAfter.map(S.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(e, t) {
    let i = Ot;
    for (let n of e.startState.facet(kk)) {
      let s = n(e);
      s.length && (i = i.concat(s));
    }
    return !i.length && e.changes.empty ? null : new Ne(e.changes.invert(e.startState.doc), i, void 0, t || e.startState.selection, Ot);
  }
  static selection(e) {
    return new Ne(void 0, Ot, void 0, void 0, e);
  }
}
function jo(r, e, t, i) {
  let n = e + 1 > t + 20 ? e - t - 1 : 0, s = r.slice(n, e);
  return s.push(i), s;
}
function Tk(r, e) {
  let t = [], i = !1;
  return r.iterChangedRanges((n, s) => t.push(n, s)), e.iterChangedRanges((n, s, o, l) => {
    for (let a = 0; a < t.length; ) {
      let h = t[a++], c = t[a++];
      l >= h && o <= c && (i = !0);
    }
  }), i;
}
function Ck(r, e) {
  return r.ranges.length == e.ranges.length && r.ranges.filter((t, i) => t.empty != e.ranges[i].empty).length === 0;
}
function vg(r, e) {
  return r.length ? e.length ? r.concat(e) : r : e;
}
const Ot = [], Xk = 200;
function xg(r, e) {
  if (r.length) {
    let t = r[r.length - 1], i = t.selectionsAfter.slice(Math.max(0, t.selectionsAfter.length - Xk));
    return i.length && i[i.length - 1].eq(e) ? r : (i.push(e), jo(r, r.length - 1, 1e9, t.setSelAfter(i)));
  } else
    return [Ne.selection([e])];
}
function Zk(r) {
  let e = r[r.length - 1], t = r.slice();
  return t[r.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), t;
}
function ca(r, e) {
  if (!r.length)
    return r;
  let t = r.length, i = Ot;
  for (; t; ) {
    let n = _k(r[t - 1], e, i);
    if (n.changes && !n.changes.empty || n.effects.length) {
      let s = r.slice(0, t);
      return s[t - 1] = n, s;
    } else
      e = n.mapped, t--, i = n.selectionsAfter;
  }
  return i.length ? [Ne.selection(i)] : Ot;
}
function _k(r, e, t) {
  let i = vg(r.selectionsAfter.length ? r.selectionsAfter.map((l) => l.map(e)) : Ot, t);
  if (!r.changes)
    return Ne.selection(i);
  let n = r.changes.map(e), s = e.mapDesc(r.changes, !0), o = r.mapped ? r.mapped.composeDesc(s) : s;
  return new Ne(n, j.mapEffects(r.effects, e), o, r.startSelection.map(s), i);
}
const Rk = /^(input\.type|delete)($|\.)/;
class Dt {
  constructor(e, t, i = 0, n = void 0) {
    this.done = e, this.undone = t, this.prevTime = i, this.prevUserEvent = n;
  }
  isolate() {
    return this.prevTime ? new Dt(this.done, this.undone) : this;
  }
  addChanges(e, t, i, n, s) {
    let o = this.done, l = o[o.length - 1];
    return l && l.changes && !l.changes.empty && e.changes && (!i || Rk.test(i)) && (!l.selectionsAfter.length && t - this.prevTime < n.newGroupDelay && n.joinToEvent(s, Tk(l.changes, e.changes)) || // For compose (but not compose.start) events, always join with previous event
    i == "input.type.compose") ? o = jo(o, o.length - 1, n.minDepth, new Ne(e.changes.compose(l.changes), vg(e.effects, l.effects), l.mapped, l.startSelection, Ot)) : o = jo(o, o.length, n.minDepth, e), new Dt(o, Ot, t, i);
  }
  addSelection(e, t, i, n) {
    let s = this.done.length ? this.done[this.done.length - 1].selectionsAfter : Ot;
    return s.length > 0 && t - this.prevTime < n && i == this.prevUserEvent && i && /^select($|\.)/.test(i) && Ck(s[s.length - 1], e) ? this : new Dt(xg(this.done, e), this.undone, t, i);
  }
  addMapping(e) {
    return new Dt(ca(this.done, e), ca(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, t, i) {
    let n = e == 0 ? this.done : this.undone;
    if (n.length == 0)
      return null;
    let s = n[n.length - 1], o = s.selectionsAfter[0] || t.selection;
    if (i && s.selectionsAfter.length)
      return t.update({
        selection: s.selectionsAfter[s.selectionsAfter.length - 1],
        annotations: Ch.of({ side: e, rest: Zk(n), selection: o }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (s.changes) {
      let l = n.length == 1 ? Ot : n.slice(0, n.length - 1);
      return s.mapped && (l = ca(l, s.mapped)), t.update({
        changes: s.changes,
        selection: s.startSelection,
        effects: s.effects,
        annotations: Ch.of({ side: e, rest: l, selection: o }),
        filter: !1,
        userEvent: e == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}
Dt.empty = /* @__PURE__ */ new Dt(Ot, Ot);
const Sg = [
  { key: "Mod-z", run: Ec, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: Mo, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: Mo, preventDefault: !0 },
  { key: "Mod-u", run: Qk, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: Pk, preventDefault: !0 }
];
function nn(r, e) {
  return S.create(r.ranges.map(e), r.mainIndex);
}
function er(r, e) {
  return r.update({ selection: e, scrollIntoView: !0, userEvent: "select" });
}
function Rt({ state: r, dispatch: e }, t) {
  let i = nn(r.selection, t);
  return i.eq(r.selection, !0) ? !1 : (e(er(r, i)), !0);
}
function xl(r, e) {
  return S.cursor(e ? r.to : r.from);
}
function kg(r, e) {
  return Rt(r, (t) => t.empty ? r.moveByChar(t, e) : xl(t, e));
}
function Ve(r) {
  return r.textDirectionAt(r.state.selection.main.head) == ce.LTR;
}
const $g = (r) => kg(r, !Ve(r)), Qg = (r) => kg(r, Ve(r));
function Pg(r, e) {
  return Rt(r, (t) => t.empty ? r.moveByGroup(t, e) : xl(t, e));
}
const Ak = (r) => Pg(r, !Ve(r)), Ek = (r) => Pg(r, Ve(r));
function qk(r, e, t) {
  if (e.type.prop(t))
    return !0;
  let i = e.to - e.from;
  return i && (i > 2 || /[^\s,.;:]/.test(r.sliceDoc(e.from, e.to))) || e.firstChild;
}
function Sl(r, e, t) {
  let i = te(r).resolveInner(e.head), n = t ? Y.closedBy : Y.openedBy;
  for (let a = e.head; ; ) {
    let h = t ? i.childAfter(a) : i.childBefore(a);
    if (!h)
      break;
    qk(r, h, n) ? i = h : a = t ? h.to : h.from;
  }
  let s = i.type.prop(n), o, l;
  return s && (o = t ? Bt(r, i.from, 1) : Bt(r, i.to, -1)) && o.matched ? l = t ? o.end.to : o.end.from : l = t ? i.to : i.from, S.cursor(l, t ? -1 : 1);
}
const zk = (r) => Rt(r, (e) => Sl(r.state, e, !Ve(r))), Yk = (r) => Rt(r, (e) => Sl(r.state, e, Ve(r)));
function Tg(r, e) {
  return Rt(r, (t) => {
    if (!t.empty)
      return xl(t, e);
    let i = r.moveVertically(t, e);
    return i.head != t.head ? i : r.moveToLineBoundary(t, e);
  });
}
const Cg = (r) => Tg(r, !1), Xg = (r) => Tg(r, !0);
function Zg(r) {
  let e = r.scrollDOM.clientHeight < r.scrollDOM.scrollHeight - 2, t = 0, i = 0, n;
  if (e) {
    for (let s of r.state.facet(Z.scrollMargins)) {
      let o = s(r);
      o != null && o.top && (t = Math.max(o == null ? void 0 : o.top, t)), o != null && o.bottom && (i = Math.max(o == null ? void 0 : o.bottom, i));
    }
    n = r.scrollDOM.clientHeight - t - i;
  } else
    n = (r.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: t,
    marginBottom: i,
    selfScroll: e,
    height: Math.max(r.defaultLineHeight, n - 5)
  };
}
function _g(r, e) {
  let t = Zg(r), { state: i } = r, n = nn(i.selection, (o) => o.empty ? r.moveVertically(o, e, t.height) : xl(o, e));
  if (n.eq(i.selection))
    return !1;
  let s;
  if (t.selfScroll) {
    let o = r.coordsAtPos(i.selection.main.head), l = r.scrollDOM.getBoundingClientRect(), a = l.top + t.marginTop, h = l.bottom - t.marginBottom;
    o && o.top > a && o.bottom < h && (s = Z.scrollIntoView(n.main.head, { y: "start", yMargin: o.top - a }));
  }
  return r.dispatch(er(i, n), { effects: s }), !0;
}
const cp = (r) => _g(r, !1), Xh = (r) => _g(r, !0);
function Dr(r, e, t) {
  let i = r.lineBlockAt(e.head), n = r.moveToLineBoundary(e, t);
  if (n.head == e.head && n.head != (t ? i.to : i.from) && (n = r.moveToLineBoundary(e, t, !1)), !t && n.head == i.from && i.length) {
    let s = /^\s*/.exec(r.state.sliceDoc(i.from, Math.min(i.from + 100, i.to)))[0].length;
    s && e.head != i.from + s && (n = S.cursor(i.from + s));
  }
  return n;
}
const Wk = (r) => Rt(r, (e) => Dr(r, e, !0)), Vk = (r) => Rt(r, (e) => Dr(r, e, !1)), Mk = (r) => Rt(r, (e) => Dr(r, e, !Ve(r))), jk = (r) => Rt(r, (e) => Dr(r, e, Ve(r))), Lk = (r) => Rt(r, (e) => S.cursor(r.lineBlockAt(e.head).from, 1)), Bk = (r) => Rt(r, (e) => S.cursor(r.lineBlockAt(e.head).to, -1));
function Dk(r, e, t) {
  let i = !1, n = nn(r.selection, (s) => {
    let o = Bt(r, s.head, -1) || Bt(r, s.head, 1) || s.head > 0 && Bt(r, s.head - 1, 1) || s.head < r.doc.length && Bt(r, s.head + 1, -1);
    if (!o || !o.end)
      return s;
    i = !0;
    let l = o.start.from == s.head ? o.end.to : o.end.from;
    return t ? S.range(s.anchor, l) : S.cursor(l);
  });
  return i ? (e(er(r, n)), !0) : !1;
}
const Ik = ({ state: r, dispatch: e }) => Dk(r, e, !1);
function St(r, e) {
  let t = nn(r.state.selection, (i) => {
    let n = e(i);
    return S.range(i.anchor, n.head, n.goalColumn, n.bidiLevel || void 0);
  });
  return t.eq(r.state.selection) ? !1 : (r.dispatch(er(r.state, t)), !0);
}
function Rg(r, e) {
  return St(r, (t) => r.moveByChar(t, e));
}
const Ag = (r) => Rg(r, !Ve(r)), Eg = (r) => Rg(r, Ve(r));
function qg(r, e) {
  return St(r, (t) => r.moveByGroup(t, e));
}
const Uk = (r) => qg(r, !Ve(r)), Gk = (r) => qg(r, Ve(r)), Nk = (r) => St(r, (e) => Sl(r.state, e, !Ve(r))), Fk = (r) => St(r, (e) => Sl(r.state, e, Ve(r)));
function zg(r, e) {
  return St(r, (t) => r.moveVertically(t, e));
}
const Yg = (r) => zg(r, !1), Wg = (r) => zg(r, !0);
function Vg(r, e) {
  return St(r, (t) => r.moveVertically(t, e, Zg(r).height));
}
const up = (r) => Vg(r, !1), dp = (r) => Vg(r, !0), Hk = (r) => St(r, (e) => Dr(r, e, !0)), Kk = (r) => St(r, (e) => Dr(r, e, !1)), Jk = (r) => St(r, (e) => Dr(r, e, !Ve(r))), e$ = (r) => St(r, (e) => Dr(r, e, Ve(r))), t$ = (r) => St(r, (e) => S.cursor(r.lineBlockAt(e.head).from)), r$ = (r) => St(r, (e) => S.cursor(r.lineBlockAt(e.head).to)), pp = ({ state: r, dispatch: e }) => (e(er(r, { anchor: 0 })), !0), fp = ({ state: r, dispatch: e }) => (e(er(r, { anchor: r.doc.length })), !0), Op = ({ state: r, dispatch: e }) => (e(er(r, { anchor: r.selection.main.anchor, head: 0 })), !0), mp = ({ state: r, dispatch: e }) => (e(er(r, { anchor: r.selection.main.anchor, head: r.doc.length })), !0), i$ = ({ state: r, dispatch: e }) => (e(r.update({ selection: { anchor: 0, head: r.doc.length }, userEvent: "select" })), !0), n$ = ({ state: r, dispatch: e }) => {
  let t = kl(r).map(({ from: i, to: n }) => S.range(i, Math.min(n + 1, r.doc.length)));
  return e(r.update({ selection: S.create(t), userEvent: "select" })), !0;
}, s$ = ({ state: r, dispatch: e }) => {
  let t = nn(r.selection, (i) => {
    var n;
    let s = te(r).resolveStack(i.from, 1);
    for (let o = s; o; o = o.next) {
      let { node: l } = o;
      if ((l.from < i.from && l.to >= i.to || l.to > i.to && l.from <= i.from) && (!((n = l.parent) === null || n === void 0) && n.parent))
        return S.range(l.to, l.from);
    }
    return i;
  });
  return e(er(r, t)), !0;
}, o$ = ({ state: r, dispatch: e }) => {
  let t = r.selection, i = null;
  return t.ranges.length > 1 ? i = S.create([t.main]) : t.main.empty || (i = S.create([S.cursor(t.main.head)])), i ? (e(er(r, i)), !0) : !1;
};
function Qs(r, e) {
  if (r.state.readOnly)
    return !1;
  let t = "delete.selection", { state: i } = r, n = i.changeByRange((s) => {
    let { from: o, to: l } = s;
    if (o == l) {
      let a = e(s);
      a < o ? (t = "delete.backward", a = Fs(r, a, !1)) : a > o && (t = "delete.forward", a = Fs(r, a, !0)), o = Math.min(o, a), l = Math.max(l, a);
    } else
      o = Fs(r, o, !1), l = Fs(r, l, !0);
    return o == l ? { range: s } : { changes: { from: o, to: l }, range: S.cursor(o, o < s.head ? -1 : 1) };
  });
  return n.changes.empty ? !1 : (r.dispatch(i.update(n, {
    scrollIntoView: !0,
    userEvent: t,
    effects: t == "delete.selection" ? Z.announce.of(i.phrase("Selection deleted")) : void 0
  })), !0);
}
function Fs(r, e, t) {
  if (r instanceof Z)
    for (let i of r.state.facet(Z.atomicRanges).map((n) => n(r)))
      i.between(e, e, (n, s) => {
        n < e && s > e && (e = t ? s : n);
      });
  return e;
}
const Mg = (r, e) => Qs(r, (t) => {
  let i = t.from, { state: n } = r, s = n.doc.lineAt(i), o, l;
  if (!e && i > s.from && i < s.from + 200 && !/[^ \t]/.test(o = s.text.slice(0, i - s.from))) {
    if (o[o.length - 1] == "	")
      return i - 1;
    let a = Tt(o, n.tabSize), h = a % ur(n) || ur(n);
    for (let c = 0; c < h && o[o.length - 1 - c] == " "; c++)
      i--;
    l = i;
  } else
    l = _e(s.text, i - s.from, e, e) + s.from, l == i && s.number != (e ? n.doc.lines : 1) ? l += e ? 1 : -1 : !e && /[\ufe00-\ufe0f]/.test(s.text.slice(l - s.from, i - s.from)) && (l = _e(s.text, l - s.from, !1, !1) + s.from);
  return l;
}), Zh = (r) => Mg(r, !1), jg = (r) => Mg(r, !0), Lg = (r, e) => Qs(r, (t) => {
  let i = t.head, { state: n } = r, s = n.doc.lineAt(i), o = n.charCategorizer(i);
  for (let l = null; ; ) {
    if (i == (e ? s.to : s.from)) {
      i == t.head && s.number != (e ? n.doc.lines : 1) && (i += e ? 1 : -1);
      break;
    }
    let a = _e(s.text, i - s.from, e) + s.from, h = s.text.slice(Math.min(i, a) - s.from, Math.max(i, a) - s.from), c = o(h);
    if (l != null && c != l)
      break;
    (h != " " || i != t.head) && (l = c), i = a;
  }
  return i;
}), Bg = (r) => Lg(r, !1), l$ = (r) => Lg(r, !0), a$ = (r) => Qs(r, (e) => {
  let t = r.lineBlockAt(e.head).to;
  return e.head < t ? t : Math.min(r.state.doc.length, e.head + 1);
}), h$ = (r) => Qs(r, (e) => {
  let t = r.moveToLineBoundary(e, !1).head;
  return e.head > t ? t : Math.max(0, e.head - 1);
}), c$ = (r) => Qs(r, (e) => {
  let t = r.moveToLineBoundary(e, !0).head;
  return e.head < t ? t : Math.min(r.state.doc.length, e.head + 1);
}), u$ = ({ state: r, dispatch: e }) => {
  if (r.readOnly)
    return !1;
  let t = r.changeByRange((i) => ({
    changes: { from: i.from, to: i.to, insert: K.of(["", ""]) },
    range: S.cursor(i.from)
  }));
  return e(r.update(t, { scrollIntoView: !0, userEvent: "input" })), !0;
}, d$ = ({ state: r, dispatch: e }) => {
  if (r.readOnly)
    return !1;
  let t = r.changeByRange((i) => {
    if (!i.empty || i.from == 0 || i.from == r.doc.length)
      return { range: i };
    let n = i.from, s = r.doc.lineAt(n), o = n == s.from ? n - 1 : _e(s.text, n - s.from, !1) + s.from, l = n == s.to ? n + 1 : _e(s.text, n - s.from, !0) + s.from;
    return {
      changes: { from: o, to: l, insert: r.doc.slice(n, l).append(r.doc.slice(o, n)) },
      range: S.cursor(l)
    };
  });
  return t.changes.empty ? !1 : (e(r.update(t, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function kl(r) {
  let e = [], t = -1;
  for (let i of r.selection.ranges) {
    let n = r.doc.lineAt(i.from), s = r.doc.lineAt(i.to);
    if (!i.empty && i.to == s.from && (s = r.doc.lineAt(i.to - 1)), t >= n.number) {
      let o = e[e.length - 1];
      o.to = s.to, o.ranges.push(i);
    } else
      e.push({ from: n.from, to: s.to, ranges: [i] });
    t = s.number + 1;
  }
  return e;
}
function Dg(r, e, t) {
  if (r.readOnly)
    return !1;
  let i = [], n = [];
  for (let s of kl(r)) {
    if (t ? s.to == r.doc.length : s.from == 0)
      continue;
    let o = r.doc.lineAt(t ? s.to + 1 : s.from - 1), l = o.length + 1;
    if (t) {
      i.push({ from: s.to, to: o.to }, { from: s.from, insert: o.text + r.lineBreak });
      for (let a of s.ranges)
        n.push(S.range(Math.min(r.doc.length, a.anchor + l), Math.min(r.doc.length, a.head + l)));
    } else {
      i.push({ from: o.from, to: s.from }, { from: s.to, insert: r.lineBreak + o.text });
      for (let a of s.ranges)
        n.push(S.range(a.anchor - l, a.head - l));
    }
  }
  return i.length ? (e(r.update({
    changes: i,
    scrollIntoView: !0,
    selection: S.create(n, r.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const p$ = ({ state: r, dispatch: e }) => Dg(r, e, !1), f$ = ({ state: r, dispatch: e }) => Dg(r, e, !0);
function Ig(r, e, t) {
  if (r.readOnly)
    return !1;
  let i = [];
  for (let n of kl(r))
    t ? i.push({ from: n.from, insert: r.doc.slice(n.from, n.to) + r.lineBreak }) : i.push({ from: n.to, insert: r.lineBreak + r.doc.slice(n.from, n.to) });
  return e(r.update({ changes: i, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const O$ = ({ state: r, dispatch: e }) => Ig(r, e, !1), m$ = ({ state: r, dispatch: e }) => Ig(r, e, !0), g$ = (r) => {
  if (r.state.readOnly)
    return !1;
  let { state: e } = r, t = e.changes(kl(e).map(({ from: n, to: s }) => (n > 0 ? n-- : s < e.doc.length && s++, { from: n, to: s }))), i = nn(e.selection, (n) => r.moveVertically(n, !0)).map(t);
  return r.dispatch({ changes: t, selection: i, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function b$(r, e) {
  if (/\(\)|\[\]|\{\}/.test(r.sliceDoc(e - 1, e + 1)))
    return { from: e, to: e };
  let t = te(r).resolveInner(e), i = t.childBefore(e), n = t.childAfter(e), s;
  return i && n && i.to <= e && n.from >= e && (s = i.type.prop(Y.closedBy)) && s.indexOf(n.name) > -1 && r.doc.lineAt(i.to).from == r.doc.lineAt(n.from).from && !/\S/.test(r.sliceDoc(i.to, n.from)) ? { from: i.to, to: n.from } : null;
}
const w$ = /* @__PURE__ */ Ug(!1), y$ = /* @__PURE__ */ Ug(!0);
function Ug(r) {
  return ({ state: e, dispatch: t }) => {
    if (e.readOnly)
      return !1;
    let i = e.changeByRange((n) => {
      let { from: s, to: o } = n, l = e.doc.lineAt(s), a = !r && s == o && b$(e, s);
      r && (s = o = (o <= l.to ? l : e.doc.lineAt(o)).to);
      let h = new bl(e, { simulateBreak: s, simulateDoubleBreak: !!a }), c = Pc(h, s);
      for (c == null && (c = Tt(/^\s*/.exec(e.doc.lineAt(s).text)[0], e.tabSize)); o < l.to && /\s/.test(l.text[o - l.from]); )
        o++;
      a ? { from: s, to: o } = a : s > l.from && s < l.from + 100 && !/\S/.test(l.text.slice(0, s)) && (s = l.from);
      let u = ["", rs(e, c)];
      return a && u.push(rs(e, h.lineIndent(l.from, -1))), {
        changes: { from: s, to: o, insert: K.of(u) },
        range: S.cursor(s + 1 + u[1].length)
      };
    });
    return t(e.update(i, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function qc(r, e) {
  let t = -1;
  return r.changeByRange((i) => {
    let n = [];
    for (let o = i.from; o <= i.to; ) {
      let l = r.doc.lineAt(o);
      l.number > t && (i.empty || i.to > l.from) && (e(l, n, i), t = l.number), o = l.to + 1;
    }
    let s = r.changes(n);
    return {
      changes: n,
      range: S.range(s.mapPos(i.anchor, 1), s.mapPos(i.head, 1))
    };
  });
}
const v$ = ({ state: r, dispatch: e }) => {
  if (r.readOnly)
    return !1;
  let t = /* @__PURE__ */ Object.create(null), i = new bl(r, { overrideIndentation: (s) => {
    let o = t[s];
    return o ?? -1;
  } }), n = qc(r, (s, o, l) => {
    let a = Pc(i, s.from);
    if (a == null)
      return;
    /\S/.test(s.text) || (a = 0);
    let h = /^\s*/.exec(s.text)[0], c = rs(r, a);
    (h != c || l.from < s.from + h.length) && (t[s.from] = a, o.push({ from: s.from, to: s.from + h.length, insert: c }));
  });
  return n.changes.empty || e(r.update(n, { userEvent: "indent" })), !0;
}, zc = ({ state: r, dispatch: e }) => r.readOnly ? !1 : (e(r.update(qc(r, (t, i) => {
  i.push({ from: t.from, insert: r.facet(fi) });
}), { userEvent: "input.indent" })), !0), Yc = ({ state: r, dispatch: e }) => r.readOnly ? !1 : (e(r.update(qc(r, (t, i) => {
  let n = /^\s*/.exec(t.text)[0];
  if (!n)
    return;
  let s = Tt(n, r.tabSize), o = 0, l = rs(r, Math.max(0, s - ur(r)));
  for (; o < n.length && o < l.length && n.charCodeAt(o) == l.charCodeAt(o); )
    o++;
  i.push({ from: t.from + o, to: t.from + n.length, insert: l.slice(o) });
}), { userEvent: "delete.dedent" })), !0), x$ = [
  { key: "Ctrl-b", run: $g, shift: Ag, preventDefault: !0 },
  { key: "Ctrl-f", run: Qg, shift: Eg },
  { key: "Ctrl-p", run: Cg, shift: Yg },
  { key: "Ctrl-n", run: Xg, shift: Wg },
  { key: "Ctrl-a", run: Lk, shift: t$ },
  { key: "Ctrl-e", run: Bk, shift: r$ },
  { key: "Ctrl-d", run: jg },
  { key: "Ctrl-h", run: Zh },
  { key: "Ctrl-k", run: a$ },
  { key: "Ctrl-Alt-h", run: Bg },
  { key: "Ctrl-o", run: u$ },
  { key: "Ctrl-t", run: d$ },
  { key: "Ctrl-v", run: Xh }
], S$ = /* @__PURE__ */ [
  { key: "ArrowLeft", run: $g, shift: Ag, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: Ak, shift: Uk, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: Mk, shift: Jk, preventDefault: !0 },
  { key: "ArrowRight", run: Qg, shift: Eg, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: Ek, shift: Gk, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: jk, shift: e$, preventDefault: !0 },
  { key: "ArrowUp", run: Cg, shift: Yg, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: pp, shift: Op },
  { mac: "Ctrl-ArrowUp", run: cp, shift: up },
  { key: "ArrowDown", run: Xg, shift: Wg, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: fp, shift: mp },
  { mac: "Ctrl-ArrowDown", run: Xh, shift: dp },
  { key: "PageUp", run: cp, shift: up },
  { key: "PageDown", run: Xh, shift: dp },
  { key: "Home", run: Vk, shift: Kk, preventDefault: !0 },
  { key: "Mod-Home", run: pp, shift: Op },
  { key: "End", run: Wk, shift: Hk, preventDefault: !0 },
  { key: "Mod-End", run: fp, shift: mp },
  { key: "Enter", run: w$ },
  { key: "Mod-a", run: i$ },
  { key: "Backspace", run: Zh, shift: Zh },
  { key: "Delete", run: jg },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: Bg },
  { key: "Mod-Delete", mac: "Alt-Delete", run: l$ },
  { mac: "Mod-Backspace", run: h$ },
  { mac: "Mod-Delete", run: c$ }
].concat(/* @__PURE__ */ x$.map((r) => ({ mac: r.key, run: r.run, shift: r.shift }))), Gg = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: zk, shift: Nk },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: Yk, shift: Fk },
  { key: "Alt-ArrowUp", run: p$ },
  { key: "Shift-Alt-ArrowUp", run: O$ },
  { key: "Alt-ArrowDown", run: f$ },
  { key: "Shift-Alt-ArrowDown", run: m$ },
  { key: "Escape", run: o$ },
  { key: "Mod-Enter", run: y$ },
  { key: "Alt-l", mac: "Ctrl-l", run: n$ },
  { key: "Mod-i", run: s$, preventDefault: !0 },
  { key: "Mod-[", run: Yc },
  { key: "Mod-]", run: zc },
  { key: "Mod-Alt-\\", run: v$ },
  { key: "Shift-Mod-k", run: g$ },
  { key: "Shift-Mod-\\", run: Ik },
  { key: "Mod-/", run: mg },
  { key: "Alt-A", run: gg }
].concat(S$), Ng = { key: "Tab", run: zc, shift: Yc };
function oe() {
  var r = arguments[0];
  typeof r == "string" && (r = document.createElement(r));
  var e = 1, t = arguments[1];
  if (t && typeof t == "object" && t.nodeType == null && !Array.isArray(t)) {
    for (var i in t)
      if (Object.prototype.hasOwnProperty.call(t, i)) {
        var n = t[i];
        typeof n == "string" ? r.setAttribute(i, n) : n != null && (r[i] = n);
      }
    e++;
  }
  for (; e < arguments.length; e++)
    Fg(r, arguments[e]);
  return r;
}
function Fg(r, e) {
  if (typeof e == "string")
    r.appendChild(document.createTextNode(e));
  else if (e != null)
    if (e.nodeType != null)
      r.appendChild(e);
    else if (Array.isArray(e))
      for (var t = 0; t < e.length; t++)
        Fg(r, e[t]);
    else
      throw new RangeError("Unsupported child node: " + e);
}
const gp = typeof String.prototype.normalize == "function" ? (r) => r.normalize("NFKD") : (r) => r;
class Ui {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(e, t, i = 0, n = e.length, s, o) {
    this.test = o, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(i, n), this.bufferStart = i, this.normalize = s ? (l) => s(gp(l)) : gp, this.query = this.normalize(t);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return Te(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = !0, this;
      let t = cc(e), i = this.bufferStart + this.bufferPos;
      this.bufferPos += dt(e);
      let n = this.normalize(t);
      for (let s = 0, o = i; ; s++) {
        let l = n.charCodeAt(s), a = this.match(l, o);
        if (s == n.length - 1) {
          if (a)
            return this.value = a, this;
          break;
        }
        o == i && s < t.length && t.charCodeAt(s) == l && o++;
      }
    }
  }
  match(e, t) {
    let i = null;
    for (let n = 0; n < this.matches.length; n += 2) {
      let s = this.matches[n], o = !1;
      this.query.charCodeAt(s) == e && (s == this.query.length - 1 ? i = { from: this.matches[n + 1], to: t + 1 } : (this.matches[n]++, o = !0)), o || (this.matches.splice(n, 2), n -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? i = { from: t, to: t + 1 } : this.matches.push(1, t)), i && this.test && !this.test(i.from, i.to, this.buffer, this.bufferStart) && (i = null), i;
  }
}
typeof Symbol < "u" && (Ui.prototype[Symbol.iterator] = function() {
  return this;
});
const Hg = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, Wc = "gm" + (/x/.unicode == null ? "" : "u");
class Kg {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(e, t, i, n = 0, s = e.length) {
    if (this.text = e, this.to = s, this.curLine = "", this.done = !1, this.value = Hg, /\\[sWDnr]|\n|\r|\[\^/.test(t))
      return new Jg(e, t, i, n, s);
    this.re = new RegExp(t, Wc + (i != null && i.ignoreCase ? "i" : "")), this.test = i == null ? void 0 : i.test, this.iter = e.iter();
    let o = e.lineAt(n);
    this.curLineStart = o.from, this.matchPos = Lo(e, n), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let t = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (t) {
        let i = this.curLineStart + t.index, n = i + t[0].length;
        if (this.matchPos = Lo(this.text, n + (i == n ? 1 : 0)), i == this.curLineStart + this.curLine.length && this.nextLine(), (i < n || i > this.value.to) && (!this.test || this.test(i, n, t)))
          return this.value = { from: i, to: n, match: t }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = !0, this;
    }
  }
}
const ua = /* @__PURE__ */ new WeakMap();
class Ri {
  constructor(e, t) {
    this.from = e, this.text = t;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, t, i) {
    let n = ua.get(e);
    if (!n || n.from >= i || n.to <= t) {
      let l = new Ri(t, e.sliceString(t, i));
      return ua.set(e, l), l;
    }
    if (n.from == t && n.to == i)
      return n;
    let { text: s, from: o } = n;
    return o > t && (s = e.sliceString(t, o) + s, o = t), n.to < i && (s += e.sliceString(n.to, i)), ua.set(e, new Ri(o, s)), new Ri(t, s.slice(t - o, i - o));
  }
}
class Jg {
  constructor(e, t, i, n, s) {
    this.text = e, this.to = s, this.done = !1, this.value = Hg, this.matchPos = Lo(e, n), this.re = new RegExp(t, Wc + (i != null && i.ignoreCase ? "i" : "")), this.test = i == null ? void 0 : i.test, this.flat = Ri.get(e, n, this.chunkEnd(
      n + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, t = this.re.exec(this.flat.text);
      if (t && !t[0] && t.index == e && (this.re.lastIndex = e + 1, t = this.re.exec(this.flat.text)), t) {
        let i = this.flat.from + t.index, n = i + t[0].length;
        if ((this.flat.to >= this.to || t.index + t[0].length <= this.flat.text.length - 10) && (!this.test || this.test(i, n, t)))
          return this.value = { from: i, to: n, match: t }, this.matchPos = Lo(this.text, n + (i == n ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = Ri.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" && (Kg.prototype[Symbol.iterator] = Jg.prototype[Symbol.iterator] = function() {
  return this;
});
function k$(r) {
  try {
    return new RegExp(r, Wc), !0;
  } catch {
    return !1;
  }
}
function Lo(r, e) {
  if (e >= r.length)
    return e;
  let t = r.lineAt(e), i;
  for (; e < t.to && (i = t.text.charCodeAt(e - t.from)) >= 56320 && i < 57344; )
    e++;
  return e;
}
function _h(r) {
  let e = String(r.state.doc.lineAt(r.state.selection.main.head).number), t = oe("input", { class: "cm-textfield", name: "line", value: e }), i = oe("form", {
    class: "cm-gotoLine",
    onkeydown: (s) => {
      s.keyCode == 27 ? (s.preventDefault(), r.dispatch({ effects: Bo.of(!1) }), r.focus()) : s.keyCode == 13 && (s.preventDefault(), n());
    },
    onsubmit: (s) => {
      s.preventDefault(), n();
    }
  }, oe("label", r.state.phrase("Go to line"), ": ", t), " ", oe("button", { class: "cm-button", type: "submit" }, r.state.phrase("go")));
  function n() {
    let s = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(t.value);
    if (!s)
      return;
    let { state: o } = r, l = o.doc.lineAt(o.selection.main.head), [, a, h, c, u] = s, d = c ? +c.slice(1) : 0, p = h ? +h : l.number;
    if (h && u) {
      let g = p / 100;
      a && (g = g * (a == "-" ? -1 : 1) + l.number / o.doc.lines), p = Math.round(o.doc.lines * g);
    } else
      h && a && (p = p * (a == "-" ? -1 : 1) + l.number);
    let f = o.doc.line(Math.max(1, Math.min(o.doc.lines, p))), m = S.cursor(f.from + Math.max(0, Math.min(d, f.length)));
    r.dispatch({
      effects: [Bo.of(!1), Z.scrollIntoView(m.from, { y: "center" })],
      selection: m
    }), r.focus();
  }
  return { dom: i };
}
const Bo = /* @__PURE__ */ j.define(), bp = /* @__PURE__ */ Qe.define({
  create() {
    return !0;
  },
  update(r, e) {
    for (let t of e.effects)
      t.is(Bo) && (r = t.value);
    return r;
  },
  provide: (r) => Jn.from(r, (e) => e ? _h : null)
}), e0 = (r) => {
  let e = Kn(r, _h);
  if (!e) {
    let t = [Bo.of(!0)];
    r.state.field(bp, !1) == null && t.push(j.appendConfig.of([bp, $$])), r.dispatch({ effects: t }), e = Kn(r, _h);
  }
  return e && e.dom.querySelector("input").select(), !0;
}, $$ = /* @__PURE__ */ Z.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    "& label": { fontSize: "80%" }
  }
}), Q$ = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !1
}, t0 = /* @__PURE__ */ _.define({
  combine(r) {
    return _t(r, Q$, {
      highlightWordAroundCursor: (e, t) => e || t,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function P$(r) {
  let e = [_$, Z$];
  return r && e.push(t0.of(r)), e;
}
const T$ = /* @__PURE__ */ E.mark({ class: "cm-selectionMatch" }), C$ = /* @__PURE__ */ E.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function wp(r, e, t, i) {
  return (t == 0 || r(e.sliceDoc(t - 1, t)) != pe.Word) && (i == e.doc.length || r(e.sliceDoc(i, i + 1)) != pe.Word);
}
function X$(r, e, t, i) {
  return r(e.sliceDoc(t, t + 1)) == pe.Word && r(e.sliceDoc(i - 1, i)) == pe.Word;
}
const Z$ = /* @__PURE__ */ ge.fromClass(class {
  constructor(r) {
    this.decorations = this.getDeco(r);
  }
  update(r) {
    (r.selectionSet || r.docChanged || r.viewportChanged) && (this.decorations = this.getDeco(r.view));
  }
  getDeco(r) {
    let e = r.state.facet(t0), { state: t } = r, i = t.selection;
    if (i.ranges.length > 1)
      return E.none;
    let n = i.main, s, o = null;
    if (n.empty) {
      if (!e.highlightWordAroundCursor)
        return E.none;
      let a = t.wordAt(n.head);
      if (!a)
        return E.none;
      o = t.charCategorizer(n.head), s = t.sliceDoc(a.from, a.to);
    } else {
      let a = n.to - n.from;
      if (a < e.minSelectionLength || a > 200)
        return E.none;
      if (e.wholeWords) {
        if (s = t.sliceDoc(n.from, n.to), o = t.charCategorizer(n.head), !(wp(o, t, n.from, n.to) && X$(o, t, n.from, n.to)))
          return E.none;
      } else if (s = t.sliceDoc(n.from, n.to).trim(), !s)
        return E.none;
    }
    let l = [];
    for (let a of r.visibleRanges) {
      let h = new Ui(t.doc, s, a.from, a.to);
      for (; !h.next().done; ) {
        let { from: c, to: u } = h.value;
        if ((!o || wp(o, t, c, u)) && (n.empty && c <= n.from && u >= n.to ? l.push(C$.range(c, u)) : (c >= n.to || u <= n.from) && l.push(T$.range(c, u)), l.length > e.maxMatches))
          return E.none;
      }
    }
    return E.set(l);
  }
}, {
  decorations: (r) => r.decorations
}), _$ = /* @__PURE__ */ Z.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), R$ = ({ state: r, dispatch: e }) => {
  let { selection: t } = r, i = S.create(t.ranges.map((n) => r.wordAt(n.head) || S.cursor(n.head)), t.mainIndex);
  return i.eq(t) ? !1 : (e(r.update({ selection: i })), !0);
};
function A$(r, e) {
  let { main: t, ranges: i } = r.selection, n = r.wordAt(t.head), s = n && n.from == t.from && n.to == t.to;
  for (let o = !1, l = new Ui(r.doc, e, i[i.length - 1].to); ; )
    if (l.next(), l.done) {
      if (o)
        return null;
      l = new Ui(r.doc, e, 0, Math.max(0, i[i.length - 1].from - 1)), o = !0;
    } else {
      if (o && i.some((a) => a.from == l.value.from))
        continue;
      if (s) {
        let a = r.wordAt(l.value.from);
        if (!a || a.from != l.value.from || a.to != l.value.to)
          continue;
      }
      return l.value;
    }
}
const E$ = ({ state: r, dispatch: e }) => {
  let { ranges: t } = r.selection;
  if (t.some((s) => s.from === s.to))
    return R$({ state: r, dispatch: e });
  let i = r.sliceDoc(t[0].from, t[0].to);
  if (r.selection.ranges.some((s) => r.sliceDoc(s.from, s.to) != i))
    return !1;
  let n = A$(r, i);
  return n ? (e(r.update({
    selection: r.selection.addRange(S.range(n.from, n.to), !1),
    effects: Z.scrollIntoView(n.to)
  })), !0) : !1;
}, sn = /* @__PURE__ */ _.define({
  combine(r) {
    return _t(r, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      regexp: !1,
      wholeWord: !1,
      createPanel: (e) => new I$(e),
      scrollToMatch: (e) => Z.scrollIntoView(e)
    });
  }
});
class r0 {
  /**
  Create a query object.
  */
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || k$(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
  }
  /**
  @internal
  */
  unquote(e) {
    return this.literal ? e : e.replace(/\\([nrt\\])/g, (t, i) => i == "n" ? `
` : i == "r" ? "\r" : i == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new W$(this) : new z$(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(e, t = 0, i) {
    let n = e.doc ? e : U.create({ doc: e });
    return i == null && (i = n.doc.length), this.regexp ? Si(this, n, t, i) : xi(this, n, t, i);
  }
}
class i0 {
  constructor(e) {
    this.spec = e;
  }
}
function xi(r, e, t, i) {
  return new Ui(e.doc, r.unquoted, t, i, r.caseSensitive ? void 0 : (n) => n.toLowerCase(), r.wholeWord ? q$(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
}
function q$(r, e) {
  return (t, i, n, s) => ((s > t || s + n.length < i) && (s = Math.max(0, t - 2), n = r.sliceString(s, Math.min(r.length, i + 2))), (e(Do(n, t - s)) != pe.Word || e(Io(n, t - s)) != pe.Word) && (e(Io(n, i - s)) != pe.Word || e(Do(n, i - s)) != pe.Word));
}
class z$ extends i0 {
  constructor(e) {
    super(e);
  }
  nextMatch(e, t, i) {
    let n = xi(this.spec, e, i, e.doc.length).nextOverlapping();
    return n.done && (n = xi(this.spec, e, 0, t).nextOverlapping()), n.done ? null : n.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(e, t, i) {
    for (let n = i; ; ) {
      let s = Math.max(t, n - 1e4 - this.spec.unquoted.length), o = xi(this.spec, e, s, n), l = null;
      for (; !o.nextOverlapping().done; )
        l = o.value;
      if (l)
        return l;
      if (s == t)
        return null;
      n -= 1e4;
    }
  }
  prevMatch(e, t, i) {
    return this.prevMatchInRange(e, 0, t) || this.prevMatchInRange(e, i, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, t) {
    let i = xi(this.spec, e, 0, e.doc.length), n = [];
    for (; !i.next().done; ) {
      if (n.length >= t)
        return null;
      n.push(i.value);
    }
    return n;
  }
  highlight(e, t, i, n) {
    let s = xi(this.spec, e, Math.max(0, t - this.spec.unquoted.length), Math.min(i + this.spec.unquoted.length, e.doc.length));
    for (; !s.next().done; )
      n(s.value.from, s.value.to);
  }
}
function Si(r, e, t, i) {
  return new Kg(e.doc, r.search, {
    ignoreCase: !r.caseSensitive,
    test: r.wholeWord ? Y$(e.charCategorizer(e.selection.main.head)) : void 0
  }, t, i);
}
function Do(r, e) {
  return r.slice(_e(r, e, !1), e);
}
function Io(r, e) {
  return r.slice(e, _e(r, e));
}
function Y$(r) {
  return (e, t, i) => !i[0].length || (r(Do(i.input, i.index)) != pe.Word || r(Io(i.input, i.index)) != pe.Word) && (r(Io(i.input, i.index + i[0].length)) != pe.Word || r(Do(i.input, i.index + i[0].length)) != pe.Word);
}
class W$ extends i0 {
  nextMatch(e, t, i) {
    let n = Si(this.spec, e, i, e.doc.length).next();
    return n.done && (n = Si(this.spec, e, 0, t).next()), n.done ? null : n.value;
  }
  prevMatchInRange(e, t, i) {
    for (let n = 1; ; n++) {
      let s = Math.max(
        t,
        i - n * 1e4
        /* FindPrev.ChunkSize */
      ), o = Si(this.spec, e, s, i), l = null;
      for (; !o.next().done; )
        l = o.value;
      if (l && (s == t || l.from > s + 10))
        return l;
      if (s == t)
        return null;
    }
  }
  prevMatch(e, t, i) {
    return this.prevMatchInRange(e, 0, t) || this.prevMatchInRange(e, i, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&\d+])/g, (t, i) => i == "$" ? "$" : i == "&" ? e.match[0] : i != "0" && +i < e.match.length ? e.match[i] : t);
  }
  matchAll(e, t) {
    let i = Si(this.spec, e, 0, e.doc.length), n = [];
    for (; !i.next().done; ) {
      if (n.length >= t)
        return null;
      n.push(i.value);
    }
    return n;
  }
  highlight(e, t, i, n) {
    let s = Si(this.spec, e, Math.max(
      0,
      t - 250
      /* RegExp.HighlightMargin */
    ), Math.min(i + 250, e.doc.length));
    for (; !s.next().done; )
      n(s.value.from, s.value.to);
  }
}
const ns = /* @__PURE__ */ j.define(), Vc = /* @__PURE__ */ j.define(), Pr = /* @__PURE__ */ Qe.define({
  create(r) {
    return new da(Rh(r).create(), null);
  },
  update(r, e) {
    for (let t of e.effects)
      t.is(ns) ? r = new da(t.value.create(), r.panel) : t.is(Vc) && (r = new da(r.query, t.value ? Mc : null));
    return r;
  },
  provide: (r) => Jn.from(r, (e) => e.panel)
});
class da {
  constructor(e, t) {
    this.query = e, this.panel = t;
  }
}
const V$ = /* @__PURE__ */ E.mark({ class: "cm-searchMatch" }), M$ = /* @__PURE__ */ E.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), j$ = /* @__PURE__ */ ge.fromClass(class {
  constructor(r) {
    this.view = r, this.decorations = this.highlight(r.state.field(Pr));
  }
  update(r) {
    let e = r.state.field(Pr);
    (e != r.startState.field(Pr) || r.docChanged || r.selectionSet || r.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: r, panel: e }) {
    if (!e || !r.spec.valid)
      return E.none;
    let { view: t } = this, i = new sr();
    for (let n = 0, s = t.visibleRanges, o = s.length; n < o; n++) {
      let { from: l, to: a } = s[n];
      for (; n < o - 1 && a > s[n + 1].from - 2 * 250; )
        a = s[++n].to;
      r.highlight(t.state, l, a, (h, c) => {
        let u = t.state.selection.ranges.some((d) => d.from == h && d.to == c);
        i.add(h, c, u ? M$ : V$);
      });
    }
    return i.finish();
  }
}, {
  decorations: (r) => r.decorations
});
function Ps(r) {
  return (e) => {
    let t = e.state.field(Pr, !1);
    return t && t.query.spec.valid ? r(e, t) : jc(e);
  };
}
const Uo = /* @__PURE__ */ Ps((r, { query: e }) => {
  let { to: t } = r.state.selection.main, i = e.nextMatch(r.state, t, t);
  if (!i)
    return !1;
  let n = S.single(i.from, i.to), s = r.state.facet(sn);
  return r.dispatch({
    selection: n,
    effects: [Lc(r, i), s.scrollToMatch(n.main, r)],
    userEvent: "select.search"
  }), s0(r), !0;
}), Go = /* @__PURE__ */ Ps((r, { query: e }) => {
  let { state: t } = r, { from: i } = t.selection.main, n = e.prevMatch(t, i, i);
  if (!n)
    return !1;
  let s = S.single(n.from, n.to), o = r.state.facet(sn);
  return r.dispatch({
    selection: s,
    effects: [Lc(r, n), o.scrollToMatch(s.main, r)],
    userEvent: "select.search"
  }), s0(r), !0;
}), L$ = /* @__PURE__ */ Ps((r, { query: e }) => {
  let t = e.matchAll(r.state, 1e3);
  return !t || !t.length ? !1 : (r.dispatch({
    selection: S.create(t.map((i) => S.range(i.from, i.to))),
    userEvent: "select.search.matches"
  }), !0);
}), B$ = ({ state: r, dispatch: e }) => {
  let t = r.selection;
  if (t.ranges.length > 1 || t.main.empty)
    return !1;
  let { from: i, to: n } = t.main, s = [], o = 0;
  for (let l = new Ui(r.doc, r.sliceDoc(i, n)); !l.next().done; ) {
    if (s.length > 1e3)
      return !1;
    l.value.from == i && (o = s.length), s.push(S.range(l.value.from, l.value.to));
  }
  return e(r.update({
    selection: S.create(s, o),
    userEvent: "select.search.matches"
  })), !0;
}, yp = /* @__PURE__ */ Ps((r, { query: e }) => {
  let { state: t } = r, { from: i, to: n } = t.selection.main;
  if (t.readOnly)
    return !1;
  let s = e.nextMatch(t, i, i);
  if (!s)
    return !1;
  let o = [], l, a, h = [];
  if (s.from == i && s.to == n && (a = t.toText(e.getReplacement(s)), o.push({ from: s.from, to: s.to, insert: a }), s = e.nextMatch(t, s.from, s.to), h.push(Z.announce.of(t.phrase("replaced match on line $", t.doc.lineAt(i).number) + "."))), s) {
    let c = o.length == 0 || o[0].from >= s.to ? 0 : s.to - s.from - a.length;
    l = S.single(s.from - c, s.to - c), h.push(Lc(r, s)), h.push(t.facet(sn).scrollToMatch(l.main, r));
  }
  return r.dispatch({
    changes: o,
    selection: l,
    effects: h,
    userEvent: "input.replace"
  }), !0;
}), D$ = /* @__PURE__ */ Ps((r, { query: e }) => {
  if (r.state.readOnly)
    return !1;
  let t = e.matchAll(r.state, 1e9).map((n) => {
    let { from: s, to: o } = n;
    return { from: s, to: o, insert: e.getReplacement(n) };
  });
  if (!t.length)
    return !1;
  let i = r.state.phrase("replaced $ matches", t.length) + ".";
  return r.dispatch({
    changes: t,
    effects: Z.announce.of(i),
    userEvent: "input.replace.all"
  }), !0;
});
function Mc(r) {
  return r.state.facet(sn).createPanel(r);
}
function Rh(r, e) {
  var t, i, n, s, o;
  let l = r.selection.main, a = l.empty || l.to > l.from + 100 ? "" : r.sliceDoc(l.from, l.to);
  if (e && !a)
    return e;
  let h = r.facet(sn);
  return new r0({
    search: ((t = e == null ? void 0 : e.literal) !== null && t !== void 0 ? t : h.literal) ? a : a.replace(/\n/g, "\\n"),
    caseSensitive: (i = e == null ? void 0 : e.caseSensitive) !== null && i !== void 0 ? i : h.caseSensitive,
    literal: (n = e == null ? void 0 : e.literal) !== null && n !== void 0 ? n : h.literal,
    regexp: (s = e == null ? void 0 : e.regexp) !== null && s !== void 0 ? s : h.regexp,
    wholeWord: (o = e == null ? void 0 : e.wholeWord) !== null && o !== void 0 ? o : h.wholeWord
  });
}
function n0(r) {
  let e = Kn(r, Mc);
  return e && e.dom.querySelector("[main-field]");
}
function s0(r) {
  let e = n0(r);
  e && e == r.root.activeElement && e.select();
}
const jc = (r) => {
  let e = r.state.field(Pr, !1);
  if (e && e.panel) {
    let t = n0(r);
    if (t && t != r.root.activeElement) {
      let i = Rh(r.state, e.query.spec);
      i.valid && r.dispatch({ effects: ns.of(i) }), t.focus(), t.select();
    }
  } else
    r.dispatch({ effects: [
      Vc.of(!0),
      e ? ns.of(Rh(r.state, e.query.spec)) : j.appendConfig.of(G$)
    ] });
  return !0;
}, o0 = (r) => {
  let e = r.state.field(Pr, !1);
  if (!e || !e.panel)
    return !1;
  let t = Kn(r, Mc);
  return t && t.dom.contains(r.root.activeElement) && r.focus(), r.dispatch({ effects: Vc.of(!1) }), !0;
}, l0 = [
  { key: "Mod-f", run: jc, scope: "editor search-panel" },
  { key: "F3", run: Uo, shift: Go, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: Uo, shift: Go, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: o0, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: B$ },
  { key: "Mod-Alt-g", run: e0 },
  { key: "Mod-d", run: E$, preventDefault: !0 }
];
class I$ {
  constructor(e) {
    this.view = e;
    let t = this.query = e.state.field(Pr).query.spec;
    this.commit = this.commit.bind(this), this.searchField = oe("input", {
      value: t.search,
      placeholder: Fe(e, "Find"),
      "aria-label": Fe(e, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = oe("input", {
      value: t.replace,
      placeholder: Fe(e, "Replace"),
      "aria-label": Fe(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = oe("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: t.caseSensitive,
      onchange: this.commit
    }), this.reField = oe("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: t.regexp,
      onchange: this.commit
    }), this.wordField = oe("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: t.wholeWord,
      onchange: this.commit
    });
    function i(n, s, o) {
      return oe("button", { class: "cm-button", name: n, onclick: s, type: "button" }, o);
    }
    this.dom = oe("div", { onkeydown: (n) => this.keydown(n), class: "cm-search" }, [
      this.searchField,
      i("next", () => Uo(e), [Fe(e, "next")]),
      i("prev", () => Go(e), [Fe(e, "previous")]),
      i("select", () => L$(e), [Fe(e, "all")]),
      oe("label", null, [this.caseField, Fe(e, "match case")]),
      oe("label", null, [this.reField, Fe(e, "regexp")]),
      oe("label", null, [this.wordField, Fe(e, "by word")]),
      ...e.state.readOnly ? [] : [
        oe("br"),
        this.replaceField,
        i("replace", () => yp(e), [Fe(e, "replace")]),
        i("replaceAll", () => D$(e), [Fe(e, "replace all")])
      ],
      oe("button", {
        name: "close",
        onclick: () => o0(e),
        "aria-label": Fe(e, "close"),
        type: "button"
      }, ["×"])
    ]);
  }
  commit() {
    let e = new r0({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: ns.of(e) }));
  }
  keydown(e) {
    cx(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? Go : Uo)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), yp(this.view));
  }
  update(e) {
    for (let t of e.transactions)
      for (let i of t.effects)
        i.is(ns) && !i.value.eq(this.query) && this.setQuery(i.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(sn).top;
  }
}
function Fe(r, e) {
  return r.state.phrase(e);
}
const Hs = 30, Ks = /[\s\.,:;?!]/;
function Lc(r, { from: e, to: t }) {
  let i = r.state.doc.lineAt(e), n = r.state.doc.lineAt(t).to, s = Math.max(i.from, e - Hs), o = Math.min(n, t + Hs), l = r.state.sliceDoc(s, o);
  if (s != i.from) {
    for (let a = 0; a < Hs; a++)
      if (!Ks.test(l[a + 1]) && Ks.test(l[a])) {
        l = l.slice(a);
        break;
      }
  }
  if (o != n) {
    for (let a = l.length - 1; a > l.length - Hs; a--)
      if (!Ks.test(l[a - 1]) && Ks.test(l[a])) {
        l = l.slice(0, a);
        break;
      }
  }
  return Z.announce.of(`${r.state.phrase("current match")}. ${l} ${r.state.phrase("on line")} ${i.number}.`);
}
const U$ = /* @__PURE__ */ Z.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), G$ = [
  Pr,
  /* @__PURE__ */ Lr.low(j$),
  U$
];
class Bc {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sources—in the editor, the extension will create
  these for you.)
  */
  constructor(e, t, i) {
    this.state = e, this.pos = t, this.explicit = i, this.abortListeners = [];
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(e) {
    let t = te(this.state).resolveInner(this.pos, -1);
    for (; t && e.indexOf(t.name) < 0; )
      t = t.parent;
    return t ? {
      from: t.from,
      to: this.pos,
      text: this.state.sliceDoc(t.from, this.pos),
      type: t.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(e) {
    let t = this.state.doc.lineAt(this.pos), i = Math.max(t.from, this.pos - 250), n = t.text.slice(i - t.from, this.pos - t.from), s = n.search(a0(e, !1));
    return s < 0 ? null : { from: i + s, to: this.pos, text: n.slice(s) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  */
  addEventListener(e, t) {
    e == "abort" && this.abortListeners && this.abortListeners.push(t);
  }
}
function vp(r) {
  let e = Object.keys(r).join(""), t = /\w/.test(e);
  return t && (e = e.replace(/\w/g, "")), `[${t ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function N$(r) {
  let e = /* @__PURE__ */ Object.create(null), t = /* @__PURE__ */ Object.create(null);
  for (let { label: n } of r) {
    e[n[0]] = !0;
    for (let s = 1; s < n.length; s++)
      t[n[s]] = !0;
  }
  let i = vp(e) + vp(t) + "*$";
  return [new RegExp("^" + i), new RegExp(i)];
}
function $l(r) {
  let e = r.map((n) => typeof n == "string" ? { label: n } : n), [t, i] = e.every((n) => /^\w+$/.test(n.label)) ? [/\w*$/, /\w+$/] : N$(e);
  return (n) => {
    let s = n.matchBefore(i);
    return s || n.explicit ? { from: s ? s.from : n.pos, options: e, validFor: t } : null;
  };
}
function Dc(r, e) {
  return (t) => {
    for (let i = te(t.state).resolveInner(t.pos, -1); i; i = i.parent) {
      if (r.indexOf(i.name) > -1)
        return null;
      if (i.type.isTop)
        break;
    }
    return e(t);
  };
}
class xp {
  constructor(e, t, i, n) {
    this.completion = e, this.source = t, this.match = i, this.score = n;
  }
}
function Tr(r) {
  return r.selection.main.from;
}
function a0(r, e) {
  var t;
  let { source: i } = r, n = e && i[0] != "^", s = i[i.length - 1] != "$";
  return !n && !s ? r : new RegExp(`${n ? "^" : ""}(?:${i})${s ? "$" : ""}`, (t = r.flags) !== null && t !== void 0 ? t : r.ignoreCase ? "i" : "");
}
const h0 = /* @__PURE__ */ pr.define();
function F$(r, e, t, i) {
  let { main: n } = r.selection, s = t - n.from, o = i - n.from;
  return Object.assign(Object.assign({}, r.changeByRange((l) => l != n && t != i && r.sliceDoc(l.from + s, l.from + o) != r.sliceDoc(t, i) ? { range: l } : {
    changes: { from: l.from + s, to: i == n.from ? l.to : l.from + o, insert: e },
    range: S.cursor(l.from + s + e.length)
  })), { scrollIntoView: !0, userEvent: "input.complete" });
}
const Sp = /* @__PURE__ */ new WeakMap();
function H$(r) {
  if (!Array.isArray(r))
    return r;
  let e = Sp.get(r);
  return e || Sp.set(r, e = $l(r)), e;
}
const No = /* @__PURE__ */ j.define(), ss = /* @__PURE__ */ j.define();
class K$ {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let t = 0; t < e.length; ) {
      let i = Te(e, t), n = dt(i);
      this.chars.push(i);
      let s = e.slice(t, t + n), o = s.toUpperCase();
      this.folded.push(Te(o == s ? s.toLowerCase() : o, 0)), t += n;
    }
    this.astral = e.length != this.chars.length;
  }
  ret(e, t) {
    return this.score = e, this.matched = t, !0;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(e) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (e.length < this.pattern.length)
      return !1;
    let { chars: t, folded: i, any: n, precise: s, byWord: o } = this;
    if (t.length == 1) {
      let v = Te(e, 0), k = dt(v), $ = k == e.length ? 0 : -100;
      if (v != t[0])
        if (v == i[0])
          $ += -200;
        else
          return !1;
      return this.ret($, [0, k]);
    }
    let l = e.indexOf(this.pattern);
    if (l == 0)
      return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let a = t.length, h = 0;
    if (l < 0) {
      for (let v = 0, k = Math.min(e.length, 200); v < k && h < a; ) {
        let $ = Te(e, v);
        ($ == t[h] || $ == i[h]) && (n[h++] = v), v += dt($);
      }
      if (h < a)
        return !1;
    }
    let c = 0, u = 0, d = !1, p = 0, f = -1, m = -1, g = /[a-z]/.test(e), b = !0;
    for (let v = 0, k = Math.min(e.length, 200), $ = 0; v < k && u < a; ) {
      let x = Te(e, v);
      l < 0 && (c < a && x == t[c] && (s[c++] = v), p < a && (x == t[p] || x == i[p] ? (p == 0 && (f = v), m = v + 1, p++) : p = 0));
      let Q, P = x < 255 ? x >= 48 && x <= 57 || x >= 97 && x <= 122 ? 2 : x >= 65 && x <= 90 ? 1 : 0 : (Q = cc(x)) != Q.toLowerCase() ? 1 : Q != Q.toUpperCase() ? 2 : 0;
      (!v || P == 1 && g || $ == 0 && P != 0) && (t[u] == x || i[u] == x && (d = !0) ? o[u++] = v : o.length && (b = !1)), $ = P, v += dt(x);
    }
    return u == a && o[0] == 0 && b ? this.result(-100 + (d ? -200 : 0), o, e) : p == a && f == 0 ? this.ret(-200 - e.length + (m == e.length ? 0 : -100), [0, m]) : l > -1 ? this.ret(-700 - e.length, [l, l + this.pattern.length]) : p == a ? this.ret(-900 - e.length, [f, m]) : u == a ? this.result(-100 + (d ? -200 : 0) + -700 + (b ? 0 : -1100), o, e) : t.length == 2 ? !1 : this.result((n[0] ? -700 : 0) + -200 + -1100, n, e);
  }
  result(e, t, i) {
    let n = [], s = 0;
    for (let o of t) {
      let l = o + (this.astral ? dt(Te(i, o)) : 1);
      s && n[s - 1] == o ? n[s - 1] = l : (n[s++] = o, n[s++] = l);
    }
    return this.ret(e - i.length, n);
  }
}
const Ze = /* @__PURE__ */ _.define({
  combine(r) {
    return _t(r, {
      activateOnTyping: !0,
      activateOnTypingDelay: 100,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: J$,
      compareCompletions: (e, t) => e.label.localeCompare(t.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (e, t) => e && t,
      closeOnBlur: (e, t) => e && t,
      icons: (e, t) => e && t,
      tooltipClass: (e, t) => (i) => kp(e(i), t(i)),
      optionClass: (e, t) => (i) => kp(e(i), t(i)),
      addToOptions: (e, t) => e.concat(t)
    });
  }
});
function kp(r, e) {
  return r ? e ? r + " " + e : r : e;
}
function J$(r, e, t, i, n, s) {
  let o = r.textDirection == ce.RTL, l = o, a = !1, h = "top", c, u, d = e.left - n.left, p = n.right - e.right, f = i.right - i.left, m = i.bottom - i.top;
  if (l && d < Math.min(f, p) ? l = !1 : !l && p < Math.min(f, d) && (l = !0), f <= (l ? d : p))
    c = Math.max(n.top, Math.min(t.top, n.bottom - m)) - e.top, u = Math.min(400, l ? d : p);
  else {
    a = !0, u = Math.min(
      400,
      (o ? e.right : n.right - e.left) - 30
      /* Info.Margin */
    );
    let v = n.bottom - e.bottom;
    v >= m || v > e.top ? c = t.bottom - e.top : (h = "bottom", c = e.bottom - t.top);
  }
  let g = (e.bottom - e.top) / s.offsetHeight, b = (e.right - e.left) / s.offsetWidth;
  return {
    style: `${h}: ${c / g}px; max-width: ${u / b}px`,
    class: "cm-completionInfo-" + (a ? o ? "left-narrow" : "right-narrow" : l ? "left" : "right")
  };
}
function eQ(r) {
  let e = r.addToOptions.slice();
  return r.icons && e.push({
    render(t) {
      let i = document.createElement("div");
      return i.classList.add("cm-completionIcon"), t.type && i.classList.add(...t.type.split(/\s+/g).map((n) => "cm-completionIcon-" + n)), i.setAttribute("aria-hidden", "true"), i;
    },
    position: 20
  }), e.push({
    render(t, i, n, s) {
      let o = document.createElement("span");
      o.className = "cm-completionLabel";
      let l = t.displayLabel || t.label, a = 0;
      for (let h = 0; h < s.length; ) {
        let c = s[h++], u = s[h++];
        c > a && o.appendChild(document.createTextNode(l.slice(a, c)));
        let d = o.appendChild(document.createElement("span"));
        d.appendChild(document.createTextNode(l.slice(c, u))), d.className = "cm-completionMatchedText", a = u;
      }
      return a < l.length && o.appendChild(document.createTextNode(l.slice(a))), o;
    },
    position: 50
  }, {
    render(t) {
      if (!t.detail)
        return null;
      let i = document.createElement("span");
      return i.className = "cm-completionDetail", i.textContent = t.detail, i;
    },
    position: 80
  }), e.sort((t, i) => t.position - i.position).map((t) => t.render);
}
function pa(r, e, t) {
  if (r <= t)
    return { from: 0, to: r };
  if (e < 0 && (e = 0), e <= r >> 1) {
    let n = Math.floor(e / t);
    return { from: n * t, to: (n + 1) * t };
  }
  let i = Math.floor((r - e) / t);
  return { from: r - (i + 1) * t, to: r - i * t };
}
class tQ {
  constructor(e, t, i) {
    this.view = e, this.stateField = t, this.applyCompletion = i, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (a) => this.placeInfo(a),
      key: this
    }, this.space = null, this.currentClass = "";
    let n = e.state.field(t), { options: s, selected: o } = n.open, l = e.state.facet(Ze);
    this.optionContent = eQ(l), this.optionClass = l.optionClass, this.tooltipClass = l.tooltipClass, this.range = pa(s.length, o, l.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (a) => {
      let { options: h } = e.state.field(t).open;
      for (let c = a.target, u; c && c != this.dom; c = c.parentNode)
        if (c.nodeName == "LI" && (u = /-(\d+)$/.exec(c.id)) && +u[1] < h.length) {
          this.applyCompletion(e, h[+u[1]]), a.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (a) => {
      let h = e.state.field(this.stateField, !1);
      h && h.tooltip && e.state.facet(Ze).closeOnBlur && a.relatedTarget != e.contentDOM && e.dispatch({ effects: ss.of(null) });
    }), this.showOptions(s, n.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(e, t) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(e, t, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(e) {
    var t;
    let i = e.state.field(this.stateField), n = e.startState.field(this.stateField);
    if (this.updateTooltipClass(e.state), i != n) {
      let { options: s, selected: o, disabled: l } = i.open;
      (!n.open || n.open.options != s) && (this.range = pa(s.length, o, e.state.facet(Ze).maxRenderedOptions), this.showOptions(s, i.id)), this.updateSel(), l != ((t = n.open) === null || t === void 0 ? void 0 : t.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!l);
    }
  }
  updateTooltipClass(e) {
    let t = this.tooltipClass(e);
    if (t != this.currentClass) {
      for (let i of this.currentClass.split(" "))
        i && this.dom.classList.remove(i);
      for (let i of t.split(" "))
        i && this.dom.classList.add(i);
      this.currentClass = t;
    }
  }
  positioned(e) {
    this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), t = e.open;
    if ((t.selected > -1 && t.selected < this.range.from || t.selected >= this.range.to) && (this.range = pa(t.options.length, t.selected, this.view.state.facet(Ze).maxRenderedOptions), this.showOptions(t.options, e.id)), this.updateSelectedOption(t.selected)) {
      this.destroyInfo();
      let { completion: i } = t.options[t.selected], { info: n } = i;
      if (!n)
        return;
      let s = typeof n == "string" ? document.createTextNode(n) : n(i);
      if (!s)
        return;
      "then" in s ? s.then((o) => {
        o && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(o, i);
      }).catch((o) => gt(this.view.state, o, "completion info")) : this.addInfoPane(s, i);
    }
  }
  addInfoPane(e, t) {
    this.destroyInfo();
    let i = this.info = document.createElement("div");
    if (i.className = "cm-tooltip cm-completionInfo", e.nodeType != null)
      i.appendChild(e), this.infoDestroy = null;
    else {
      let { dom: n, destroy: s } = e;
      i.appendChild(n), this.infoDestroy = s || null;
    }
    this.dom.appendChild(i), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let t = null;
    for (let i = this.list.firstChild, n = this.range.from; i; i = i.nextSibling, n++)
      i.nodeName != "LI" || !i.id ? n-- : n == e ? i.hasAttribute("aria-selected") || (i.setAttribute("aria-selected", "true"), t = i) : i.hasAttribute("aria-selected") && i.removeAttribute("aria-selected");
    return t && iQ(this.list, t), t;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let t = this.dom.getBoundingClientRect(), i = this.info.getBoundingClientRect(), n = e.getBoundingClientRect(), s = this.space;
    if (!s) {
      let o = this.dom.ownerDocument.defaultView || window;
      s = { left: 0, top: 0, right: o.innerWidth, bottom: o.innerHeight };
    }
    return n.top > Math.min(s.bottom, t.bottom) - 10 || n.bottom < Math.max(s.top, t.top) + 10 ? null : this.view.state.facet(Ze).positionInfo(this.view, t, n, i, s, this.dom);
  }
  placeInfo(e) {
    this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(e, t, i) {
    const n = document.createElement("ul");
    n.id = t, n.setAttribute("role", "listbox"), n.setAttribute("aria-expanded", "true"), n.setAttribute("aria-label", this.view.state.phrase("Completions"));
    let s = null;
    for (let o = i.from; o < i.to; o++) {
      let { completion: l, match: a } = e[o], { section: h } = l;
      if (h) {
        let d = typeof h == "string" ? h : h.name;
        if (d != s && (o > i.from || i.from == 0))
          if (s = d, typeof h != "string" && h.header)
            n.appendChild(h.header(h));
          else {
            let p = n.appendChild(document.createElement("completion-section"));
            p.textContent = d;
          }
      }
      const c = n.appendChild(document.createElement("li"));
      c.id = t + "-" + o, c.setAttribute("role", "option");
      let u = this.optionClass(l);
      u && (c.className = u);
      for (let d of this.optionContent) {
        let p = d(l, this.view.state, this.view, a);
        p && c.appendChild(p);
      }
    }
    return i.from && n.classList.add("cm-completionListIncompleteTop"), i.to < e.length && n.classList.add("cm-completionListIncompleteBottom"), n;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function rQ(r, e) {
  return (t) => new tQ(t, r, e);
}
function iQ(r, e) {
  let t = r.getBoundingClientRect(), i = e.getBoundingClientRect(), n = t.height / r.offsetHeight;
  i.top < t.top ? r.scrollTop -= (t.top - i.top) / n : i.bottom > t.bottom && (r.scrollTop += (i.bottom - t.bottom) / n);
}
function $p(r) {
  return (r.boost || 0) * 100 + (r.apply ? 10 : 0) + (r.info ? 5 : 0) + (r.type ? 1 : 0);
}
function nQ(r, e) {
  let t = [], i = null, n = (a) => {
    t.push(a);
    let { section: h } = a.completion;
    if (h) {
      i || (i = []);
      let c = typeof h == "string" ? h : h.name;
      i.some((u) => u.name == c) || i.push(typeof h == "string" ? { name: c } : h);
    }
  };
  for (let a of r)
    if (a.hasResult()) {
      let h = a.result.getMatch;
      if (a.result.filter === !1)
        for (let c of a.result.options)
          n(new xp(c, a.source, h ? h(c) : [], 1e9 - t.length));
      else {
        let c = new K$(e.sliceDoc(a.from, a.to));
        for (let u of a.result.options)
          if (c.match(u.label)) {
            let d = u.displayLabel ? h ? h(u, c.matched) : [] : c.matched;
            n(new xp(u, a.source, d, c.score + (u.boost || 0)));
          }
      }
    }
  if (i) {
    let a = /* @__PURE__ */ Object.create(null), h = 0, c = (u, d) => {
      var p, f;
      return ((p = u.rank) !== null && p !== void 0 ? p : 1e9) - ((f = d.rank) !== null && f !== void 0 ? f : 1e9) || (u.name < d.name ? -1 : 1);
    };
    for (let u of i.sort(c))
      h -= 1e5, a[u.name] = h;
    for (let u of t) {
      let { section: d } = u.completion;
      d && (u.score += a[typeof d == "string" ? d : d.name]);
    }
  }
  let s = [], o = null, l = e.facet(Ze).compareCompletions;
  for (let a of t.sort((h, c) => c.score - h.score || l(h.completion, c.completion))) {
    let h = a.completion;
    !o || o.label != h.label || o.detail != h.detail || o.type != null && h.type != null && o.type != h.type || o.apply != h.apply || o.boost != h.boost ? s.push(a) : $p(a.completion) > $p(o) && (s[s.length - 1] = a), o = a.completion;
  }
  return s;
}
class Qi {
  constructor(e, t, i, n, s, o) {
    this.options = e, this.attrs = t, this.tooltip = i, this.timestamp = n, this.selected = s, this.disabled = o;
  }
  setSelected(e, t) {
    return e == this.selected || e >= this.options.length ? this : new Qi(this.options, Qp(t, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, t, i, n, s) {
    let o = nQ(e, t);
    if (!o.length)
      return n && e.some(
        (a) => a.state == 1
        /* State.Pending */
      ) ? new Qi(n.options, n.attrs, n.tooltip, n.timestamp, n.selected, !0) : null;
    let l = t.facet(Ze).selectOnOpen ? 0 : -1;
    if (n && n.selected != l && n.selected != -1) {
      let a = n.options[n.selected].completion;
      for (let h = 0; h < o.length; h++)
        if (o[h].completion == a) {
          l = h;
          break;
        }
    }
    return new Qi(o, Qp(i, l), {
      pos: e.reduce((a, h) => h.hasResult() ? Math.min(a, h.from) : a, 1e8),
      create: hQ,
      above: s.aboveCursor
    }, n ? n.timestamp : Date.now(), l, !1);
  }
  map(e) {
    return new Qi(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: e.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
}
class Fo {
  constructor(e, t, i) {
    this.active = e, this.id = t, this.open = i;
  }
  static start() {
    return new Fo(lQ, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: t } = e, i = t.facet(Ze), s = (i.override || t.languageDataAt("autocomplete", Tr(t)).map(H$)).map((l) => (this.active.find((h) => h.source == l) || new Ge(
      l,
      this.active.some(
        (h) => h.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(e, i));
    s.length == this.active.length && s.every((l, a) => l == this.active[a]) && (s = this.active);
    let o = this.open;
    o && e.docChanged && (o = o.map(e.changes)), e.selection || s.some((l) => l.hasResult() && e.changes.touchesRange(l.from, l.to)) || !sQ(s, this.active) ? o = Qi.build(s, t, this.id, o, i) : o && o.disabled && !s.some(
      (l) => l.state == 1
      /* State.Pending */
    ) && (o = null), !o && s.every(
      (l) => l.state != 1
      /* State.Pending */
    ) && s.some((l) => l.hasResult()) && (s = s.map((l) => l.hasResult() ? new Ge(
      l.source,
      0
      /* State.Inactive */
    ) : l));
    for (let l of e.effects)
      l.is(u0) && (o = o && o.setSelected(l.value, this.id));
    return s == this.active && o == this.open ? this : new Fo(s, this.id, o);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : oQ;
  }
}
function sQ(r, e) {
  if (r == e)
    return !0;
  for (let t = 0, i = 0; ; ) {
    for (; t < r.length && !r[t].hasResult; )
      t++;
    for (; i < e.length && !e[i].hasResult; )
      i++;
    let n = t == r.length, s = i == e.length;
    if (n || s)
      return n == s;
    if (r[t++].result != e[i++].result)
      return !1;
  }
}
const oQ = {
  "aria-autocomplete": "list"
};
function Qp(r, e) {
  let t = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": r
  };
  return e > -1 && (t["aria-activedescendant"] = r + "-" + e), t;
}
const lQ = [];
function Ah(r) {
  return r.isUserEvent("input.type") ? "input" : r.isUserEvent("delete.backward") ? "delete" : null;
}
class Ge {
  constructor(e, t, i = -1) {
    this.source = e, this.state = t, this.explicitPos = i;
  }
  hasResult() {
    return !1;
  }
  update(e, t) {
    let i = Ah(e), n = this;
    i ? n = n.handleUserEvent(e, i, t) : e.docChanged ? n = n.handleChange(e) : e.selection && n.state != 0 && (n = new Ge(
      n.source,
      0
      /* State.Inactive */
    ));
    for (let s of e.effects)
      if (s.is(No))
        n = new Ge(n.source, 1, s.value ? Tr(e.state) : -1);
      else if (s.is(ss))
        n = new Ge(
          n.source,
          0
          /* State.Inactive */
        );
      else if (s.is(c0))
        for (let o of s.value)
          o.source == n.source && (n = o);
    return n;
  }
  handleUserEvent(e, t, i) {
    return t == "delete" || !i.activateOnTyping ? this.map(e.changes) : new Ge(
      this.source,
      1
      /* State.Pending */
    );
  }
  handleChange(e) {
    return e.changes.touchesRange(Tr(e.startState)) ? new Ge(
      this.source,
      0
      /* State.Inactive */
    ) : this.map(e.changes);
  }
  map(e) {
    return e.empty || this.explicitPos < 0 ? this : new Ge(this.source, this.state, e.mapPos(this.explicitPos));
  }
}
class Ai extends Ge {
  constructor(e, t, i, n, s) {
    super(e, 2, t), this.result = i, this.from = n, this.to = s;
  }
  hasResult() {
    return !0;
  }
  handleUserEvent(e, t, i) {
    var n;
    let s = e.changes.mapPos(this.from), o = e.changes.mapPos(this.to, 1), l = Tr(e.state);
    if ((this.explicitPos < 0 ? l <= s : l < this.from) || l > o || t == "delete" && Tr(e.startState) == this.from)
      return new Ge(
        this.source,
        t == "input" && i.activateOnTyping ? 1 : 0
        /* State.Inactive */
      );
    let a = this.explicitPos < 0 ? -1 : e.changes.mapPos(this.explicitPos), h;
    return aQ(this.result.validFor, e.state, s, o) ? new Ai(this.source, a, this.result, s, o) : this.result.update && (h = this.result.update(this.result, s, o, new Bc(e.state, l, a >= 0))) ? new Ai(this.source, a, h, h.from, (n = h.to) !== null && n !== void 0 ? n : Tr(e.state)) : new Ge(this.source, 1, a);
  }
  handleChange(e) {
    return e.changes.touchesRange(this.from, this.to) ? new Ge(
      this.source,
      0
      /* State.Inactive */
    ) : this.map(e.changes);
  }
  map(e) {
    return e.empty ? this : new Ai(this.source, this.explicitPos < 0 ? -1 : e.mapPos(this.explicitPos), this.result, e.mapPos(this.from), e.mapPos(this.to, 1));
  }
}
function aQ(r, e, t, i) {
  if (!r)
    return !1;
  let n = e.sliceDoc(t, i);
  return typeof r == "function" ? r(n, t, i, e) : a0(r, !0).test(n);
}
const c0 = /* @__PURE__ */ j.define({
  map(r, e) {
    return r.map((t) => t.map(e));
  }
}), u0 = /* @__PURE__ */ j.define(), rt = /* @__PURE__ */ Qe.define({
  create() {
    return Fo.start();
  },
  update(r, e) {
    return r.update(e);
  },
  provide: (r) => [
    vc.from(r, (e) => e.tooltip),
    Z.contentAttributes.from(r, (e) => e.attrs)
  ]
});
function d0(r, e) {
  const t = e.completion.apply || e.completion.label;
  let i = r.state.field(rt).active.find((n) => n.source == e.source);
  return i instanceof Ai ? (typeof t == "string" ? r.dispatch(Object.assign(Object.assign({}, F$(r.state, t, i.from, i.to)), { annotations: h0.of(e.completion) })) : t(r, e.completion, i.from, i.to), !0) : !1;
}
const hQ = /* @__PURE__ */ rQ(rt, d0);
function Js(r, e = "option") {
  return (t) => {
    let i = t.state.field(rt, !1);
    if (!i || !i.open || i.open.disabled || Date.now() - i.open.timestamp < t.state.facet(Ze).interactionDelay)
      return !1;
    let n = 1, s;
    e == "page" && (s = Em(t, i.open.tooltip)) && (n = Math.max(2, Math.floor(s.dom.offsetHeight / s.dom.querySelector("li").offsetHeight) - 1));
    let { length: o } = i.open.options, l = i.open.selected > -1 ? i.open.selected + n * (r ? 1 : -1) : r ? 0 : o - 1;
    return l < 0 ? l = e == "page" ? 0 : o - 1 : l >= o && (l = e == "page" ? o - 1 : 0), t.dispatch({ effects: u0.of(l) }), !0;
  };
}
const cQ = (r) => {
  let e = r.state.field(rt, !1);
  return r.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < r.state.facet(Ze).interactionDelay ? !1 : d0(r, e.open.options[e.open.selected]);
}, uQ = (r) => r.state.field(rt, !1) ? (r.dispatch({ effects: No.of(!0) }), !0) : !1, dQ = (r) => {
  let e = r.state.field(rt, !1);
  return !e || !e.active.some(
    (t) => t.state != 0
    /* State.Inactive */
  ) ? !1 : (r.dispatch({ effects: ss.of(null) }), !0);
};
class pQ {
  constructor(e, t) {
    this.active = e, this.context = t, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const fQ = 50, OQ = 1e3, mQ = /* @__PURE__ */ ge.fromClass(class {
  constructor(r) {
    this.view = r, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;
    for (let e of r.state.field(rt).active)
      e.state == 1 && this.startQuery(e);
  }
  update(r) {
    let e = r.state.field(rt);
    if (!r.selectionSet && !r.docChanged && r.startState.field(rt) == e)
      return;
    let t = r.transactions.some((n) => (n.selection || n.docChanged) && !Ah(n));
    for (let n = 0; n < this.running.length; n++) {
      let s = this.running[n];
      if (t || s.updates.length + r.transactions.length > fQ && Date.now() - s.time > OQ) {
        for (let o of s.context.abortListeners)
          try {
            o();
          } catch (l) {
            gt(this.view.state, l);
          }
        s.context.abortListeners = null, this.running.splice(n--, 1);
      } else
        s.updates.push(...r.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), r.transactions.some((n) => n.effects.some((s) => s.is(No))) && (this.pendingStart = !0);
    let i = this.pendingStart ? 50 : r.state.facet(Ze).activateOnTypingDelay;
    if (this.debounceUpdate = e.active.some((n) => n.state == 1 && !this.running.some((s) => s.active.source == n.source)) ? setTimeout(() => this.startUpdate(), i) : -1, this.composing != 0)
      for (let n of r.transactions)
        Ah(n) == "input" ? this.composing = 2 : this.composing == 2 && n.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = !1;
    let { state: r } = this.view, e = r.field(rt);
    for (let t of e.active)
      t.state == 1 && !this.running.some((i) => i.active.source == t.source) && this.startQuery(t);
  }
  startQuery(r) {
    let { state: e } = this.view, t = Tr(e), i = new Bc(e, t, r.explicitPos == t), n = new pQ(r, i);
    this.running.push(n), Promise.resolve(r.source(i)).then((s) => {
      n.context.aborted || (n.done = s || null, this.scheduleAccept());
    }, (s) => {
      this.view.dispatch({ effects: ss.of(null) }), gt(this.view.state, s);
    });
  }
  scheduleAccept() {
    this.running.every((r) => r.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Ze).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var r;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], t = this.view.state.facet(Ze);
    for (let i = 0; i < this.running.length; i++) {
      let n = this.running[i];
      if (n.done === void 0)
        continue;
      if (this.running.splice(i--, 1), n.done) {
        let o = new Ai(n.active.source, n.active.explicitPos, n.done, n.done.from, (r = n.done.to) !== null && r !== void 0 ? r : Tr(n.updates.length ? n.updates[0].startState : this.view.state));
        for (let l of n.updates)
          o = o.update(l, t);
        if (o.hasResult()) {
          e.push(o);
          continue;
        }
      }
      let s = this.view.state.field(rt).active.find((o) => o.source == n.active.source);
      if (s && s.state == 1)
        if (n.done == null) {
          let o = new Ge(
            n.active.source,
            0
            /* State.Inactive */
          );
          for (let l of n.updates)
            o = o.update(l, t);
          o.state != 1 && e.push(o);
        } else
          this.startQuery(s);
    }
    e.length && this.view.dispatch({ effects: c0.of(e) });
  }
}, {
  eventHandlers: {
    blur(r) {
      let e = this.view.state.field(rt, !1);
      if (e && e.tooltip && this.view.state.facet(Ze).closeOnBlur) {
        let t = e.open && Em(this.view, e.open.tooltip);
        (!t || !t.dom.contains(r.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: ss.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: No.of(!1) }), 20), this.composing = 0;
    }
  }
}), p0 = /* @__PURE__ */ Z.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"···"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'ƒ'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'○'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'◌'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'𝑥'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'𝐶'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'𝑡'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'∪'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'□'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'🔑︎'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'▢'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class gQ {
  constructor(e, t, i, n) {
    this.field = e, this.line = t, this.from = i, this.to = n;
  }
}
class Ic {
  constructor(e, t, i) {
    this.field = e, this.from = t, this.to = i;
  }
  map(e) {
    let t = e.mapPos(this.from, -1, Xe.TrackDel), i = e.mapPos(this.to, 1, Xe.TrackDel);
    return t == null || i == null ? null : new Ic(this.field, t, i);
  }
}
class Uc {
  constructor(e, t) {
    this.lines = e, this.fieldPositions = t;
  }
  instantiate(e, t) {
    let i = [], n = [t], s = e.doc.lineAt(t), o = /^\s*/.exec(s.text)[0];
    for (let a of this.lines) {
      if (i.length) {
        let h = o, c = /^\t*/.exec(a)[0].length;
        for (let u = 0; u < c; u++)
          h += e.facet(fi);
        n.push(t + h.length - c), a = h + a.slice(c);
      }
      i.push(a), t += a.length + 1;
    }
    let l = this.fieldPositions.map((a) => new Ic(a.field, n[a.line] + a.from, n[a.line] + a.to));
    return { text: i, ranges: l };
  }
  static parse(e) {
    let t = [], i = [], n = [], s;
    for (let o of e.split(/\r\n?|\n/)) {
      for (; s = /[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(o); ) {
        let l = s[1] ? +s[1] : null, a = s[2] || s[3] || "", h = -1;
        for (let c = 0; c < t.length; c++)
          (l != null ? t[c].seq == l : a && t[c].name == a) && (h = c);
        if (h < 0) {
          let c = 0;
          for (; c < t.length && (l == null || t[c].seq != null && t[c].seq < l); )
            c++;
          t.splice(c, 0, { seq: l, name: a }), h = c;
          for (let u of n)
            u.field >= h && u.field++;
        }
        n.push(new gQ(h, i.length, s.index, s.index + a.length)), o = o.slice(0, s.index) + a + o.slice(s.index + s[0].length);
      }
      for (let l; l = /\\([{}])/.exec(o); ) {
        o = o.slice(0, l.index) + l[1] + o.slice(l.index + l[0].length);
        for (let a of n)
          a.line == i.length && a.from > l.index && (a.from--, a.to--);
      }
      i.push(o);
    }
    return new Uc(i, n);
  }
}
let bQ = /* @__PURE__ */ E.widget({ widget: /* @__PURE__ */ new class extends Kt {
  toDOM() {
    let r = document.createElement("span");
    return r.className = "cm-snippetFieldPosition", r;
  }
  ignoreEvent() {
    return !1;
  }
}() }), wQ = /* @__PURE__ */ E.mark({ class: "cm-snippetField" });
class on {
  constructor(e, t) {
    this.ranges = e, this.active = t, this.deco = E.set(e.map((i) => (i.from == i.to ? bQ : wQ).range(i.from, i.to)));
  }
  map(e) {
    let t = [];
    for (let i of this.ranges) {
      let n = i.map(e);
      if (!n)
        return null;
      t.push(n);
    }
    return new on(t, this.active);
  }
  selectionInsideField(e) {
    return e.ranges.every((t) => this.ranges.some((i) => i.field == this.active && i.from <= t.from && i.to >= t.to));
  }
}
const Ts = /* @__PURE__ */ j.define({
  map(r, e) {
    return r && r.map(e);
  }
}), yQ = /* @__PURE__ */ j.define(), os = /* @__PURE__ */ Qe.define({
  create() {
    return null;
  },
  update(r, e) {
    for (let t of e.effects) {
      if (t.is(Ts))
        return t.value;
      if (t.is(yQ) && r)
        return new on(r.ranges, t.value);
    }
    return r && e.docChanged && (r = r.map(e.changes)), r && e.selection && !r.selectionInsideField(e.selection) && (r = null), r;
  },
  provide: (r) => Z.decorations.from(r, (e) => e ? e.deco : E.none)
});
function Gc(r, e) {
  return S.create(r.filter((t) => t.field == e).map((t) => S.range(t.from, t.to)));
}
function vQ(r) {
  let e = Uc.parse(r);
  return (t, i, n, s) => {
    let { text: o, ranges: l } = e.instantiate(t.state, n), a = {
      changes: { from: n, to: s, insert: K.of(o) },
      scrollIntoView: !0,
      annotations: i ? [h0.of(i), we.userEvent.of("input.complete")] : void 0
    };
    if (l.length && (a.selection = Gc(l, 0)), l.some((h) => h.field > 0)) {
      let h = new on(l, 0), c = a.effects = [Ts.of(h)];
      t.state.field(os, !1) === void 0 && c.push(j.appendConfig.of([os, QQ, PQ, p0]));
    }
    t.dispatch(t.state.update(a));
  };
}
function f0(r) {
  return ({ state: e, dispatch: t }) => {
    let i = e.field(os, !1);
    if (!i || r < 0 && i.active == 0)
      return !1;
    let n = i.active + r, s = r > 0 && !i.ranges.some((o) => o.field == n + r);
    return t(e.update({
      selection: Gc(i.ranges, n),
      effects: Ts.of(s ? null : new on(i.ranges, n)),
      scrollIntoView: !0
    })), !0;
  };
}
const xQ = ({ state: r, dispatch: e }) => r.field(os, !1) ? (e(r.update({ effects: Ts.of(null) })), !0) : !1, SQ = /* @__PURE__ */ f0(1), kQ = /* @__PURE__ */ f0(-1), $Q = [
  { key: "Tab", run: SQ, shift: kQ },
  { key: "Escape", run: xQ }
], Pp = /* @__PURE__ */ _.define({
  combine(r) {
    return r.length ? r[0] : $Q;
  }
}), QQ = /* @__PURE__ */ Lr.highest(/* @__PURE__ */ tn.compute([Pp], (r) => r.facet(Pp)));
function Oe(r, e) {
  return Object.assign(Object.assign({}, e), { apply: vQ(r) });
}
const PQ = /* @__PURE__ */ Z.domEventHandlers({
  mousedown(r, e) {
    let t = e.state.field(os, !1), i;
    if (!t || (i = e.posAtCoords({ x: r.clientX, y: r.clientY })) == null)
      return !1;
    let n = t.ranges.find((s) => s.from <= i && s.to >= i);
    return !n || n.field == t.active ? !1 : (e.dispatch({
      selection: Gc(t.ranges, n.field),
      effects: Ts.of(t.ranges.some((s) => s.field > n.field) ? new on(t.ranges, n.field) : null),
      scrollIntoView: !0
    }), !0);
  }
}), ls = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, ni = /* @__PURE__ */ j.define({
  map(r, e) {
    let t = e.mapPos(r, -1, Xe.TrackAfter);
    return t ?? void 0;
  }
}), Nc = /* @__PURE__ */ new class extends ci {
}();
Nc.startSide = 1;
Nc.endSide = -1;
const O0 = /* @__PURE__ */ Qe.define({
  create() {
    return H.empty;
  },
  update(r, e) {
    if (r = r.map(e.changes), e.selection) {
      let t = e.state.doc.lineAt(e.selection.main.head);
      r = r.update({ filter: (i) => i >= t.from && i <= t.to });
    }
    for (let t of e.effects)
      t.is(ni) && (r = r.update({ add: [Nc.range(t.value, t.value + 1)] }));
    return r;
  }
});
function TQ() {
  return [XQ, O0];
}
const fa = "()[]{}<>";
function m0(r) {
  for (let e = 0; e < fa.length; e += 2)
    if (fa.charCodeAt(e) == r)
      return fa.charAt(e + 1);
  return cc(r < 128 ? r : r + 1);
}
function g0(r, e) {
  return r.languageDataAt("closeBrackets", e)[0] || ls;
}
const CQ = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), XQ = /* @__PURE__ */ Z.inputHandler.of((r, e, t, i) => {
  if ((CQ ? r.composing : r.compositionStarted) || r.state.readOnly)
    return !1;
  let n = r.state.selection.main;
  if (i.length > 2 || i.length == 2 && dt(Te(i, 0)) == 1 || e != n.from || t != n.to)
    return !1;
  let s = RQ(r.state, i);
  return s ? (r.dispatch(s), !0) : !1;
}), ZQ = ({ state: r, dispatch: e }) => {
  if (r.readOnly)
    return !1;
  let i = g0(r, r.selection.main.head).brackets || ls.brackets, n = null, s = r.changeByRange((o) => {
    if (o.empty) {
      let l = AQ(r.doc, o.head);
      for (let a of i)
        if (a == l && Ql(r.doc, o.head) == m0(Te(a, 0)))
          return {
            changes: { from: o.head - a.length, to: o.head + a.length },
            range: S.cursor(o.head - a.length)
          };
    }
    return { range: n = o };
  });
  return n || e(r.update(s, { scrollIntoView: !0, userEvent: "delete.backward" })), !n;
}, _Q = [
  { key: "Backspace", run: ZQ }
];
function RQ(r, e) {
  let t = g0(r, r.selection.main.head), i = t.brackets || ls.brackets;
  for (let n of i) {
    let s = m0(Te(n, 0));
    if (e == n)
      return s == n ? zQ(r, n, i.indexOf(n + n + n) > -1, t) : EQ(r, n, s, t.before || ls.before);
    if (e == s && b0(r, r.selection.main.from))
      return qQ(r, n, s);
  }
  return null;
}
function b0(r, e) {
  let t = !1;
  return r.field(O0).between(0, r.doc.length, (i) => {
    i == e && (t = !0);
  }), t;
}
function Ql(r, e) {
  let t = r.sliceString(e, e + 2);
  return t.slice(0, dt(Te(t, 0)));
}
function AQ(r, e) {
  let t = r.sliceString(e - 2, e);
  return dt(Te(t, 0)) == t.length ? t : t.slice(1);
}
function EQ(r, e, t, i) {
  let n = null, s = r.changeByRange((o) => {
    if (!o.empty)
      return {
        changes: [{ insert: e, from: o.from }, { insert: t, from: o.to }],
        effects: ni.of(o.to + e.length),
        range: S.range(o.anchor + e.length, o.head + e.length)
      };
    let l = Ql(r.doc, o.head);
    return !l || /\s/.test(l) || i.indexOf(l) > -1 ? {
      changes: { insert: e + t, from: o.head },
      effects: ni.of(o.head + e.length),
      range: S.cursor(o.head + e.length)
    } : { range: n = o };
  });
  return n ? null : r.update(s, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function qQ(r, e, t) {
  let i = null, n = r.changeByRange((s) => s.empty && Ql(r.doc, s.head) == t ? {
    changes: { from: s.head, to: s.head + t.length, insert: t },
    range: S.cursor(s.head + t.length)
  } : i = { range: s });
  return i ? null : r.update(n, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function zQ(r, e, t, i) {
  let n = i.stringPrefixes || ls.stringPrefixes, s = null, o = r.changeByRange((l) => {
    if (!l.empty)
      return {
        changes: [{ insert: e, from: l.from }, { insert: e, from: l.to }],
        effects: ni.of(l.to + e.length),
        range: S.range(l.anchor + e.length, l.head + e.length)
      };
    let a = l.head, h = Ql(r.doc, a), c;
    if (h == e) {
      if (Tp(r, a))
        return {
          changes: { insert: e + e, from: a },
          effects: ni.of(a + e.length),
          range: S.cursor(a + e.length)
        };
      if (b0(r, a)) {
        let d = t && r.sliceDoc(a, a + e.length * 3) == e + e + e ? e + e + e : e;
        return {
          changes: { from: a, to: a + d.length, insert: d },
          range: S.cursor(a + d.length)
        };
      }
    } else {
      if (t && r.sliceDoc(a - 2 * e.length, a) == e + e && (c = Cp(r, a - 2 * e.length, n)) > -1 && Tp(r, c))
        return {
          changes: { insert: e + e + e + e, from: a },
          effects: ni.of(a + e.length),
          range: S.cursor(a + e.length)
        };
      if (r.charCategorizer(a)(h) != pe.Word && Cp(r, a, n) > -1 && !YQ(r, a, e, n))
        return {
          changes: { insert: e + e, from: a },
          effects: ni.of(a + e.length),
          range: S.cursor(a + e.length)
        };
    }
    return { range: s = l };
  });
  return s ? null : r.update(o, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function Tp(r, e) {
  let t = te(r).resolveInner(e + 1);
  return t.parent && t.from == e;
}
function YQ(r, e, t, i) {
  let n = te(r).resolveInner(e, -1), s = i.reduce((o, l) => Math.max(o, l.length), 0);
  for (let o = 0; o < 5; o++) {
    let l = r.sliceDoc(n.from, Math.min(n.to, n.from + t.length + s)), a = l.indexOf(t);
    if (!a || a > -1 && i.indexOf(l.slice(0, a)) > -1) {
      let c = n.firstChild;
      for (; c && c.from == n.from && c.to - c.from > t.length + a; ) {
        if (r.sliceDoc(c.to - t.length, c.to) == t)
          return !1;
        c = c.firstChild;
      }
      return !0;
    }
    let h = n.to == e && n.parent;
    if (!h)
      break;
    n = h;
  }
  return !1;
}
function Cp(r, e, t) {
  let i = r.charCategorizer(e);
  if (i(r.sliceDoc(e - 1, e)) != pe.Word)
    return e;
  for (let n of t) {
    let s = e - n.length;
    if (r.sliceDoc(s, e) == n && i(r.sliceDoc(s - 1, s)) != pe.Word)
      return s;
  }
  return -1;
}
function WQ(r = {}) {
  return [
    rt,
    Ze.of(r),
    mQ,
    VQ,
    p0
  ];
}
const w0 = [
  { key: "Ctrl-Space", run: uQ },
  { key: "Escape", run: dQ },
  { key: "ArrowDown", run: /* @__PURE__ */ Js(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ Js(!1) },
  { key: "PageDown", run: /* @__PURE__ */ Js(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ Js(!1, "page") },
  { key: "Enter", run: cQ }
], VQ = /* @__PURE__ */ Lr.highest(/* @__PURE__ */ tn.computeN([Ze], (r) => r.facet(Ze).defaultKeymap ? [w0] : []));
class MQ {
  constructor(e, t, i) {
    this.from = e, this.to = t, this.diagnostic = i;
  }
}
class ti {
  constructor(e, t, i) {
    this.diagnostics = e, this.panel = t, this.selected = i;
  }
  static init(e, t, i) {
    let n = e, s = i.facet(x0).markerFilter;
    s && (n = s(n));
    let o = E.set(n.map((l) => l.from == l.to || l.from == l.to - 1 && i.doc.lineAt(l.from).to == l.from ? E.widget({
      widget: new FQ(l),
      diagnostic: l
    }).range(l.from) : E.mark({
      attributes: { class: "cm-lintRange cm-lintRange-" + l.severity + (l.markClass ? " " + l.markClass : "") },
      diagnostic: l
    }).range(l.from, l.to)), !0);
    return new ti(o, t, Gi(o));
  }
}
function Gi(r, e = null, t = 0) {
  let i = null;
  return r.between(t, 1e9, (n, s, { spec: o }) => {
    if (!(e && o.diagnostic != e))
      return i = new MQ(n, s, o.diagnostic), !1;
  }), i;
}
function jQ(r, e) {
  let t = r.startState.doc.lineAt(e.pos);
  return !!(r.effects.some((i) => i.is(y0)) || r.changes.touchesRange(t.from, t.to));
}
function LQ(r, e) {
  return r.field(st, !1) ? e : e.concat(j.appendConfig.of(JQ));
}
const y0 = /* @__PURE__ */ j.define(), Fc = /* @__PURE__ */ j.define(), v0 = /* @__PURE__ */ j.define(), st = /* @__PURE__ */ Qe.define({
  create() {
    return new ti(E.none, null, null);
  },
  update(r, e) {
    if (e.docChanged) {
      let t = r.diagnostics.map(e.changes), i = null;
      if (r.selected) {
        let n = e.changes.mapPos(r.selected.from, 1);
        i = Gi(t, r.selected.diagnostic, n) || Gi(t, null, n);
      }
      r = new ti(t, r.panel, i);
    }
    for (let t of e.effects)
      t.is(y0) ? r = ti.init(t.value, r.panel, e.state) : t.is(Fc) ? r = new ti(r.diagnostics, t.value ? Pl.open : null, r.selected) : t.is(v0) && (r = new ti(r.diagnostics, r.panel, t.value));
    return r;
  },
  provide: (r) => [
    Jn.from(r, (e) => e.panel),
    Z.decorations.from(r, (e) => e.diagnostics)
  ]
}), BQ = /* @__PURE__ */ E.mark({ class: "cm-lintRange cm-lintRange-active" });
function DQ(r, e, t) {
  let { diagnostics: i } = r.state.field(st), n = [], s = 2e8, o = 0;
  i.between(e - (t < 0 ? 1 : 0), e + (t > 0 ? 1 : 0), (a, h, { spec: c }) => {
    e >= a && e <= h && (a == h || (e > a || t > 0) && (e < h || t < 0)) && (n.push(c.diagnostic), s = Math.min(a, s), o = Math.max(h, o));
  });
  let l = r.state.facet(x0).tooltipFilter;
  return l && (n = l(n)), n.length ? {
    pos: s,
    end: o,
    above: r.state.doc.lineAt(s).to < o,
    create() {
      return { dom: IQ(r, n) };
    }
  } : null;
}
function IQ(r, e) {
  return oe("ul", { class: "cm-tooltip-lint" }, e.map((t) => k0(r, t, !1)));
}
const UQ = (r) => {
  let e = r.state.field(st, !1);
  (!e || !e.panel) && r.dispatch({ effects: LQ(r.state, [Fc.of(!0)]) });
  let t = Kn(r, Pl.open);
  return t && t.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, Xp = (r) => {
  let e = r.state.field(st, !1);
  return !e || !e.panel ? !1 : (r.dispatch({ effects: Fc.of(!1) }), !0);
}, GQ = (r) => {
  let e = r.state.field(st, !1);
  if (!e)
    return !1;
  let t = r.state.selection.main, i = e.diagnostics.iter(t.to + 1);
  return !i.value && (i = e.diagnostics.iter(0), !i.value || i.from == t.from && i.to == t.to) ? !1 : (r.dispatch({ selection: { anchor: i.from, head: i.to }, scrollIntoView: !0 }), !0);
}, NQ = [
  { key: "Mod-Shift-m", run: UQ, preventDefault: !0 },
  { key: "F8", run: GQ }
], x0 = /* @__PURE__ */ _.define({
  combine(r) {
    return Object.assign({ sources: r.map((e) => e.source) }, _t(r.map((e) => e.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null
    }, {
      needsRefresh: (e, t) => e ? t ? (i) => e(i) || t(i) : e : t
    }));
  }
});
function S0(r) {
  let e = [];
  if (r)
    e:
      for (let { name: t } of r) {
        for (let i = 0; i < t.length; i++) {
          let n = t[i];
          if (/[a-zA-Z]/.test(n) && !e.some((s) => s.toLowerCase() == n.toLowerCase())) {
            e.push(n);
            continue e;
          }
        }
        e.push("");
      }
  return e;
}
function k0(r, e, t) {
  var i;
  let n = t ? S0(e.actions) : [];
  return oe("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, oe("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage() : e.message), (i = e.actions) === null || i === void 0 ? void 0 : i.map((s, o) => {
    let l = !1, a = (d) => {
      if (d.preventDefault(), l)
        return;
      l = !0;
      let p = Gi(r.state.field(st).diagnostics, e);
      p && s.apply(r, p.from, p.to);
    }, { name: h } = s, c = n[o] ? h.indexOf(n[o]) : -1, u = c < 0 ? h : [
      h.slice(0, c),
      oe("u", h.slice(c, c + 1)),
      h.slice(c + 1)
    ];
    return oe("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: a,
      onmousedown: a,
      "aria-label": ` Action: ${h}${c < 0 ? "" : ` (access key "${n[o]})"`}.`
    }, u);
  }), e.source && oe("div", { class: "cm-diagnosticSource" }, e.source));
}
class FQ extends Kt {
  constructor(e) {
    super(), this.diagnostic = e;
  }
  eq(e) {
    return e.diagnostic == this.diagnostic;
  }
  toDOM() {
    return oe("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
  }
}
class Zp {
  constructor(e, t) {
    this.diagnostic = t, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = k0(e, t, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class Pl {
  constructor(e) {
    this.view = e, this.items = [];
    let t = (n) => {
      if (n.keyCode == 27)
        Xp(this.view), this.view.focus();
      else if (n.keyCode == 38 || n.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (n.keyCode == 40 || n.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (n.keyCode == 36)
        this.moveSelection(0);
      else if (n.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (n.keyCode == 13)
        this.view.focus();
      else if (n.keyCode >= 65 && n.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: s } = this.items[this.selectedIndex], o = S0(s.actions);
        for (let l = 0; l < o.length; l++)
          if (o[l].toUpperCase().charCodeAt(0) == n.keyCode) {
            let a = Gi(this.view.state.field(st).diagnostics, s);
            a && s.actions[l].apply(e, a.from, a.to);
          }
      } else
        return;
      n.preventDefault();
    }, i = (n) => {
      for (let s = 0; s < this.items.length; s++)
        this.items[s].dom.contains(n.target) && this.moveSelection(s);
    };
    this.list = oe("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: t,
      onclick: i
    }), this.dom = oe("div", { class: "cm-panel-lint" }, this.list, oe("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => Xp(this.view)
    }, "×")), this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(st).selected;
    if (!e)
      return -1;
    for (let t = 0; t < this.items.length; t++)
      if (this.items[t].diagnostic == e.diagnostic)
        return t;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: t } = this.view.state.field(st), i = 0, n = !1, s = null;
    for (e.between(0, this.view.state.doc.length, (o, l, { spec: a }) => {
      let h = -1, c;
      for (let u = i; u < this.items.length; u++)
        if (this.items[u].diagnostic == a.diagnostic) {
          h = u;
          break;
        }
      h < 0 ? (c = new Zp(this.view, a.diagnostic), this.items.splice(i, 0, c), n = !0) : (c = this.items[h], h > i && (this.items.splice(i, h - i), n = !0)), t && c.diagnostic == t.diagnostic ? c.dom.hasAttribute("aria-selected") || (c.dom.setAttribute("aria-selected", "true"), s = c) : c.dom.hasAttribute("aria-selected") && c.dom.removeAttribute("aria-selected"), i++;
    }); i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      n = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new Zp(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), n = !0), s ? (this.list.setAttribute("aria-activedescendant", s.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: s.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: o, panel: l }) => {
        let a = l.height / this.list.offsetHeight;
        o.top < l.top ? this.list.scrollTop -= (l.top - o.top) / a : o.bottom > l.bottom && (this.list.scrollTop += (o.bottom - l.bottom) / a);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), n && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function t() {
      let i = e;
      e = i.nextSibling, i.remove();
    }
    for (let i of this.items)
      if (i.dom.parentNode == this.list) {
        for (; e != i.dom; )
          t();
        e = i.dom.nextSibling;
      } else
        this.list.insertBefore(i.dom, e);
    for (; e; )
      t();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0)
      return;
    let t = this.view.state.field(st), i = Gi(t.diagnostics, this.items[e].diagnostic);
    i && this.view.dispatch({
      selection: { anchor: i.from, head: i.to },
      scrollIntoView: !0,
      effects: v0.of(i)
    });
  }
  static open(e) {
    return new Pl(e);
  }
}
function HQ(r, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(r)}</svg>')`;
}
function eo(r) {
  return HQ(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${r}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const KQ = /* @__PURE__ */ Z.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ eo("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ eo("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ eo("#999") },
  ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ eo("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
}), JQ = [
  st,
  /* @__PURE__ */ Z.decorations.compute([st], (r) => {
    let { selected: e, panel: t } = r.field(st);
    return !e || !t || e.from == e.to ? E.none : E.set([
      BQ.range(e.from, e.to)
    ]);
  }),
  /* @__PURE__ */ Hx(DQ, { hideOn: jQ }),
  KQ
], eP = [
  Cn(),
  aS(),
  Px(),
  $k(),
  HS(),
  mx(),
  vx(),
  U.allowMultipleSelections.of(!0),
  VS(),
  sg(tk, { fallback: !0 }),
  ak(),
  TQ(),
  WQ(),
  Vx(),
  Lx(),
  Rx(),
  P$(),
  tn.of([
    ..._Q,
    ...Gg,
    ...l0,
    ...Sg,
    ...tg,
    ...w0,
    ...NQ
  ])
];
function tP(r, e = r.state) {
  const t = /* @__PURE__ */ new Set();
  for (const { from: i, to: n } of r.visibleRanges) {
    let s = i;
    for (; s <= n; ) {
      const o = e.doc.lineAt(s);
      t.has(o) || t.add(o), s = o.to + 1;
    }
  }
  return t;
}
function Eh(r) {
  const e = r.selection.main.head;
  return r.doc.lineAt(e);
}
function _p(r, e) {
  let t = 0;
  e:
    for (let i = 0; i < r.length; i++)
      switch (r[i]) {
        case " ": {
          t += 1;
          continue e;
        }
        case "	": {
          t += e - t % e;
          continue e;
        }
        case "\r":
          continue e;
        default:
          break e;
      }
  return t;
}
const Ho = /* @__PURE__ */ _.define({
  combine(r) {
    return _t(r, {
      highlightActiveBlock: !0,
      hideFirstIndent: !1,
      markerType: "fullScope",
      thickness: 1
    });
  }
});
class rP {
  /**
   * @param lines - The set of lines to get the indentation map for.
   * @param state - The {@link EditorState} to derive the indentation map from.
   * @param unitWidth - The width of the editor's indent unit.
   * @param markerType - The type of indentation to use (terminate at end of scope vs last line of code in scope)
   */
  constructor(e, t, i, n) {
    this.lines = e, this.state = t, this.map = /* @__PURE__ */ new Map(), this.unitWidth = i, this.markerType = n;
    for (const s of this.lines)
      this.add(s);
    this.state.facet(Ho).highlightActiveBlock && this.findAndSetActiveLines();
  }
  /**
   * Checks if the indentation map has an entry for the given line.
   *
   * @param line - The {@link Line} or line number to check for.
   */
  has(e) {
    return this.map.has(typeof e == "number" ? e : e.number);
  }
  /**
   * Returns the {@link IndentEntry} for the given line.
   *
   * Note that this function will throw an error if the line does not exist in the map.
   *
   * @param line - The {@link Line} or line number to get the entry for.
   */
  get(e) {
    const t = this.map.get(typeof e == "number" ? e : e.number);
    if (!t)
      throw new Error("Line not found in indentation map");
    return t;
  }
  /**
   * Sets the {@link IndentEntry} for the given line.
   *
   * @param line - The {@link Line} to set the entry for.
   * @param col - The visual beginning whitespace width of the line.
   * @param level - The indentation level of the line.
   */
  set(e, t, i) {
    const n = !e.text.trim().length, s = { line: e, col: t, level: i, empty: n };
    return this.map.set(s.line.number, s), s;
  }
  /**
   * Adds a line to the indentation map.
   *
   * @param line - The {@link Line} to add to the map.
   */
  add(e) {
    if (this.has(e))
      return this.get(e);
    if (!e.length || !e.text.trim().length) {
      if (e.number === 1)
        return this.set(e, 0, 0);
      if (e.number === this.state.doc.lines) {
        const o = this.closestNonEmpty(e, -1);
        return this.set(e, 0, o.level);
      }
      const n = this.closestNonEmpty(e, -1), s = this.closestNonEmpty(e, 1);
      return n.level >= s.level && this.markerType !== "codeOnly" ? this.set(e, 0, n.level) : n.empty && n.level === 0 && s.level !== 0 ? this.set(e, 0, 0) : s.level > n.level ? this.set(e, 0, n.level + 1) : this.set(e, 0, s.level);
    }
    const t = _p(e.text, this.state.tabSize), i = Math.floor(t / this.unitWidth);
    return this.set(e, t, i);
  }
  /**
   * Finds the closest non-empty line, starting from the given line.
   *
   * @param from - The {@link Line} to start from.
   * @param dir - The direction to search in. Either `1` or `-1`.
   */
  closestNonEmpty(e, t) {
    let i = e.number + t;
    for (; t === -1 ? i >= 1 : i <= this.state.doc.lines; ) {
      if (this.has(i)) {
        const o = this.get(i);
        if (!o.empty)
          return o;
      }
      const s = this.state.doc.line(i);
      if (s.text.trim().length) {
        const o = _p(s.text, this.state.tabSize), l = Math.floor(o / this.unitWidth);
        return this.set(s, o, l);
      }
      i += t;
    }
    const n = this.state.doc.line(t === -1 ? 1 : this.state.doc.lines);
    return this.set(n, 0, 0);
  }
  /**
   * Finds the state's active block (via the current selection) and sets all
   * the active indent level for the lines in the block.
   */
  findAndSetActiveLines() {
    const e = Eh(this.state);
    if (!this.has(e))
      return;
    let t = this.get(e);
    if (this.has(t.line.number + 1)) {
      const s = this.get(t.line.number + 1);
      s.level > t.level && (t = s);
    }
    if (this.has(t.line.number - 1)) {
      const s = this.get(t.line.number - 1);
      s.level > t.level && (t = s);
    }
    if (t.level === 0)
      return;
    t.active = t.level;
    let i, n;
    for (i = t.line.number; i > 1; i--) {
      if (!this.has(i - 1))
        continue;
      const s = this.get(i - 1);
      if (s.level < t.level)
        break;
      s.active = t.level;
    }
    for (n = t.line.number; n < this.state.doc.lines; n++) {
      if (!this.has(n + 1))
        continue;
      const s = this.get(n + 1);
      if (s.level < t.level)
        break;
      s.active = t.level;
    }
  }
}
function iP(r) {
  const e = {
    light: "#F0F1F2",
    dark: "#2B3245",
    activeLight: "#E4E5E6",
    activeDark: "#3C445C"
  };
  let t = e;
  return r && (t = Object.assign(Object.assign({}, e), r)), Z.baseTheme({
    "&light": {
      "--indent-marker-bg-color": t.light,
      "--indent-marker-active-bg-color": t.activeLight
    },
    "&dark": {
      "--indent-marker-bg-color": t.dark,
      "--indent-marker-active-bg-color": t.activeDark
    },
    ".cm-line": {
      position: "relative"
    },
    // this pseudo-element is used to draw the indent markers,
    // while still allowing the line to have its own background.
    ".cm-indent-markers::before": {
      content: '""',
      position: "absolute",
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      background: "var(--indent-markers)",
      pointerEvents: "none",
      zIndex: "-1"
    }
  });
}
function to(r, e, t, i, n) {
  return `${`repeating-linear-gradient(to right, var(${r}) 0 ${e}px, transparent ${e}px ${t}ch)`} ${i * t}.5ch/calc(${t * n}ch - 1px) no-repeat`;
}
function nP(r, e, t, i) {
  const { level: n, active: s } = r;
  if (t && n === 0)
    return [];
  const o = t ? 1 : 0, l = [];
  if (s !== void 0) {
    const a = s - o - 1;
    a > 0 && l.push(to("--indent-marker-bg-color", i, e, o, a)), l.push(to("--indent-marker-active-bg-color", i, e, s - 1, 1)), s !== n && l.push(to("--indent-marker-bg-color", i, e, s, n - s));
  } else
    l.push(to("--indent-marker-bg-color", i, e, o, n - o));
  return l.join(",");
}
class sP {
  constructor(e) {
    this.view = e, this.unitWidth = ur(e.state), this.currentLineNumber = Eh(e.state).number, this.generate(e.state);
  }
  update(e) {
    const t = ur(e.state), i = t !== this.unitWidth;
    i && (this.unitWidth = t);
    const n = Eh(e.state).number, s = n !== this.currentLineNumber;
    this.currentLineNumber = n;
    const o = e.state.facet(Ho).highlightActiveBlock && s;
    (e.docChanged || e.viewportChanged || i || o) && this.generate(e.state);
  }
  generate(e) {
    const t = new sr(), i = tP(this.view, e), { hideFirstIndent: n, markerType: s, thickness: o } = e.facet(Ho), l = new rP(i, e, this.unitWidth, s);
    for (const a of i) {
      const h = l.get(a.number);
      if (!(h != null && h.level))
        continue;
      const c = nP(h, this.unitWidth, n, o);
      t.add(a.from, a.from, E.line({
        class: "cm-indent-markers",
        attributes: {
          style: `--indent-markers: ${c}`
        }
      }));
    }
    this.decorations = t.finish();
  }
}
function oP(r = {}) {
  return [
    Ho.of(r),
    iP(r.colors),
    ge.fromClass(sP, {
      decorations: (e) => e.decorations
    })
  ];
}
const lP = ":host{display:block;z-index:1200}.toolbar{display:flex;justify-content:space-between;align-items:center;width:100%}::slotted(*){margin:0}.toolbar__start,.toolbar__center,.toolbar__end{display:flex}.toolbar__top,.toolbar__bottom{flex-direction:row;position:fixed;left:0;right:0}.toolbar__top{top:0}.toolbar__bottom{bottom:0}.toolbar__left,.toolbar__right{flex-direction:column;position:fixed;top:0;bottom:0}.toolbar__left .toolbar__start,.toolbar__right .toolbar__start,.toolbar__left .toolbar__center,.toolbar__right .toolbar__center,.toolbar__left .toolbar__end,.toolbar__right .toolbar__end{flex-direction:column;align-items:stretch}.toolbar__left{left:0}.toolbar__right{right:0}";
var aP = Object.defineProperty, hP = Object.getOwnPropertyDescriptor, cP = Object.getPrototypeOf, uP = Reflect.get, Hc = (r, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? hP(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (n = (i ? o(e, t, n) : o(n)) || n);
  return i && n && aP(e, t, n), n;
}, dP = (r, e, t) => uP(cP(r), t, e);
let oi = class extends Pt {
  constructor() {
    super(...arguments), this.fixed = !1, this.placement = "top";
  }
  get tagTitle() {
    return "Barre d'outils";
  }
  toAsciidoc() {
    throw new Error("Method not implemented.");
  }
  render() {
    const r = {
      toolbar: !0,
      toolbar__top: this.fixed && this.placement === "top",
      toolbar__bottom: this.fixed && this.placement === "bottom"
    };
    return X`
      <div part="base" class=${je(r)}>
        <div part="start" class="toolbar__start">
          <slot name="start"></slot>
        </div>
        <div part="center" class="toolbar__center">
          <slot name="center"></slot>
        </div>
        <div part="end" class="toolbar__end">
          <slot name="end"></slot>
        </div>
      </div>
    `;
  }
};
oi.styles = [
  dP(oi, oi, "styles"),
  Zt(lP),
  re`/* layer: preflights */
*,::before,::after{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-pan-x: ;--un-pan-y: ;--un-pinch-zoom: ;--un-scroll-snap-strictness:proximity;--un-ordinal: ;--un-slashed-zero: ;--un-numeric-figure: ;--un-numeric-spacing: ;--un-numeric-fraction: ;--un-border-spacing-x:0;--un-border-spacing-y:0;--un-ring-offset-shadow:0 0 rgb(0 0 0 / 0);--un-ring-shadow:0 0 rgb(0 0 0 / 0);--un-shadow-inset: ;--un-shadow:0 0 rgb(0 0 0 / 0);--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgb(147 197 253 / 0.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: ;}::backdrop{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-pan-x: ;--un-pan-y: ;--un-pinch-zoom: ;--un-scroll-snap-strictness:proximity;--un-ordinal: ;--un-slashed-zero: ;--un-numeric-figure: ;--un-numeric-spacing: ;--un-numeric-fraction: ;--un-border-spacing-x:0;--un-border-spacing-y:0;--un-ring-offset-shadow:0 0 rgb(0 0 0 / 0);--un-ring-shadow:0 0 rgb(0 0 0 / 0);--un-shadow-inset: ;--un-shadow:0 0 rgb(0 0 0 / 0);--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgb(147 197 253 / 0.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: ;}
/* layer: typography */
:is([prose=""],.prose) :where(h1,h2,h3,h4,h5,h6):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-headings);font-weight:600;line-height:1.25;}:is([prose=""],.prose) :where(a):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-links);text-decoration:underline;font-weight:500;}:is([prose=""],.prose) :where(a code):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-links);}:is([prose=""],.prose) :where(p,ul,ol,pre):not(:where(.not-prose,.not-prose *)){margin:1em 0;line-height:1.75;}:is([prose=""],.prose) :where(blockquote):not(:where(.not-prose,.not-prose *)){margin:1em 0;padding-left:1em;font-style:italic;border-left:.25em solid var(--un-prose-borders);}:is([prose=""],.prose) :where(h1):not(:where(.not-prose,.not-prose *)){margin:1rem 0;font-size:2.25em;}:is([prose=""],.prose) :where(h2):not(:where(.not-prose,.not-prose *)){margin:1.75em 0 .5em;font-size:1.75em;}:is([prose=""],.prose) :where(h3):not(:where(.not-prose,.not-prose *)){margin:1.5em 0 .5em;font-size:1.375em;}:is([prose=""],.prose) :where(h4):not(:where(.not-prose,.not-prose *)){margin:1em 0;font-size:1.125em;}:is([prose=""],.prose) :where(img,video):not(:where(.not-prose,.not-prose *)){max-width:100%;}:is([prose=""],.prose) :where(figure,picture):not(:where(.not-prose,.not-prose *)){margin:1em 0;}:is([prose=""],.prose) :where(figcaption):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-captions);font-size:.875em;}:is([prose=""],.prose) :where(code):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-code);font-size:.875em;font-weight:600;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;}:is([prose=""],.prose) :where(:not(pre) > code):not(:where(.not-prose,.not-prose *))::before,:is([prose=""],.prose) :where(:not(pre) > code):not(:where(.not-prose,.not-prose *))::after{content:"\`";}:is([prose=""],.prose) :where(pre):not(:where(.not-prose,.not-prose *)){padding:1.25rem 1.5rem;overflow-x:auto;border-radius:.375rem;}:is([prose=""],.prose) :where(pre,code):not(:where(.not-prose,.not-prose *)){white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;hyphens:none;background:transparent;}:is([prose=""],.prose) :where(pre code):not(:where(.not-prose,.not-prose *)){font-weight:inherit;}:is([prose=""],.prose) :where(ol,ul):not(:where(.not-prose,.not-prose *)){padding-left:1.25em;}:is([prose=""],.prose) :where(ol):not(:where(.not-prose,.not-prose *)){list-style-type:decimal;}:is([prose=""],.prose) :where(ol[type="A"]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-alpha;}:is([prose=""],.prose) :where(ol[type="a"]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-alpha;}:is([prose=""],.prose) :where(ol[type="A" s]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-alpha;}:is([prose=""],.prose) :where(ol[type="a" s]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-alpha;}:is([prose=""],.prose) :where(ol[type="I"]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-roman;}:is([prose=""],.prose) :where(ol[type="i"]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-roman;}:is([prose=""],.prose) :where(ol[type="I" s]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-roman;}:is([prose=""],.prose) :where(ol[type="i" s]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-roman;}:is([prose=""],.prose) :where(ol[type="1"]):not(:where(.not-prose,.not-prose *)){list-style-type:decimal;}:is([prose=""],.prose) :where(ul):not(:where(.not-prose,.not-prose *)){list-style-type:disc;}:is([prose=""],.prose) :where(ol > li):not(:where(.not-prose,.not-prose *))::marker,:is([prose=""],.prose) :where(ul > li):not(:where(.not-prose,.not-prose *))::marker,:is([prose=""],.prose) :where(summary):not(:where(.not-prose,.not-prose *))::marker{color:var(--un-prose-lists);}:is([prose=""],.prose) :where(hr):not(:where(.not-prose,.not-prose *)){margin:2em 0;border:1px solid var(--un-prose-hr);}:is([prose=""],.prose) :where(table):not(:where(.not-prose,.not-prose *)){display:block;margin:1em 0;border-collapse:collapse;overflow-x:auto;}:is([prose=""],.prose) :where(tr):not(:where(.not-prose,.not-prose *)):nth-child(2n){background:var(--un-prose-bg-soft);}:is([prose=""],.prose) :where(td,th):not(:where(.not-prose,.not-prose *)){border:1px solid var(--un-prose-borders);padding:.625em 1em;}:is([prose=""],.prose) :where(abbr):not(:where(.not-prose,.not-prose *)){cursor:help;}:is([prose=""],.prose) :where(kbd):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-code);border:1px solid;padding:.25rem .5rem;font-size:.875em;border-radius:.25rem;}:is([prose=""],.prose) :where(details):not(:where(.not-prose,.not-prose *)){margin:1em 0;padding:1.25rem 1.5rem;background:var(--un-prose-bg-soft);}:is([prose=""],.prose) :where(summary):not(:where(.not-prose,.not-prose *)){cursor:pointer;font-weight:600;}
/* layer: default */
.fixed{position:fixed;}
.static{position:static;}`
];
Hc([
  y({ type: Boolean, reflect: !0 })
], oi.prototype, "fixed", 2);
Hc([
  y({ type: String, reflect: !0 })
], oi.prototype, "placement", 2);
oi = Hc([
  Mr("toolbar-it")
], oi);
function qh(r, e, t) {
  const i = new CustomEvent(e, {
    bubbles: !0,
    cancelable: !1,
    composed: !0,
    detail: {},
    ...t
  });
  return r.dispatchEvent(i), i;
}
function pP(r) {
  const e = r.split(`
`);
  e[0] === "" && e.splice(0, 1);
  const t = e[0];
  let i = 0;
  const s = t.startsWith("	") ? "	" : " ";
  for (; t[i] === s; )
    i += 1;
  const o = [];
  for (const l of e) {
    let a = l;
    for (let h = 0; h < i && a.startsWith(s); h++)
      a = a.substring(1);
    o.push(a);
  }
  return o[o.length - 1] === "" && o.splice(o.length - 1, 1), o.join(`
`);
}
const fP = ":host{display:block}.answer-form__fieldset{margin-bottom:var(--sl-spacing-medium);padding:var(--sl-spacing-medium);border:1px solid var(--sl-color-neutral-400);border-radius:var(--sl-border-radius-large)}.answer-form__legend{padding:var(--sl-spacing-3x-small);color:var(--sl-color-neutral-400)}";
var OP = Object.defineProperty, mP = Object.getOwnPropertyDescriptor, Tl = (r, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? mP(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (n = (i ? o(e, t, n) : o(n)) || n);
  return i && n && OP(e, t, n), n;
};
const Mn = class Mn extends Pt {
  constructor() {
    super(...arguments), this.legend = "", this.btnFeedback = !1, this.fieldset = !1;
  }
  render() {
    const e = {
      "answer-form__fieldset": !0,
      rtl: this.dir === "rtl"
    };
    return X`
      <form part="base" class="answer-form">
        ${this.fieldset ? X`
            <fieldset class=${je(e)}>
              <legend class="answer-form__legend">${this.legend}</legend>
              ${this.renderAnswer()}
            </fieldset>
            ` : this.renderAnswer()}
      </form>
    `;
  }
};
Mn.styles = [
  Ou(Mn, Mn, "styles"),
  Zt(fP),
  re`/* layer: preflights */
*,::before,::after{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-pan-x: ;--un-pan-y: ;--un-pinch-zoom: ;--un-scroll-snap-strictness:proximity;--un-ordinal: ;--un-slashed-zero: ;--un-numeric-figure: ;--un-numeric-spacing: ;--un-numeric-fraction: ;--un-border-spacing-x:0;--un-border-spacing-y:0;--un-ring-offset-shadow:0 0 rgb(0 0 0 / 0);--un-ring-shadow:0 0 rgb(0 0 0 / 0);--un-shadow-inset: ;--un-shadow:0 0 rgb(0 0 0 / 0);--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgb(147 197 253 / 0.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: ;}::backdrop{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-pan-x: ;--un-pan-y: ;--un-pinch-zoom: ;--un-scroll-snap-strictness:proximity;--un-ordinal: ;--un-slashed-zero: ;--un-numeric-figure: ;--un-numeric-spacing: ;--un-numeric-fraction: ;--un-border-spacing-x:0;--un-border-spacing-y:0;--un-ring-offset-shadow:0 0 rgb(0 0 0 / 0);--un-ring-shadow:0 0 rgb(0 0 0 / 0);--un-shadow-inset: ;--un-shadow:0 0 rgb(0 0 0 / 0);--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgb(147 197 253 / 0.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: ;}
/* layer: typography */
:is([prose=""],.prose) :where(h1,h2,h3,h4,h5,h6):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-headings);font-weight:600;line-height:1.25;}:is([prose=""],.prose) :where(a):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-links);text-decoration:underline;font-weight:500;}:is([prose=""],.prose) :where(a code):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-links);}:is([prose=""],.prose) :where(p,ul,ol,pre):not(:where(.not-prose,.not-prose *)){margin:1em 0;line-height:1.75;}:is([prose=""],.prose) :where(blockquote):not(:where(.not-prose,.not-prose *)){margin:1em 0;padding-left:1em;font-style:italic;border-left:.25em solid var(--un-prose-borders);}:is([prose=""],.prose) :where(h1):not(:where(.not-prose,.not-prose *)){margin:1rem 0;font-size:2.25em;}:is([prose=""],.prose) :where(h2):not(:where(.not-prose,.not-prose *)){margin:1.75em 0 .5em;font-size:1.75em;}:is([prose=""],.prose) :where(h3):not(:where(.not-prose,.not-prose *)){margin:1.5em 0 .5em;font-size:1.375em;}:is([prose=""],.prose) :where(h4):not(:where(.not-prose,.not-prose *)){margin:1em 0;font-size:1.125em;}:is([prose=""],.prose) :where(img,video):not(:where(.not-prose,.not-prose *)){max-width:100%;}:is([prose=""],.prose) :where(figure,picture):not(:where(.not-prose,.not-prose *)){margin:1em 0;}:is([prose=""],.prose) :where(figcaption):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-captions);font-size:.875em;}:is([prose=""],.prose) :where(code):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-code);font-size:.875em;font-weight:600;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;}:is([prose=""],.prose) :where(:not(pre) > code):not(:where(.not-prose,.not-prose *))::before,:is([prose=""],.prose) :where(:not(pre) > code):not(:where(.not-prose,.not-prose *))::after{content:"\`";}:is([prose=""],.prose) :where(pre):not(:where(.not-prose,.not-prose *)){padding:1.25rem 1.5rem;overflow-x:auto;border-radius:.375rem;}:is([prose=""],.prose) :where(pre,code):not(:where(.not-prose,.not-prose *)){white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;hyphens:none;background:transparent;}:is([prose=""],.prose) :where(pre code):not(:where(.not-prose,.not-prose *)){font-weight:inherit;}:is([prose=""],.prose) :where(ol,ul):not(:where(.not-prose,.not-prose *)){padding-left:1.25em;}:is([prose=""],.prose) :where(ol):not(:where(.not-prose,.not-prose *)){list-style-type:decimal;}:is([prose=""],.prose) :where(ol[type="A"]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-alpha;}:is([prose=""],.prose) :where(ol[type="a"]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-alpha;}:is([prose=""],.prose) :where(ol[type="A" s]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-alpha;}:is([prose=""],.prose) :where(ol[type="a" s]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-alpha;}:is([prose=""],.prose) :where(ol[type="I"]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-roman;}:is([prose=""],.prose) :where(ol[type="i"]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-roman;}:is([prose=""],.prose) :where(ol[type="I" s]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-roman;}:is([prose=""],.prose) :where(ol[type="i" s]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-roman;}:is([prose=""],.prose) :where(ol[type="1"]):not(:where(.not-prose,.not-prose *)){list-style-type:decimal;}:is([prose=""],.prose) :where(ul):not(:where(.not-prose,.not-prose *)){list-style-type:disc;}:is([prose=""],.prose) :where(ol > li):not(:where(.not-prose,.not-prose *))::marker,:is([prose=""],.prose) :where(ul > li):not(:where(.not-prose,.not-prose *))::marker,:is([prose=""],.prose) :where(summary):not(:where(.not-prose,.not-prose *))::marker{color:var(--un-prose-lists);}:is([prose=""],.prose) :where(hr):not(:where(.not-prose,.not-prose *)){margin:2em 0;border:1px solid var(--un-prose-hr);}:is([prose=""],.prose) :where(table):not(:where(.not-prose,.not-prose *)){display:block;margin:1em 0;border-collapse:collapse;overflow-x:auto;}:is([prose=""],.prose) :where(tr):not(:where(.not-prose,.not-prose *)):nth-child(2n){background:var(--un-prose-bg-soft);}:is([prose=""],.prose) :where(td,th):not(:where(.not-prose,.not-prose *)){border:1px solid var(--un-prose-borders);padding:.625em 1em;}:is([prose=""],.prose) :where(abbr):not(:where(.not-prose,.not-prose *)){cursor:help;}:is([prose=""],.prose) :where(kbd):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-code);border:1px solid;padding:.25rem .5rem;font-size:.875em;border-radius:.25rem;}:is([prose=""],.prose) :where(details):not(:where(.not-prose,.not-prose *)){margin:1em 0;padding:1.25rem 1.5rem;background:var(--un-prose-bg-soft);}:is([prose=""],.prose) :where(summary):not(:where(.not-prose,.not-prose *)){cursor:pointer;font-weight:600;}
/* layer: default */
.static{position:static;}`
];
let mi = Mn;
Tl([
  J("form.answer-form")
], mi.prototype, "form", 2);
Tl([
  y({ type: String, reflect: !0 })
], mi.prototype, "legend", 2);
Tl([
  y({ type: Boolean, reflect: !0, attribute: "btn-feedback" })
], mi.prototype, "btnFeedback", 2);
Tl([
  y({ type: Boolean, reflect: !0 })
], mi.prototype, "fieldset", 2);
const gP = {
  // @codemirror/view
  "Control character": "caractère de contrôle",
  // @codemirror/commands
  "Selection deleted": "sélection supprimée",
  // @codemirror/language
  "Folded lines": "lignes pliées",
  "Unfolded lines": "lignes dépliées",
  to: "à",
  "folded code": "code plié",
  unfold: "déplier",
  "Fold line": "plier la ligne",
  "Unfold line": "déplier la ligne",
  // @codemirror/search
  "Go to line": "atteindre la ligne (ligne:colonne) ",
  go: "ok",
  Find: "chercher",
  Replace: "remplacer",
  next: "suivant",
  previous: "précédent",
  all: "tout",
  "match case": "respecter la casse",
  "by word": "mot entier",
  regexp: "expression régulière",
  replace: "remplacer",
  "replace all": "remplacer tout",
  close: "fermer",
  "current match": "correspondance courante",
  "replaced $ matches": "$ correspondances remplacées",
  "replaced match on line $": "correspondance remplacée à la ligne $",
  "on line": "en ligne",
  // @codemirror/autocomplete
  Completions: "complétions",
  // @codemirror/lint
  Diagnostics: "diagnostics",
  "No diagnostics": "pas de diagnostic"
};
function $0() {
  const r = navigator.userAgent;
  return r.search("Windows") !== -1 ? "windows" : r.search("Mac") !== -1 ? "mac" : r.search("X11") !== -1 ? "unix" : r.search("Linux") !== -1 ? "linux" : "unknown";
}
function bP() {
  const r = [], e = {
    "Mod-z": "undo",
    "Mod-y": "redo",
    "Mod-u": "undoSelection",
    "Alt-u": "redoSelection",
    "Ctrl-Shift-z": "redo"
  };
  return Sg.forEach((t) => {
    if ((t.key || t.mac) && t.run) {
      if (t.key && t.mac)
        r.push({ name: e[t.key], key: t.mac.replace("Mod-", "Cmd-"), run: t.run });
      else if (t.key && !t.mac) {
        const i = $0() === "mac" ? "Cmd-" : "Ctrl-";
        r.push({ name: e[t.key], key: t.key.replace("Mod-", i), run: t.run });
      }
    }
  }), r;
}
function Q0() {
  let r = [];
  return Gg.concat(tg).concat(l0).concat([Ng]).forEach((t) => {
    var i, n;
    if ((t.key || t.mac) && t.run && t.run.name) {
      if (t.mac)
        r.push({ name: t.run.name, key: t.mac.replace("Mod-", "Cmd-"), run: t.run }), (i = t.shift) != null && i.name && r.push({ name: t.shift.name, key: `Shift-${t.mac}`.replace("Mod-", "Cmd-"), run: t.run });
      else if (t.key && !t.mac) {
        const s = $0() === "mac" ? "Cmd-" : "Ctrl-";
        r.push({ name: t.run.name, key: t.key.replace("Mod-", s), run: t.run }), (n = t.shift) != null && n.name && r.push({ name: t.shift.name, key: `Shift-${t.key}`.replace("Mod-", s), run: t.run });
      }
    }
  }), r = r.concat(bP()), r.sort((t, i) => t.name < i.name ? -1 : 1), r;
}
console.log(Q0());
const P0 = ({ variant: r, settings: e, styles: t }) => {
  const i = Z.theme(
    {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      "&": {
        backgroundColor: e.background,
        color: e.foreground
      },
      ".cm-content": {
        caretColor: e.caret
      },
      ".cm-cursor, .cm-dropCursor": {
        borderLeftColor: e.caret
      },
      "&.cm-focused .cm-selectionBackground, .cm-content ::selection": {
        backgroundColor: e.selection
      },
      ".cm-activeLine": {
        backgroundColor: e.lineHighlight
      },
      ".cm-gutters": {
        backgroundColor: e.gutterBackground,
        color: e.gutterForeground
      },
      ".cm-activeLineGutter": {
        backgroundColor: e.lineHighlight
      }
    },
    {
      dark: r === "dark"
    }
  ), n = $s.define(t);
  return [i, sg(n)];
}, Rp = P0({
  variant: "dark",
  settings: {
    background: "#00254b",
    foreground: "#FFFFFF",
    caret: "#FFFFFF",
    selection: "#B36539BF",
    gutterBackground: "#00254b",
    gutterForeground: "#FFFFFF70",
    lineHighlight: "#00000059"
  },
  styles: [
    {
      tag: O.comment,
      color: "#0088FF"
    },
    {
      tag: O.string,
      color: "#3AD900"
    },
    {
      tag: O.regexp,
      color: "#80FFC2"
    },
    {
      tag: [O.number, O.bool, O.null],
      color: "#FF628C"
    },
    {
      tag: [O.definitionKeyword, O.modifier],
      color: "#FFEE80"
    },
    {
      tag: O.variableName,
      color: "#CCCCCC"
    },
    {
      tag: O.self,
      color: "#FF80E1"
    },
    {
      tag: [
        O.className,
        O.definition(O.propertyName),
        O.function(O.variableName),
        O.definition(O.typeName),
        O.labelName
      ],
      color: "#FFDD00"
    },
    {
      tag: [O.keyword, O.operator],
      color: "#FF9D00"
    },
    {
      tag: [O.propertyName, O.typeName],
      color: "#80FFBB"
    },
    {
      tag: O.special(O.brace),
      color: "#EDEF7D"
    },
    {
      tag: O.attributeName,
      color: "#9EFFFF"
    },
    {
      tag: O.derefOperator,
      color: "#fff"
    }
  ]
}), Ap = P0({
  variant: "light",
  settings: {
    background: "#faf4ed",
    foreground: "#575279",
    caret: "#575279",
    selection: "#6e6a8614",
    gutterBackground: "#faf4ed",
    gutterForeground: "#57527970",
    lineHighlight: "#6e6a860d"
  },
  styles: [
    {
      tag: O.comment,
      color: "#9893a5"
    },
    {
      tag: [O.bool, O.null],
      color: "#286983"
    },
    {
      tag: O.number,
      color: "#d7827e"
    },
    {
      tag: O.className,
      color: "#d7827e"
    },
    {
      tag: [O.angleBracket, O.tagName, O.typeName],
      color: "#56949f"
    },
    {
      tag: O.attributeName,
      color: "#907aa9"
    },
    {
      tag: O.punctuation,
      color: "#797593"
    },
    {
      tag: [O.keyword, O.modifier],
      color: "#286983"
    },
    {
      tag: [O.string, O.regexp],
      color: "#ea9d34"
    },
    {
      tag: O.variableName,
      color: "#d7827e"
    }
  ]
});
var wP = function() {
  var r = "[a-zA-Z¡-￿]+\\b";
  this.$rules = {
    start: [
      { token: "empty", regex: /$/ },
      { token: "literal", regex: /^\.{4,}\s*$/, next: "listingBlock" },
      { token: "literal", regex: /^-{4,}\s*$/, next: "literalBlock" },
      { token: "literal", regex: /^\+{4,}\s*$/, next: "passthroughBlock" },
      { token: "keyword", regex: /^={4,}\s*$/ },
      { token: "text", regex: /^\s*$/ },
      // immediately return to the start mode without matching anything
      { token: "empty", regex: "", next: "dissallowDelimitedBlock" }
    ],
    dissallowDelimitedBlock: [
      { include: "paragraphEnd" },
      { token: "comment", regex: "^//.+$" },
      { token: "keyword", regex: "^(?:NOTE|TIP|IMPORTANT|WARNING|CAUTION):\\s" },
      { include: "listStart" },
      { token: "literal", regex: /^\s+.+$/, next: "indentedBlock" },
      { token: "empty", regex: "", next: "text" }
    ],
    paragraphEnd: [
      { token: "doc.comment", regex: /^\/{4,}\s*$/, next: "commentBlock" },
      { token: "tableBlock", regex: /^\s*[|!]=+\s*$/, next: "tableBlock" },
      // open block, ruler
      { token: "keyword", regex: /^(?:--|''')\s*$/, next: "start" },
      { token: "option", regex: /^\[.*\]\s*$/, next: "start" },
      { token: "pageBreak", regex: /^>{3,}$/, next: "start" },
      { token: "literal", regex: /^\.{4,}\s*$/, next: "listingBlock" },
      { token: "titleUnderline", regex: /^(?:={2,}|-{2,}|~{2,}|\^{2,}|\+{2,})\s*$/, next: "start" },
      { token: "singleLineTitle", regex: /^={1,6}\s+\S.*$/, next: "start" },
      { token: "otherBlock", regex: /^(?:\*{2,}|_{2,})\s*$/, next: "start" },
      // .optional title
      { token: "optionalTitle", regex: /^\.[^.\s].+$/, next: "start" }
    ],
    listStart: [
      {
        token: "keyword",
        regex: /^\s*(?:\d+\.|[a-zA-Z]\.|[ixvmIXVM]+\)|\*{1,5}|-|\.{1,5})\s/,
        next: "listText"
      },
      { token: "meta.tag", regex: /^.+(?::{2,4}|;;)(?: |$)/, next: "listText" },
      // continuation
      { token: "keyword", regex: /^\+\s*$/, next: "start" }
    ],
    text: [
      {
        token: ["link", "link"],
        regex: /((?:https?:\/\/|ftp:\/\/|file:\/\/|mailto:|callto:)[^\s\[]+)(\[.*?\])/
      },
      { token: ["link", "link"], regex: /(?:https?:\/\/|ftp:\/\/|file:\/\/|mailto:|callto:)[^\s\[]+/ },
      { token: "link", regex: /\b[\w\.\/\-]+@[\w\.\/\-]+\b/ },
      { include: "macros" },
      { include: "paragraphEnd" },
      { token: "literal", regex: /\+{3,}/, next: "smallPassthrough" },
      {
        token: "escape",
        regex: /\((?:C|TM|R)\)|\.{3}|->|<-|=>|<=|&#(?:\d+|x[a-fA-F\d]+);|(?: |^)--(?=\s+\S)/
      },
      { token: "escape", regex: /\\[_*'`+#]|\\{2}[_*'`+#]{2}/ },
      { token: "keyword", regex: /\s\+$/ },
      // any word
      { token: "text", regex: r },
      {
        token: ["keyword", "string", "keyword"],
        regex: /(<<[\w\d\-$]+,)(.*?)(>>|$)/
      },
      { token: "keyword", regex: /<<[\w\d\-$]+,?|>>/ },
      { token: "constant.character", regex: /\({2,3}.*?\){2,3}/ },
      // List of callouts
      { token: "support.function.list.callout", regex: /^(?:<\d+>|\d+>|>) /, next: "text" },
      // Anchor
      { token: "keyword", regex: /\[\[.+?\]\]/ },
      // bibliography
      { token: "support", regex: /^\[{3}[\w\d =\-]+\]{3}/ },
      { include: "quotes" },
      // text block end
      { token: "empty", regex: /^\s*$/, next: "start" }
    ],
    listText: [
      { include: "listStart" },
      { include: "text" }
    ],
    indentedBlock: [
      { token: "literal", regex: /^[\s\w].+$/, next: "indentedBlock" },
      { token: "literal", regex: "", next: "start" }
    ],
    listingBlock: [
      { token: "literal", regex: /^\.{4,}\s*$/, next: "dissallowDelimitedBlock" },
      { token: "constant.numeric", regex: "<\\d+>" },
      { token: "literal", regex: "[^<]+" },
      { token: "literal", regex: "<" }
    ],
    literalBlock: [
      { token: "literal", regex: /^-{4,}\s*$/, next: "dissallowDelimitedBlock" },
      { token: "constant.numeric", regex: "<\\d+>" },
      { token: "literal", regex: "[^<]+" },
      { token: "literal", regex: "<" }
    ],
    passthroughBlock: [
      { token: "literal", regex: /^\+{4,}\s*$/, next: "dissallowDelimitedBlock" },
      { token: "literal", regex: r + "|\\d+" },
      { include: "macros" },
      { token: "literal", regex: "." }
    ],
    smallPassthrough: [
      { token: "literal", regex: /[+]{3,}/, next: "dissallowDelimitedBlock" },
      { token: "literal", regex: /^\s*$/, next: "dissallowDelimitedBlock" },
      { token: "literal", regex: r + "|\\d+" },
      { include: "macros" }
    ],
    commentBlock: [
      { token: "doc.comment", regex: /^\/{4,}\s*$/, next: "dissallowDelimitedBlock" },
      { token: "doc.comment", regex: "^.*$" }
    ],
    tableBlock: [
      { token: "tableBlock", regex: /^\s*\|={3,}\s*$/, next: "dissallowDelimitedBlock" },
      { token: "tableBlock", regex: /^\s*!={3,}\s*$/, next: "innerTableBlock" },
      { token: "tableBlock", regex: /\|/ },
      { include: "text", noEscape: !0 }
    ],
    innerTableBlock: [
      { token: "tableBlock", regex: /^\s*!={3,}\s*$/, next: "tableBlock" },
      { token: "tableBlock", regex: /^\s*|={3,}\s*$/, next: "dissallowDelimitedBlock" },
      { token: "tableBlock", regex: /\!/ }
    ],
    macros: [
      { token: "macro", regex: /{[\w\-$]+}/ },
      {
        token: ["text", "string", "text", "constant.character", "text"],
        regex: /({)([\w\-$]+)(:)?(.+)?(})/
      },
      {
        token: ["text", "markup.list.macro", "keyword", "string"],
        regex: /(\w+)(footnote(?:ref)?::?)([^\s\[]+)?(\[.*?\])?/
      },
      {
        token: ["markup.list.macro", "keyword", "string"],
        regex: /([a-zA-Z\-][\w\.\/\-]*::?)([^\s\[]+)(\[.*?\])?/
      },
      { token: ["markup.list.macro", "keyword"], regex: /([a-zA-Z\-][\w\.\/\-]+::?)(\[.*?\])/ },
      { token: "keyword", regex: /^:.+?:(?= |$)/ }
    ],
    quotes: [
      { token: "string.italic", regex: /__[^_\s].*?__/ },
      { token: "string.italic", regex: e("_") },
      { token: "keyword.bold", regex: /\*\*[^*\s].*?\*\*/ },
      { token: "keyword.bold", regex: e("\\*") },
      { token: "literal", regex: /\+\+[^+\s].*?\+\+/ },
      { token: "literal", regex: e("\\+") },
      { token: "literal", regex: /\$\$.+?\$\$/ },
      { token: "literal", regex: e("\\$") },
      { token: "literal", regex: /``[^`\s].*?``/ },
      { token: "literal", regex: e("`") },
      { token: "keyword", regex: /\^[^\^].*?\^/ },
      { token: "keyword", regex: e("\\^") },
      { token: "keyword", regex: /~[^~].*?~/ },
      { token: "keyword", regex: e("~") },
      { token: "keyword", regex: /##?/ },
      { token: "keyword", regex: /(?:\B|^)``|\b''/ }
    ]
  };
  function e(a) {
    var h = /\w/.test(a) ? "\\b" : "(?:\\B|^)";
    return h + a + "[^" + a + "].*?" + a + "(?![\\w*])";
  }
  var t = {
    macro: "constant.character",
    tableBlock: "doc.comment",
    titleUnderline: "markup.heading",
    singleLineTitle: "markup.heading",
    pageBreak: "string",
    option: "string.regexp",
    otherBlock: "markup.list",
    literal: "support.function",
    optionalTitle: "constant.numeric",
    escape: "constant.language.escape",
    link: "markup.underline.list"
  };
  for (var i in this.$rules)
    for (var n = this.$rules[i], s = n.length; s--; ) {
      var o = n[s];
      if (o.include || typeof o == "string") {
        var l = [s, 1].concat(this.$rules[o.include || o]);
        o.noEscape && (l = l.filter(function(a) {
          return !a.next;
        })), n.splice.apply(n, l);
      } else
        o.token in t && (o.token = t[o.token]);
    }
}, Ep = 1e3, T0 = function(r) {
  this.states = r, this.regExps = {}, this.matchMappings = {};
  for (var e in this.states) {
    for (var t = this.states[e], i = [], n = 0, s = this.matchMappings[e] = { defaultToken: "text" }, o = "g", l = [], a = 0; a < t.length; a++) {
      var h = t[a];
      if (h.defaultToken && (s.defaultToken = h.defaultToken), h.caseInsensitive && (o = "gi"), h.regex != null) {
        h.regex instanceof RegExp && (h.regex = h.regex.toString().slice(1, -1));
        var c = h.regex, u = new RegExp("(?:(" + c + ")|(.))").exec("a").length - 2;
        if (Array.isArray(h.token))
          if (h.token.length == 1 || u == 1)
            h.token = h.token[0];
          else {
            if (u - 1 != h.token.length)
              throw new Error("number of classes and regexp groups in '" + h.token + `'
'` + h.regex + `' doesn't match
` + (u - 1) + "!=" + h.token.length);
            h.tokenArray = h.token, h.token = null, h.onMatch = this.$arrayTokens;
          }
        else
          typeof h.token == "function" && !h.onMatch && (u > 1 ? h.onMatch = this.$applyToken : h.onMatch = h.token);
        u > 1 && (/\\\d/.test(h.regex) ? c = h.regex.replace(/\\([0-9]+)/g, function(d, p) {
          return "\\" + (parseInt(p, 10) + n + 1);
        }) : (u = 1, c = this.removeCapturingGroups(h.regex)), !h.splitRegex && typeof h.token != "string" && l.push(h)), s[n] = a, n += u, i.push(c), h.onMatch || (h.onMatch = null);
      }
    }
    l.forEach(function(d) {
      d.splitRegex = this.createSplitterRegexp(d.regex, o);
    }, this), this.regExps[e] = new RegExp("(" + i.join(")|(") + ")|($)", o);
  }
};
(function() {
  this.$setMaxTokenCount = function(r) {
    Ep = r | 0;
  }, this.$applyToken = function(r) {
    var e = this.splitRegex.exec(r).slice(1), t = this.token.apply(this, e);
    if (typeof t == "string")
      return [{ type: t, value: r }];
    for (var i = [], n = 0, s = t.length; n < s; n++)
      e[n] && (i[i.length] = {
        type: t[n],
        value: e[n]
      });
    return i;
  }, this.$arrayTokens = function(r) {
    if (!r)
      return [];
    var e = this.splitRegex.exec(r);
    if (!e)
      return "text";
    for (var t = [], i = this.tokenArray, n = 0, s = i.length; n < s; n++)
      e[n + 1] && (t[t.length] = {
        type: i[n],
        value: e[n + 1]
      });
    return t;
  }, this.removeCapturingGroups = function(r) {
    var e = r.replace(
      /\[(?:\\.|[^\]])*?\]|\\.|\(\?[:=!]|(\()/g,
      function(t, i) {
        return i ? "(?:" : t;
      }
    );
    return e;
  }, this.createSplitterRegexp = function(r, e) {
    if (r.indexOf("(?=") != -1) {
      var t = 0, i = !1, n = {};
      r.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function(s, o, l, a, h, c) {
        return i ? i = h != "]" : h ? i = !0 : a ? (t == n.stack && (n.end = c + 1, n.stack = -1), t--) : l && (t++, l.length != 1 && (n.stack = t, n.start = c)), s;
      }), n.end != null && /^\)*$/.test(r.substr(n.end)) && (r = r.substring(0, n.start) + r.substr(n.end));
    }
    return new RegExp(r, (e || "").replace("g", ""));
  }, this.getLineTokens = function(r, e) {
    if (e && typeof e != "string") {
      var t = e.slice(0);
      e = t[0];
    } else
      var t = [];
    var i = e || "start", n = this.states[i];
    n || (i = "start", n = this.states[i]);
    var s = this.matchMappings[i], o = this.regExps[i];
    o.lastIndex = 0;
    for (var l, a = [], h = 0, c = { type: null, value: "" }; l = o.exec(r); ) {
      var u = s.defaultToken, d = null, p = l[0], f = o.lastIndex;
      if (f - p.length > h) {
        var m = r.substring(h, f - p.length);
        c.type == u ? c.value += m : (c.type && a.push(c), c = { type: u, value: m });
      }
      for (var g = 0; g < l.length - 2; g++)
        if (l[g + 1] !== void 0) {
          d = n[s[g]], d.onMatch ? u = d.onMatch(p, i, t) : u = d.token, d.next && (typeof d.next == "string" ? i = d.next : i = d.next(i, t), n = this.states[i], n || (window.console && console.error && console.error(i, "doesn't exist"), i = "start", n = this.states[i]), s = this.matchMappings[i], h = f, o = this.regExps[i], o.lastIndex = f);
          break;
        }
      if (p) {
        if (typeof u == "string")
          (!d || d.merge !== !1) && c.type === u ? c.value += p : (c.type && a.push(c), c = { type: u, value: p });
        else if (u) {
          c.type && a.push(c), c = { type: null, value: "" };
          for (var g = 0; g < u.length; g++)
            a.push(u[g]);
        }
      }
      if (h == r.length)
        break;
      if (h = f, a.length > Ep) {
        for (; h < r.length; )
          c.type && a.push(c), c = {
            value: r.substring(h, h += 2e3),
            type: "overflow"
          };
        i = "start", t = [];
        break;
      }
    }
    return c.type && a.push(c), t.length > 1 && t[0] !== i && t.unshift(i), {
      tokens: a,
      state: t.length ? t : i
    };
  };
}).call(T0.prototype);
var qp = {
  empty: null,
  text: null,
  // Keyword
  keyword: "keyword",
  control: "keyword",
  operator: "operator",
  // Constants
  constant: "atom",
  numeric: "number",
  character: "atom",
  escape: "atom",
  // Variables
  variable: "variable",
  parameter: "variable-3",
  language: "variable-2",
  // Python's `self` uses that.
  // Comments
  comment: "comment",
  line: "comment",
  "double-slash": "comment",
  "double-dash": "comment",
  "number-sign": "comment",
  percentage: "comment",
  block: "comment",
  doc: "comment",
  // String
  string: "string",
  quoted: "string",
  single: "string",
  double: "string",
  triple: "string",
  unquoted: "string",
  interpolated: "string",
  regexp: "string-2",
  meta: "keyword",
  literal: "qualifier",
  support: "builtin",
  // Markup
  markup: "tag",
  underline: "link",
  link: "link",
  strong: "strong",
  heading: "header",
  em: "em",
  list: "variable-2",
  numbered: "variable-2",
  unnumbered: "variable-2",
  quote: "quote",
  raw: "variable-2",
  // Markdown's raw block uses that.
  // Invalid
  invalid: "error",
  illegal: "invalidchar",
  deprecated: "error"
}, yP = function(r) {
  for (var e = null, t = 0; t < r.length; t++)
    qp[r[t]] !== void 0 && (e = qp[r[t]]);
  return e;
}, zp = function(r, e) {
  var t = e.plannedTokens.shift();
  if (t === void 0)
    return null;
  r.match(t.value);
  var i = t.type.split(".");
  return yP(i);
}, Yp = function(r, e) {
  if (e.plannedTokens.length > 0)
    return zp(r, e);
  var t = e.current, i = r.match(/.*$/, !1)[0], n = xP.getLineTokens(i, t);
  return e.plannedTokens = n.tokens, e.current = n.state, zp(r, e);
}, vP = new wP(), xP = new T0(vP.$rules);
const SP = {
  startState: function() {
    return {
      current: "start",
      // List of {value, type}, with type being an Ace token string.
      plannedTokens: []
    };
  },
  blankLine: function(r) {
    Yp("", r);
  },
  token: Yp
};
class Ko {
  /**
  @internal
  */
  constructor(e, t, i, n, s, o, l, a, h, c = 0, u) {
    this.p = e, this.stack = t, this.state = i, this.reducePos = n, this.pos = s, this.score = o, this.buffer = l, this.bufferBase = a, this.curContext = h, this.lookAhead = c, this.parent = u;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((e, t) => t % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(e, t, i = 0) {
    let n = e.parser.context;
    return new Ko(e, [], t, i, i, 0, [], 0, n ? new Wp(n, n.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(e, t) {
    this.stack.push(this.state, t, this.bufferBase + this.buffer.length), this.state = e;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(e) {
    var t;
    let i = e >> 19, n = e & 65535, { parser: s } = this.p, o = s.dynamicPrecedence(n);
    if (o && (this.score += o), i == 0) {
      this.pushState(s.getGoto(this.state, n, !0), this.reducePos), n < s.minRepeatTerm && this.storeNode(n, this.reducePos, this.reducePos, 4, !0), this.reduceContext(n, this.reducePos);
      return;
    }
    let l = this.stack.length - (i - 1) * 3 - (e & 262144 ? 6 : 0), a = l ? this.stack[l - 2] : this.p.ranges[0].from, h = this.reducePos - a;
    h >= 2e3 && !(!((t = this.p.parser.nodeSet.types[n]) === null || t === void 0) && t.isAnonymous) && (a == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = h) : this.p.lastBigReductionSize < h && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = a, this.p.lastBigReductionSize = h));
    let c = l ? this.stack[l - 1] : 0, u = this.bufferBase + this.buffer.length - c;
    if (n < s.minRepeatTerm || e & 131072) {
      let d = s.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(n, a, d, u + 4, !0);
    }
    if (e & 262144)
      this.state = this.stack[l];
    else {
      let d = this.stack[l - 3];
      this.state = s.getGoto(d, n, !0);
    }
    for (; this.stack.length > l; )
      this.stack.pop();
    this.reduceContext(n, a);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(e, t, i, n = 4, s = !1) {
    if (e == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let o = this, l = this.buffer.length;
      if (l == 0 && o.parent && (l = o.bufferBase - o.parent.bufferBase, o = o.parent), l > 0 && o.buffer[l - 4] == 0 && o.buffer[l - 1] > -1) {
        if (t == i)
          return;
        if (o.buffer[l - 2] >= t) {
          o.buffer[l - 2] = i;
          return;
        }
      }
    }
    if (!s || this.pos == i)
      this.buffer.push(e, t, i, n);
    else {
      let o = this.buffer.length;
      if (o > 0 && this.buffer[o - 4] != 0)
        for (; o > 0 && this.buffer[o - 2] > i; )
          this.buffer[o] = this.buffer[o - 4], this.buffer[o + 1] = this.buffer[o - 3], this.buffer[o + 2] = this.buffer[o - 2], this.buffer[o + 3] = this.buffer[o - 1], o -= 4, n > 4 && (n -= 4);
      this.buffer[o] = e, this.buffer[o + 1] = t, this.buffer[o + 2] = i, this.buffer[o + 3] = n;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(e, t, i, n) {
    if (e & 131072)
      this.pushState(e & 65535, this.pos);
    else if (e & 262144)
      this.pos = n, this.shiftContext(t, i), t <= this.p.parser.maxNode && this.buffer.push(t, i, n, 4);
    else {
      let s = e, { parser: o } = this.p;
      (n > this.pos || t <= o.maxNode) && (this.pos = n, o.stateFlag(
        s,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = n)), this.pushState(s, i), this.shiftContext(t, i), t <= o.maxNode && this.buffer.push(t, i, n, 4);
    }
  }
  // Apply an action
  /**
  @internal
  */
  apply(e, t, i, n) {
    e & 65536 ? this.reduce(e) : this.shift(e, t, i, n);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(e, t) {
    let i = this.p.reused.length - 1;
    (i < 0 || this.p.reused[i] != e) && (this.p.reused.push(e), i++);
    let n = this.pos;
    this.reducePos = this.pos = n + e.length, this.pushState(t, n), this.buffer.push(
      i,
      n,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let e = this, t = e.buffer.length;
    for (; t > 0 && e.buffer[t - 2] > e.reducePos; )
      t -= 4;
    let i = e.buffer.slice(t), n = e.bufferBase + t;
    for (; e && n == e.bufferBase; )
      e = e.parent;
    return new Ko(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, i, n, this.curContext, this.lookAhead, e);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(e, t) {
    let i = e <= this.p.parser.maxNode;
    i && this.storeNode(e, this.pos, t, 4), this.storeNode(0, this.pos, t, i ? 8 : 4), this.pos = this.reducePos = t, this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(e) {
    for (let t = new kP(this); ; ) {
      let i = this.p.parser.stateSlot(
        t.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(t.state, e);
      if (i == 0)
        return !1;
      if (!(i & 65536))
        return !0;
      t.reduce(i);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(e) {
    if (this.stack.length >= 300)
      return [];
    let t = this.p.parser.nextStates(this.state);
    if (t.length > 8 || this.stack.length >= 120) {
      let n = [];
      for (let s = 0, o; s < t.length; s += 2)
        (o = t[s + 1]) != this.state && this.p.parser.hasAction(o, e) && n.push(t[s], o);
      if (this.stack.length < 120)
        for (let s = 0; n.length < 8 && s < t.length; s += 2) {
          let o = t[s + 1];
          n.some((l, a) => a & 1 && l == o) || n.push(t[s], o);
        }
      t = n;
    }
    let i = [];
    for (let n = 0; n < t.length && i.length < 4; n += 2) {
      let s = t[n + 1];
      if (s == this.state)
        continue;
      let o = this.split();
      o.pushState(s, this.pos), o.storeNode(0, o.pos, o.pos, 4, !0), o.shiftContext(t[n], this.pos), o.reducePos = this.pos, o.score -= 200, i.push(o);
    }
    return i;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: e } = this.p, t = e.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if (!(t & 65536))
      return !1;
    if (!e.validAction(this.state, t)) {
      let i = t >> 19, n = t & 65535, s = this.stack.length - i * 3;
      if (s < 0 || e.getGoto(this.stack[s], n, !1) < 0) {
        let o = this.findForcedReduction();
        if (o == null)
          return !1;
        t = o;
      }
      this.storeNode(0, this.pos, this.pos, 4, !0), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(t), !0;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: e } = this.p, t = [], i = (n, s) => {
      if (!t.includes(n))
        return t.push(n), e.allActions(n, (o) => {
          if (!(o & 393216))
            if (o & 65536) {
              let l = (o >> 19) - s;
              if (l > 1) {
                let a = o & 65535, h = this.stack.length - l * 3;
                if (h >= 0 && e.getGoto(this.stack[h], a, !1) >= 0)
                  return l << 19 | 65536 | a;
              }
            } else {
              let l = i(o, s + 1);
              if (l != null)
                return l;
            }
        });
    };
    return i(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return !1;
    let { parser: e } = this.p;
    return e.data[e.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !e.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, !0), this.state = this.stack[0], this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(e) {
    if (this.state != e.state || this.stack.length != e.stack.length)
      return !1;
    for (let t = 0; t < this.stack.length; t += 3)
      if (this.stack[t] != e.stack[t])
        return !1;
    return !0;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(e) {
    return this.p.parser.dialect.flags[e];
  }
  shiftContext(e, t) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(t)));
  }
  reduceContext(e, t) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(t)));
  }
  /**
  @internal
  */
  emitContext() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(e) {
    if (e != this.curContext.context) {
      let t = new Wp(this.curContext.tracker, e);
      t.hash != this.curContext.hash && this.emitContext(), this.curContext = t;
    }
  }
  /**
  @internal
  */
  setLookAhead(e) {
    e > this.lookAhead && (this.emitLookAhead(), this.lookAhead = e);
  }
  /**
  @internal
  */
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
}
class Wp {
  constructor(e, t) {
    this.tracker = e, this.context = t, this.hash = e.strict ? e.hash(t) : 0;
  }
}
class kP {
  constructor(e) {
    this.start = e, this.state = e.state, this.stack = e.stack, this.base = this.stack.length;
  }
  reduce(e) {
    let t = e & 65535, i = e >> 19;
    i == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (i - 1) * 3;
    let n = this.start.p.parser.getGoto(this.stack[this.base - 3], t, !0);
    this.state = n;
  }
}
class Jo {
  constructor(e, t, i) {
    this.stack = e, this.pos = t, this.index = i, this.buffer = e.buffer, this.index == 0 && this.maybeNext();
  }
  static create(e, t = e.bufferBase + e.buffer.length) {
    return new Jo(e, t, t - e.bufferBase);
  }
  maybeNext() {
    let e = this.stack.parent;
    e != null && (this.index = this.stack.bufferBase - e.bufferBase, this.stack = e, this.buffer = e.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new Jo(this.stack, this.pos, this.index);
  }
}
function Xn(r, e = Uint16Array) {
  if (typeof r != "string")
    return r;
  let t = null;
  for (let i = 0, n = 0; i < r.length; ) {
    let s = 0;
    for (; ; ) {
      let o = r.charCodeAt(i++), l = !1;
      if (o == 126) {
        s = 65535;
        break;
      }
      o >= 92 && o--, o >= 34 && o--;
      let a = o - 32;
      if (a >= 46 && (a -= 46, l = !0), s += a, l)
        break;
      s *= 46;
    }
    t ? t[n++] = s : t = new e(s);
  }
  return t;
}
class yo {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}
const Vp = new yo();
class $P {
  /**
  @internal
  */
  constructor(e, t) {
    this.input = e, this.ranges = t, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = Vp, this.rangeIndex = 0, this.pos = this.chunkPos = t[0].from, this.range = t[0], this.end = t[t.length - 1].to, this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(e, t) {
    let i = this.range, n = this.rangeIndex, s = this.pos + e;
    for (; s < i.from; ) {
      if (!n)
        return null;
      let o = this.ranges[--n];
      s -= i.from - o.to, i = o;
    }
    for (; t < 0 ? s > i.to : s >= i.to; ) {
      if (n == this.ranges.length - 1)
        return null;
      let o = this.ranges[++n];
      s += o.from - i.to, i = o;
    }
    return s;
  }
  /**
  @internal
  */
  clipPos(e) {
    if (e >= this.range.from && e < this.range.to)
      return e;
    for (let t of this.ranges)
      if (t.to > e)
        return Math.max(e, t.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsing—when looking forward—or even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(e) {
    let t = this.chunkOff + e, i, n;
    if (t >= 0 && t < this.chunk.length)
      i = this.pos + e, n = this.chunk.charCodeAt(t);
    else {
      let s = this.resolveOffset(e, 1);
      if (s == null)
        return -1;
      if (i = s, i >= this.chunk2Pos && i < this.chunk2Pos + this.chunk2.length)
        n = this.chunk2.charCodeAt(i - this.chunk2Pos);
      else {
        let o = this.rangeIndex, l = this.range;
        for (; l.to <= i; )
          l = this.ranges[++o];
        this.chunk2 = this.input.chunk(this.chunk2Pos = i), i + this.chunk2.length > l.to && (this.chunk2 = this.chunk2.slice(0, l.to - i)), n = this.chunk2.charCodeAt(0);
      }
    }
    return i >= this.token.lookAhead && (this.token.lookAhead = i + 1), n;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(e, t = 0) {
    let i = t ? this.resolveOffset(t, -1) : this.pos;
    if (i == null || i < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = e, this.token.end = i;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(e, t) {
    this.token.value = e, this.token.end = t;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: e, chunkPos: t } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = e, this.chunk2Pos = t, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let e = this.input.chunk(this.pos), t = this.pos + e.length;
      this.chunk = t > this.range.to ? e.slice(0, this.range.to - this.pos) : e, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(e = 1) {
    for (this.chunkOff += e; this.pos + e >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      e -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += e, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /**
  @internal
  */
  reset(e, t) {
    if (t ? (this.token = t, t.start = e, t.lookAhead = e + 1, t.value = t.extended = -1) : this.token = Vp, this.pos != e) {
      if (this.pos = e, e == this.end)
        return this.setDone(), this;
      for (; e < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; e >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      e >= this.chunkPos && e < this.chunkPos + this.chunk.length ? this.chunkOff = e - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(e, t) {
    if (e >= this.chunkPos && t <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(e - this.chunkPos, t - this.chunkPos);
    if (e >= this.chunk2Pos && t <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(e - this.chunk2Pos, t - this.chunk2Pos);
    if (e >= this.range.from && t <= this.range.to)
      return this.input.read(e, t);
    let i = "";
    for (let n of this.ranges) {
      if (n.from >= t)
        break;
      n.to > e && (i += this.input.read(Math.max(n.from, e), Math.min(n.to, t)));
    }
    return i;
  }
}
class Ei {
  constructor(e, t) {
    this.data = e, this.id = t;
  }
  token(e, t) {
    let { parser: i } = t.p;
    C0(this.data, e, t, this.id, i.data, i.tokenPrecTable);
  }
}
Ei.prototype.contextual = Ei.prototype.fallback = Ei.prototype.extend = !1;
class el {
  constructor(e, t, i) {
    this.precTable = t, this.elseToken = i, this.data = typeof e == "string" ? Xn(e) : e;
  }
  token(e, t) {
    let i = e.pos, n = 0;
    for (; ; ) {
      let s = e.next < 0, o = e.resolveOffset(1, 1);
      if (C0(this.data, e, t, 0, this.data, this.precTable), e.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (s || n++, o == null)
        break;
      e.reset(o, e.token);
    }
    n && (e.reset(i, e.token), e.acceptToken(this.elseToken, n));
  }
}
el.prototype.contextual = Ei.prototype.fallback = Ei.prototype.extend = !1;
class Ae {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(e, t = {}) {
    this.token = e, this.contextual = !!t.contextual, this.fallback = !!t.fallback, this.extend = !!t.extend;
  }
}
function C0(r, e, t, i, n, s) {
  let o = 0, l = 1 << i, { dialect: a } = t.p.parser;
  e:
    for (; l & r[o]; ) {
      let h = r[o + 1];
      for (let p = o + 3; p < h; p += 2)
        if ((r[p + 1] & l) > 0) {
          let f = r[p];
          if (a.allows(f) && (e.token.value == -1 || e.token.value == f || QP(f, e.token.value, n, s))) {
            e.acceptToken(f);
            break;
          }
        }
      let c = e.next, u = 0, d = r[o + 2];
      if (e.next < 0 && d > u && r[h + d * 3 - 3] == 65535) {
        o = r[h + d * 3 - 1];
        continue e;
      }
      for (; u < d; ) {
        let p = u + d >> 1, f = h + p + (p << 1), m = r[f], g = r[f + 1] || 65536;
        if (c < m)
          d = p;
        else if (c >= g)
          u = p + 1;
        else {
          o = r[f + 2], e.advance();
          continue e;
        }
      }
      break;
    }
}
function Mp(r, e, t) {
  for (let i = e, n; (n = r[i]) != 65535; i++)
    if (n == t)
      return i - e;
  return -1;
}
function QP(r, e, t, i) {
  let n = Mp(t, i, e);
  return n < 0 || Mp(t, i, r) < n;
}
const He = typeof process < "u" && process.env && /\bparse\b/.test(process.env.LOG);
let Oa = null;
function jp(r, e, t) {
  let i = r.cursor(ne.IncludeAnonymous);
  for (i.moveTo(e); ; )
    if (!(t < 0 ? i.childBefore(e) : i.childAfter(e)))
      for (; ; ) {
        if ((t < 0 ? i.to < e : i.from > e) && !i.type.isError)
          return t < 0 ? Math.max(0, Math.min(
            i.to - 1,
            e - 25
            /* Safety.Margin */
          )) : Math.min(r.length, Math.max(
            i.from + 1,
            e + 25
            /* Safety.Margin */
          ));
        if (t < 0 ? i.prevSibling() : i.nextSibling())
          break;
        if (!i.parent())
          return t < 0 ? 0 : r.length;
      }
}
let PP = class {
  constructor(e, t) {
    this.fragments = e, this.nodeSet = t, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let e = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (e) {
      for (this.safeFrom = e.openStart ? jp(e.tree, e.from + e.offset, 1) - e.offset : e.from, this.safeTo = e.openEnd ? jp(e.tree, e.to + e.offset, -1) - e.offset : e.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(e.tree), this.start.push(-e.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(e) {
    if (e < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= e; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let t = this.trees.length - 1;
      if (t < 0)
        return this.nextFragment(), null;
      let i = this.trees[t], n = this.index[t];
      if (n == i.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let s = i.children[n], o = this.start[t] + i.positions[n];
      if (o > e)
        return this.nextStart = o, null;
      if (s instanceof D) {
        if (o == e) {
          if (o < this.safeFrom)
            return null;
          let l = o + s.length;
          if (l <= this.safeTo) {
            let a = s.prop(Y.lookAhead);
            if (!a || l + a < this.fragment.to)
              return s;
          }
        }
        this.index[t]++, o + s.length >= Math.max(this.safeFrom, e) && (this.trees.push(s), this.start.push(o), this.index.push(0));
      } else
        this.index[t]++, this.nextStart = o + s.length;
    }
  }
};
class TP {
  constructor(e, t) {
    this.stream = t, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = e.tokenizers.map((i) => new yo());
  }
  getActions(e) {
    let t = 0, i = null, { parser: n } = e.p, { tokenizers: s } = n, o = n.stateSlot(
      e.state,
      3
      /* ParseState.TokenizerMask */
    ), l = e.curContext ? e.curContext.hash : 0, a = 0;
    for (let h = 0; h < s.length; h++) {
      if (!(1 << h & o))
        continue;
      let c = s[h], u = this.tokens[h];
      if (!(i && !c.fallback) && ((c.contextual || u.start != e.pos || u.mask != o || u.context != l) && (this.updateCachedToken(u, c, e), u.mask = o, u.context = l), u.lookAhead > u.end + 25 && (a = Math.max(u.lookAhead, a)), u.value != 0)) {
        let d = t;
        if (u.extended > -1 && (t = this.addActions(e, u.extended, u.end, t)), t = this.addActions(e, u.value, u.end, t), !c.extend && (i = u, t > d))
          break;
      }
    }
    for (; this.actions.length > t; )
      this.actions.pop();
    return a && e.setLookAhead(a), !i && e.pos == this.stream.end && (i = new yo(), i.value = e.p.parser.eofTerm, i.start = i.end = e.pos, t = this.addActions(e, i.value, i.end, t)), this.mainToken = i, this.actions;
  }
  getMainToken(e) {
    if (this.mainToken)
      return this.mainToken;
    let t = new yo(), { pos: i, p: n } = e;
    return t.start = i, t.end = Math.min(i + 1, n.stream.end), t.value = i == n.stream.end ? n.parser.eofTerm : 0, t;
  }
  updateCachedToken(e, t, i) {
    let n = this.stream.clipPos(i.pos);
    if (t.token(this.stream.reset(n, e), i), e.value > -1) {
      let { parser: s } = i.p;
      for (let o = 0; o < s.specialized.length; o++)
        if (s.specialized[o] == e.value) {
          let l = s.specializers[o](this.stream.read(e.start, e.end), i);
          if (l >= 0 && i.p.parser.dialect.allows(l >> 1)) {
            l & 1 ? e.extended = l >> 1 : e.value = l >> 1;
            break;
          }
        }
    } else
      e.value = 0, e.end = this.stream.clipPos(n + 1);
  }
  putAction(e, t, i, n) {
    for (let s = 0; s < n; s += 3)
      if (this.actions[s] == e)
        return n;
    return this.actions[n++] = e, this.actions[n++] = t, this.actions[n++] = i, n;
  }
  addActions(e, t, i, n) {
    let { state: s } = e, { parser: o } = e.p, { data: l } = o;
    for (let a = 0; a < 2; a++)
      for (let h = o.stateSlot(
        s,
        a ? 2 : 1
        /* ParseState.Actions */
      ); ; h += 3) {
        if (l[h] == 65535)
          if (l[h + 1] == 1)
            h = rr(l, h + 2);
          else {
            n == 0 && l[h + 1] == 2 && (n = this.putAction(rr(l, h + 2), t, i, n));
            break;
          }
        l[h] == t && (n = this.putAction(rr(l, h + 1), t, i, n));
      }
    return n;
  }
}
class CP {
  constructor(e, t, i, n) {
    this.parser = e, this.input = t, this.ranges = n, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new $P(t, n), this.tokens = new TP(e, this.stream), this.topTerm = e.top[1];
    let { from: s } = n[0];
    this.stacks = [Ko.start(this, e.top[0], s)], this.fragments = i.length && this.stream.end - s > e.bufferLength * 4 ? new PP(i, e.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let e = this.stacks, t = this.minStackPos, i = this.stacks = [], n, s;
    if (this.bigReductionCount > 300 && e.length == 1) {
      let [o] = e;
      for (; o.forceReduce() && o.stack.length && o.stack[o.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let o = 0; o < e.length; o++) {
      let l = e[o];
      for (; ; ) {
        if (this.tokens.mainToken = null, l.pos > t)
          i.push(l);
        else {
          if (this.advanceStack(l, i, e))
            continue;
          {
            n || (n = [], s = []), n.push(l);
            let a = this.tokens.getMainToken(l);
            s.push(a.value, a.end);
          }
        }
        break;
      }
    }
    if (!i.length) {
      let o = n && ZP(n);
      if (o)
        return He && console.log("Finish with " + this.stackID(o)), this.stackToTree(o);
      if (this.parser.strict)
        throw He && n && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + t);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && n) {
      let o = this.stoppedAt != null && n[0].pos > this.stoppedAt ? n[0] : this.runRecovery(n, s, i);
      if (o)
        return He && console.log("Force-finish " + this.stackID(o)), this.stackToTree(o.forceAll());
    }
    if (this.recovering) {
      let o = this.recovering == 1 ? 1 : this.recovering * 3;
      if (i.length > o)
        for (i.sort((l, a) => a.score - l.score); i.length > o; )
          i.pop();
      i.some((l) => l.reducePos > t) && this.recovering--;
    } else if (i.length > 1) {
      e:
        for (let o = 0; o < i.length - 1; o++) {
          let l = i[o];
          for (let a = o + 1; a < i.length; a++) {
            let h = i[a];
            if (l.sameState(h) || l.buffer.length > 500 && h.buffer.length > 500)
              if ((l.score - h.score || l.buffer.length - h.buffer.length) > 0)
                i.splice(a--, 1);
              else {
                i.splice(o--, 1);
                continue e;
              }
          }
        }
      i.length > 12 && i.splice(
        12,
        i.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = i[0].pos;
    for (let o = 1; o < i.length; o++)
      i[o].pos < this.minStackPos && (this.minStackPos = i[o].pos);
    return null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(e, t, i) {
    let n = e.pos, { parser: s } = this, o = He ? this.stackID(e) + " -> " : "";
    if (this.stoppedAt != null && n > this.stoppedAt)
      return e.forceReduce() ? e : null;
    if (this.fragments) {
      let h = e.curContext && e.curContext.tracker.strict, c = h ? e.curContext.hash : 0;
      for (let u = this.fragments.nodeAt(n); u; ) {
        let d = this.parser.nodeSet.types[u.type.id] == u.type ? s.getGoto(e.state, u.type.id) : -1;
        if (d > -1 && u.length && (!h || (u.prop(Y.contextHash) || 0) == c))
          return e.useNode(u, d), He && console.log(o + this.stackID(e) + ` (via reuse of ${s.getName(u.type.id)})`), !0;
        if (!(u instanceof D) || u.children.length == 0 || u.positions[0] > 0)
          break;
        let p = u.children[0];
        if (p instanceof D && u.positions[0] == 0)
          u = p;
        else
          break;
      }
    }
    let l = s.stateSlot(
      e.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (l > 0)
      return e.reduce(l), He && console.log(o + this.stackID(e) + ` (via always-reduce ${s.getName(
        l & 65535
        /* Action.ValueMask */
      )})`), !0;
    if (e.stack.length >= 8400)
      for (; e.stack.length > 6e3 && e.forceReduce(); )
        ;
    let a = this.tokens.getActions(e);
    for (let h = 0; h < a.length; ) {
      let c = a[h++], u = a[h++], d = a[h++], p = h == a.length || !i, f = p ? e : e.split(), m = this.tokens.mainToken;
      if (f.apply(c, u, m ? m.start : f.pos, d), He && console.log(o + this.stackID(f) + ` (via ${c & 65536 ? `reduce of ${s.getName(
        c & 65535
        /* Action.ValueMask */
      )}` : "shift"} for ${s.getName(u)} @ ${n}${f == e ? "" : ", split"})`), p)
        return !0;
      f.pos > n ? t.push(f) : i.push(f);
    }
    return !1;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(e, t) {
    let i = e.pos;
    for (; ; ) {
      if (!this.advanceStack(e, null, null))
        return !1;
      if (e.pos > i)
        return Lp(e, t), !0;
    }
  }
  runRecovery(e, t, i) {
    let n = null, s = !1;
    for (let o = 0; o < e.length; o++) {
      let l = e[o], a = t[o << 1], h = t[(o << 1) + 1], c = He ? this.stackID(l) + " -> " : "";
      if (l.deadEnd && (s || (s = !0, l.restart(), He && console.log(c + this.stackID(l) + " (restarted)"), this.advanceFully(l, i))))
        continue;
      let u = l.split(), d = c;
      for (let p = 0; u.forceReduce() && p < 10 && (He && console.log(d + this.stackID(u) + " (via force-reduce)"), !this.advanceFully(u, i)); p++)
        He && (d = this.stackID(u) + " -> ");
      for (let p of l.recoverByInsert(a))
        He && console.log(c + this.stackID(p) + " (via recover-insert)"), this.advanceFully(p, i);
      this.stream.end > l.pos ? (h == l.pos && (h++, a = 0), l.recoverByDelete(a, h), He && console.log(c + this.stackID(l) + ` (via recover-delete ${this.parser.getName(a)})`), Lp(l, i)) : (!n || n.score < l.score) && (n = l);
    }
    return n;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(e) {
    return e.close(), D.build({
      buffer: Jo.create(e),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: e.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(e) {
    let t = (Oa || (Oa = /* @__PURE__ */ new WeakMap())).get(e);
    return t || Oa.set(e, t = String.fromCodePoint(this.nextStackID++)), t + e;
  }
}
function Lp(r, e) {
  for (let t = 0; t < e.length; t++) {
    let i = e[t];
    if (i.pos == r.pos && i.sameState(r)) {
      e[t].score < r.score && (e[t] = r);
      return;
    }
  }
  e.push(r);
}
class XP {
  constructor(e, t, i) {
    this.source = e, this.flags = t, this.disabled = i;
  }
  allows(e) {
    return !this.disabled || this.disabled[e] == 0;
  }
}
const ma = (r) => r;
class Kc {
  /**
  Define a context tracker.
  */
  constructor(e) {
    this.start = e.start, this.shift = e.shift || ma, this.reduce = e.reduce || ma, this.reuse = e.reuse || ma, this.hash = e.hash || (() => 0), this.strict = e.strict !== !1;
  }
}
class Ft extends ml {
  /**
  @internal
  */
  constructor(e) {
    if (super(), this.wrappers = [], e.version != 14)
      throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (14)`);
    let t = e.nodeNames.split(" ");
    this.minRepeatTerm = t.length;
    for (let l = 0; l < e.repeatNodeCount; l++)
      t.push("");
    let i = Object.keys(e.topRules).map((l) => e.topRules[l][1]), n = [];
    for (let l = 0; l < t.length; l++)
      n.push([]);
    function s(l, a, h) {
      n[l].push([a, a.deserialize(String(h))]);
    }
    if (e.nodeProps)
      for (let l of e.nodeProps) {
        let a = l[0];
        typeof a == "string" && (a = Y[a]);
        for (let h = 1; h < l.length; ) {
          let c = l[h++];
          if (c >= 0)
            s(c, a, l[h++]);
          else {
            let u = l[h + -c];
            for (let d = -c; d > 0; d--)
              s(l[h++], a, u);
            h++;
          }
        }
      }
    this.nodeSet = new rn(t.map((l, a) => ye.define({
      name: a >= this.minRepeatTerm ? void 0 : l,
      id: a,
      props: n[a],
      top: i.indexOf(a) > -1,
      error: a == 0,
      skipped: e.skippedNodes && e.skippedNodes.indexOf(a) > -1
    }))), e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)), this.strict = !1, this.bufferLength = Wm;
    let o = Xn(e.tokenData);
    this.context = e.context, this.specializerSpecs = e.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let l = 0; l < this.specializerSpecs.length; l++)
      this.specialized[l] = this.specializerSpecs[l].term;
    this.specializers = this.specializerSpecs.map(Bp), this.states = Xn(e.states, Uint32Array), this.data = Xn(e.stateData), this.goto = Xn(e.goto), this.maxTerm = e.maxTerm, this.tokenizers = e.tokenizers.map((l) => typeof l == "number" ? new Ei(o, l) : l), this.topRules = e.topRules, this.dialects = e.dialects || {}, this.dynamicPrecedences = e.dynamicPrecedences || null, this.tokenPrecTable = e.tokenPrec, this.termNames = e.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(e, t, i) {
    let n = new CP(this, e, t, i);
    for (let s of this.wrappers)
      n = s(n, e, t, i);
    return n;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(e, t, i = !1) {
    let n = this.goto;
    if (t >= n[0])
      return -1;
    for (let s = n[t + 1]; ; ) {
      let o = n[s++], l = o & 1, a = n[s++];
      if (l && i)
        return a;
      for (let h = s + (o >> 1); s < h; s++)
        if (n[s] == e)
          return a;
      if (l)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(e, t) {
    let i = this.data;
    for (let n = 0; n < 2; n++)
      for (let s = this.stateSlot(
        e,
        n ? 2 : 1
        /* ParseState.Actions */
      ), o; ; s += 3) {
        if ((o = i[s]) == 65535)
          if (i[s + 1] == 1)
            o = i[s = rr(i, s + 2)];
          else {
            if (i[s + 1] == 2)
              return rr(i, s + 2);
            break;
          }
        if (o == t || o == 0)
          return rr(i, s + 1);
      }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(e, t) {
    return this.states[e * 6 + t];
  }
  /**
  @internal
  */
  stateFlag(e, t) {
    return (this.stateSlot(
      e,
      0
      /* ParseState.Flags */
    ) & t) > 0;
  }
  /**
  @internal
  */
  validAction(e, t) {
    return !!this.allActions(e, (i) => i == t ? !0 : null);
  }
  /**
  @internal
  */
  allActions(e, t) {
    let i = this.stateSlot(
      e,
      4
      /* ParseState.DefaultReduce */
    ), n = i ? t(i) : void 0;
    for (let s = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); n == null; s += 3) {
      if (this.data[s] == 65535)
        if (this.data[s + 1] == 1)
          s = rr(this.data, s + 2);
        else
          break;
      n = t(rr(this.data, s + 1));
    }
    return n;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(e) {
    let t = [];
    for (let i = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); ; i += 3) {
      if (this.data[i] == 65535)
        if (this.data[i + 1] == 1)
          i = rr(this.data, i + 2);
        else
          break;
      if (!(this.data[i + 2] & 1)) {
        let n = this.data[i + 1];
        t.some((s, o) => o & 1 && s == n) || t.push(this.data[i], n);
      }
    }
    return t;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(e) {
    let t = Object.assign(Object.create(Ft.prototype), this);
    if (e.props && (t.nodeSet = this.nodeSet.extend(...e.props)), e.top) {
      let i = this.topRules[e.top];
      if (!i)
        throw new RangeError(`Invalid top rule name ${e.top}`);
      t.top = i;
    }
    return e.tokenizers && (t.tokenizers = this.tokenizers.map((i) => {
      let n = e.tokenizers.find((s) => s.from == i);
      return n ? n.to : i;
    })), e.specializers && (t.specializers = this.specializers.slice(), t.specializerSpecs = this.specializerSpecs.map((i, n) => {
      let s = e.specializers.find((l) => l.from == i.external);
      if (!s)
        return i;
      let o = Object.assign(Object.assign({}, i), { external: s.to });
      return t.specializers[n] = Bp(o), o;
    })), e.contextTracker && (t.context = e.contextTracker), e.dialect && (t.dialect = this.parseDialect(e.dialect)), e.strict != null && (t.strict = e.strict), e.wrap && (t.wrappers = t.wrappers.concat(e.wrap)), e.bufferLength != null && (t.bufferLength = e.bufferLength), t;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(e) {
    return this.termNames ? this.termNames[e] : String(e <= this.maxNode && this.nodeSet.types[e].name || e);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(e) {
    let t = this.dynamicPrecedences;
    return t == null ? 0 : t[e] || 0;
  }
  /**
  @internal
  */
  parseDialect(e) {
    let t = Object.keys(this.dialects), i = t.map(() => !1);
    if (e)
      for (let s of e.split(" ")) {
        let o = t.indexOf(s);
        o >= 0 && (i[o] = !0);
      }
    let n = null;
    for (let s = 0; s < t.length; s++)
      if (!i[s])
        for (let o = this.dialects[t[s]], l; (l = this.data[o++]) != 65535; )
          (n || (n = new Uint8Array(this.maxTerm + 1)))[l] = 1;
    return new XP(e, i, n);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(e) {
    return new Ft(e);
  }
}
function rr(r, e) {
  return r[e] | r[e + 1] << 16;
}
function ZP(r) {
  let e = null;
  for (let t of r) {
    let i = t.p.stoppedAt;
    (t.pos == t.p.stream.end || i != null && t.pos > i) && t.p.parser.stateFlag(
      t.state,
      2
      /* StateFlag.Accepting */
    ) && (!e || e.score < t.score) && (e = t);
  }
  return e;
}
function Bp(r) {
  if (r.external) {
    let e = r.extend ? 1 : 0;
    return (t, i) => r.external(t, i) << 1 | e;
  }
  return r.get;
}
const _P = 99, Dp = 1, RP = 100, AP = 101, Ip = 2, X0 = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], EP = 58, qP = 40, Z0 = 95, zP = 91, vo = 45, YP = 46, WP = 35, VP = 37, MP = 38, jP = 92, LP = 10;
function as(r) {
  return r >= 65 && r <= 90 || r >= 97 && r <= 122 || r >= 161;
}
function BP(r) {
  return r >= 48 && r <= 57;
}
const DP = new Ae((r, e) => {
  for (let t = !1, i = 0, n = 0; ; n++) {
    let { next: s } = r;
    if (as(s) || s == vo || s == Z0 || t && BP(s))
      !t && (s != vo || n > 0) && (t = !0), i === n && s == vo && i++, r.advance();
    else if (s == jP && r.peek(1) != LP)
      r.advance(), r.next > -1 && r.advance(), t = !0;
    else {
      t && r.acceptToken(s == qP ? RP : i == 2 && e.canShift(Ip) ? Ip : AP);
      break;
    }
  }
}), IP = new Ae((r) => {
  if (X0.includes(r.peek(-1))) {
    let { next: e } = r;
    (as(e) || e == Z0 || e == WP || e == YP || e == zP || e == EP && as(r.peek(1)) || e == vo || e == MP) && r.acceptToken(_P);
  }
}), UP = new Ae((r) => {
  if (!X0.includes(r.peek(-1))) {
    let { next: e } = r;
    if (e == VP && (r.advance(), r.acceptToken(Dp)), as(e)) {
      do
        r.advance();
      while (as(r.next));
      r.acceptToken(Dp);
    }
  }
}), GP = Jt({
  "AtKeyword import charset namespace keyframes media supports": O.definitionKeyword,
  "from to selector": O.keyword,
  NamespaceName: O.namespace,
  KeyframeName: O.labelName,
  KeyframeRangeName: O.operatorKeyword,
  TagName: O.tagName,
  ClassName: O.className,
  PseudoClassName: O.constant(O.className),
  IdName: O.labelName,
  "FeatureName PropertyName": O.propertyName,
  AttributeName: O.attributeName,
  NumberLiteral: O.number,
  KeywordQuery: O.keyword,
  UnaryQueryOp: O.operatorKeyword,
  "CallTag ValueName": O.atom,
  VariableName: O.variableName,
  Callee: O.operatorKeyword,
  Unit: O.unit,
  "UniversalSelector NestingSelector": O.definitionOperator,
  MatchOp: O.compareOperator,
  "ChildOp SiblingOp, LogicOp": O.logicOperator,
  BinOp: O.arithmeticOperator,
  Important: O.modifier,
  Comment: O.blockComment,
  ColorLiteral: O.color,
  "ParenthesizedContent StringLiteral": O.string,
  ":": O.punctuation,
  "PseudoOp #": O.derefOperator,
  "; ,": O.separator,
  "( )": O.paren,
  "[ ]": O.squareBracket,
  "{ }": O.brace
}), NP = { __proto__: null, lang: 32, "nth-child": 32, "nth-last-child": 32, "nth-of-type": 32, "nth-last-of-type": 32, dir: 32, "host-context": 32, url: 60, "url-prefix": 60, domain: 60, regexp: 60, selector: 138 }, FP = { __proto__: null, "@import": 118, "@media": 142, "@charset": 146, "@namespace": 150, "@keyframes": 156, "@supports": 168 }, HP = { __proto__: null, not: 132, only: 132 }, KP = Ft.deserialize({
  version: 14,
  states: ":^QYQ[OOO#_Q[OOP#fOWOOOOQP'#Cd'#CdOOQP'#Cc'#CcO#kQ[O'#CfO$_QXO'#CaO$fQ[O'#ChO$qQ[O'#DTO$vQ[O'#DWOOQP'#Em'#EmO${QdO'#DgO%jQ[O'#DtO${QdO'#DvO%{Q[O'#DxO&WQ[O'#D{O&`Q[O'#ERO&nQ[O'#ETOOQS'#El'#ElOOQS'#EW'#EWQYQ[OOO&uQXO'#CdO'jQWO'#DcO'oQWO'#EsO'zQ[O'#EsQOQWOOP(UO#tO'#C_POOO)C@[)C@[OOQP'#Cg'#CgOOQP,59Q,59QO#kQ[O,59QO(aQ[O'#E[O({QWO,58{O)TQ[O,59SO$qQ[O,59oO$vQ[O,59rO(aQ[O,59uO(aQ[O,59wO(aQ[O,59xO)`Q[O'#DbOOQS,58{,58{OOQP'#Ck'#CkOOQO'#DR'#DROOQP,59S,59SO)gQWO,59SO)lQWO,59SOOQP'#DV'#DVOOQP,59o,59oOOQO'#DX'#DXO)qQ`O,59rOOQS'#Cp'#CpO${QdO'#CqO)yQvO'#CsO+ZQtO,5:ROOQO'#Cx'#CxO)lQWO'#CwO+oQWO'#CyO+tQ[O'#DOOOQS'#Ep'#EpOOQO'#Dj'#DjO+|Q[O'#DqO,[QWO'#EtO&`Q[O'#DoO,jQWO'#DrOOQO'#Eu'#EuO)OQWO,5:`O,oQpO,5:bOOQS'#Dz'#DzO,wQWO,5:dO,|Q[O,5:dOOQO'#D}'#D}O-UQWO,5:gO-ZQWO,5:mO-cQWO,5:oOOQS-E8U-E8UO${QdO,59}O-kQ[O'#E^O-xQWO,5;_O-xQWO,5;_POOO'#EV'#EVP.TO#tO,58yPOOO,58y,58yOOQP1G.l1G.lO.zQXO,5:vOOQO-E8Y-E8YOOQS1G.g1G.gOOQP1G.n1G.nO)gQWO1G.nO)lQWO1G.nOOQP1G/Z1G/ZO/XQ`O1G/^O/rQXO1G/aO0YQXO1G/cO0pQXO1G/dO1WQWO,59|O1]Q[O'#DSO1dQdO'#CoOOQP1G/^1G/^O${QdO1G/^O1kQpO,59]OOQS,59_,59_O${QdO,59aO1sQWO1G/mOOQS,59c,59cO1xQ!bO,59eOOQS'#DP'#DPOOQS'#EY'#EYO2QQ[O,59jOOQS,59j,59jO2YQWO'#DjO2eQWO,5:VO2jQWO,5:]O&`Q[O,5:XO&`Q[O'#E_O2rQWO,5;`O2}QWO,5:ZO(aQ[O,5:^OOQS1G/z1G/zOOQS1G/|1G/|OOQS1G0O1G0OO3`QWO1G0OO3eQdO'#EOOOQS1G0R1G0ROOQS1G0X1G0XOOQS1G0Z1G0ZO3pQtO1G/iOOQO,5:x,5:xO4WQ[O,5:xOOQO-E8[-E8[O4eQWO1G0yPOOO-E8T-E8TPOOO1G.e1G.eOOQP7+$Y7+$YOOQP7+$x7+$xO${QdO7+$xOOQS1G/h1G/hO4pQXO'#ErO4wQWO,59nO4|QtO'#EXO5tQdO'#EoO6OQWO,59ZO6TQpO7+$xOOQS1G.w1G.wOOQS1G.{1G.{OOQS7+%X7+%XO6]QWO1G/POOQS-E8W-E8WOOQS1G/U1G/UO${QdO1G/qOOQO1G/w1G/wOOQO1G/s1G/sO6bQWO,5:yOOQO-E8]-E8]O6pQXO1G/xOOQS7+%j7+%jO6wQYO'#CsOOQO'#EQ'#EQO7SQ`O'#EPOOQO'#EP'#EPO7_QWO'#E`O7gQdO,5:jOOQS,5:j,5:jO7rQtO'#E]O${QdO'#E]O8sQdO7+%TOOQO7+%T7+%TOOQO1G0d1G0dO9WQpO<<HdO9`QWO,5;^OOQP1G/Y1G/YOOQS-E8V-E8VO${QdO'#EZO9hQWO,5;ZOOQT1G.u1G.uOOQP<<Hd<<HdOOQS7+$k7+$kO9pQdO7+%]OOQO7+%d7+%dOOQO,5:k,5:kO3hQdO'#EaO7_QWO,5:zOOQS,5:z,5:zOOQS-E8^-E8^OOQS1G0U1G0UO9wQtO,5:wOOQS-E8Z-E8ZOOQO<<Ho<<HoOOQPAN>OAN>OO:xQdO,5:uOOQO-E8X-E8XOOQO<<Hw<<HwOOQO,5:{,5:{OOQO-E8_-E8_OOQS1G0f1G0f",
  stateData: ";[~O#ZOS#[QQ~OUYOXYO]VO^VOqXOxWO![aO!]ZO!i[O!k]O!m^O!p_O!v`O#XRO#bTO~OQfOUYOXYO]VO^VOqXOxWO![aO!]ZO!i[O!k]O!m^O!p_O!v`O#XeO#bTO~O#U#gP~P!ZO#[jO~O#XlO~O]qO^qOqsOtoOxrO!OtO!RvO#VuO#bnO~O!TwO~P#pO`}O#WzO#XyO~O#X!OO~O#X!QO~OQ![Ob!TOf![Oh![On!YOq!ZO#W!WO#X!SO#e!UO~Ob!^O!d!`O!g!aO#X!]O!T#hP~Oh!fOn!YO#X!eO~Oh!hO#X!hO~Ob!^O!d!`O!g!aO#X!]O~O!Y#hP~P%jO]WX]!WX^WXqWXtWXxWX!OWX!RWX!TWX#VWX#bWX~O]!mO~O!Y!nO#U#gX!S#gX~O#U#gX!S#gX~P!ZO#]!qO#^!qO#_!sO~OUYOXYO]VO^VOqXOxWO#XRO#bTO~OtoO!TwO~O`!zO#WzO#XyO~O!S#gP~P!ZOb#RO~Ob#SO~Op#TO|#UO~OP#WObgXjgX!YgX!dgX!ggX#XgXagXQgXfgXhgXngXqgXtgX!XgX#UgX#WgX#egXpgX!SgX~Ob!^Oj#XO!d!`O!g!aO#X!]O!Y#hP~Ob#[O~Op#`O#X#]O~Ob!^O!d!`O!g!aO#X#aO~Ot#eO!b#dO!T#hX!Y#hX~Ob#hO~Oj#XO!Y#jO~O!Y#kO~Oh#lOn!YO~O!T#mO~O!TwO!b#dO~O!TwO!Y#pO~O!Y#QX#U#QX!S#QX~P!ZO!Y!nO#U#ga!S#ga~O#]!qO#^!qO#_#wO~O]qO^qOqsOxrO!OtO!RvO#VuO#bnO~Ot#Oa!T#Oaa#Oa~P.`Op#yO|#zO~O]qO^qOqsOxrO#bnO~Ot}i!O}i!R}i!T}i#V}ia}i~P/aOt!Pi!O!Pi!R!Pi!T!Pi#V!Pia!Pi~P/aOt!Qi!O!Qi!R!Qi!T!Qi#V!Qia!Qi~P/aO!S#{O~Oa#fP~P(aOa#cP~P${Oa$SOj#XO~O!Y$UO~Oh$VOo$VO~Op$XO#X#]O~O]!`Xa!^X!b!^X~O]$YO~Oa$ZO!b#dO~Ot#eO!T#ha!Y#ha~O!b#dOt!ca!T!ca!Y!caa!ca~O!Y$`O~O!S$gO#X$bO#e$aO~Oj#XOt$iO!X$kO!Y!Vi#U!Vi!S!Vi~P${O!Y#Qa#U#Qa!S#Qa~P!ZO!Y!nO#U#gi!S#gi~Oa#fX~P#pOa$oO~Oj#XOQ!{Xa!{Xb!{Xf!{Xh!{Xn!{Xq!{Xt!{X#W!{X#X!{X#e!{X~Ot$qOa#cX~P${Oa$sO~Oj#XOp$tO~Oa$uO~O!b#dOt#Ra!T#Ra!Y#Ra~Oa$wO~P.`OP#WOtgX!TgX~O#e$aOt!sX!T!sX~Ot$yO!TwO~O!S$}O#X$bO#e$aO~Oj#XOQ#PXb#PXf#PXh#PXn#PXq#PXt#PX!X#PX!Y#PX#U#PX#W#PX#X#PX#e#PX!S#PX~Ot$iO!X%QO!Y!Vq#U!Vq!S!Vq~P${Oj#XOp%RO~OtoOa#fa~Ot$qOa#ca~Oa%UO~P${Oj#XOQ#Pab#Paf#Pah#Pan#Paq#Pat#Pa!X#Pa!Y#Pa#U#Pa#W#Pa#X#Pa#e#Pa!S#Pa~Oa!}at!}a~P${O#Zo#[#ej!R#e~",
  goto: "-g#jPPP#kP#nP#w$WP#w$g#wPP$mPPP$s$|$|P%`P$|P$|%z&^PPPP$|&vP&z'Q#wP'W#w'^P#wP#w#wPPP'd'y(WPP#nPP(_(_(i(_P(_P(_(_P#nP#nP#nP(l#nP(o(r(u(|#nP#nP)R)X)h)v)|*S*^*d*n*t*zPPPPPPPPPP+Q+ZP+v+yP,o,r,x-RRkQ_bOPdhw!n#skYOPdhotuvw!n#R#h#skSOPdhotuvw!n#R#h#sQmTR!tnQ{VR!xqQ!x}Q#Z!XR#x!zq![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%Sp![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%SU$d#m$f$yR$x$cq!XZ]!T!m#S#U#X#q#z$P$Y$i$j$q$v%Sp![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%SQ!f^R#l!gT#^!Z#_Q|VR!yqQ!x|R#x!yQ!PWR!{rQ!RXR!|sQxUQ!wpQ#i!cQ#o!jQ#p!kQ${$eR%X$zSgPwQ!phQ#r!nR$l#sZfPhw!n#sa!b[`a!V!^!`#d#eR#b!^R!g^R!i_R#n!iS$e#m$fR%V$yV$c#m$f$yQ!rjR#v!rQdOShPwU!ldh#sR#s!nQ$P#SU$p$P$v%SQ$v$YR%S$qQ#_!ZR$W#_Q$r$PR%T$rQpUS!vp$nR$n#|Q$j#qR%P$jQ!ogS#t!o#uR#u!pQ#f!_R$^#fQ$f#mR$|$fQ$z$eR%W$z_cOPdhw!n#s^UOPdhw!n#sQ!uoQ!}tQ#OuQ#PvQ#|#RR$_#hR$Q#SQ!VZQ!d]Q#V!TQ#q!m[$O#S$P$Y$q$v%SQ$R#UQ$T#XS$h#q$jQ$m#zR%O$iR#}#RQiPR#QwQ!c[Q!kaR#Y!VU!_[a!VQ!j`Q#c!^Q#g!`Q$[#dR$]#e",
  nodeNames: "⚠ Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent ] [ LineNames LineName , PseudoClassName ArgList IdSelector # IdName AttributeSelector AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports AtRule Styles",
  maxTerm: 117,
  nodeProps: [
    ["isolate", -2, 3, 24, ""],
    ["openedBy", 17, "(", 32, "[", 50, "{"],
    ["closedBy", 18, ")", 33, "]", 51, "}"]
  ],
  propSources: [GP],
  skippedNodes: [0, 3, 87],
  repeatNodeCount: 11,
  tokenData: "J^~R!^OX$}X^%u^p$}pq%uqr)Xrs.Rst/utu6duv$}vw7^wx7oxy9^yz9oz{9t{|:_|}?Q}!O?c!O!P@Q!P!Q@i!Q![Ab![!]B]!]!^CX!^!_$}!_!`Cj!`!aC{!a!b$}!b!cDw!c!}$}!}#OFa#O#P$}#P#QFr#Q#R6d#R#T$}#T#UGT#U#c$}#c#dHf#d#o$}#o#pH{#p#q6d#q#rI^#r#sIo#s#y$}#y#z%u#z$f$}$f$g%u$g#BY$}#BY#BZ%u#BZ$IS$}$IS$I_%u$I_$I|$}$I|$JO%u$JO$JT$}$JT$JU%u$JU$KV$}$KV$KW%u$KW&FU$}&FU&FV%u&FV;'S$};'S;=`JW<%lO$}`%QSOy%^z;'S%^;'S;=`%o<%lO%^`%cSo`Oy%^z;'S%^;'S;=`%o<%lO%^`%rP;=`<%l%^~%zh#Z~OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^~'mh#Z~o`OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^l)[UOy%^z#]%^#]#^)n#^;'S%^;'S;=`%o<%lO%^l)sUo`Oy%^z#a%^#a#b*V#b;'S%^;'S;=`%o<%lO%^l*[Uo`Oy%^z#d%^#d#e*n#e;'S%^;'S;=`%o<%lO%^l*sUo`Oy%^z#c%^#c#d+V#d;'S%^;'S;=`%o<%lO%^l+[Uo`Oy%^z#f%^#f#g+n#g;'S%^;'S;=`%o<%lO%^l+sUo`Oy%^z#h%^#h#i,V#i;'S%^;'S;=`%o<%lO%^l,[Uo`Oy%^z#T%^#T#U,n#U;'S%^;'S;=`%o<%lO%^l,sUo`Oy%^z#b%^#b#c-V#c;'S%^;'S;=`%o<%lO%^l-[Uo`Oy%^z#h%^#h#i-n#i;'S%^;'S;=`%o<%lO%^l-uS!X[o`Oy%^z;'S%^;'S;=`%o<%lO%^~.UWOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o<%lO.R~.sOh~~.vRO;'S.R;'S;=`/P;=`O.R~/SXOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o;=`<%l.R<%lO.R~/rP;=`<%l.Rn/zYxQOy%^z!Q%^!Q![0j![!c%^!c!i0j!i#T%^#T#Z0j#Z;'S%^;'S;=`%o<%lO%^l0oYo`Oy%^z!Q%^!Q![1_![!c%^!c!i1_!i#T%^#T#Z1_#Z;'S%^;'S;=`%o<%lO%^l1dYo`Oy%^z!Q%^!Q![2S![!c%^!c!i2S!i#T%^#T#Z2S#Z;'S%^;'S;=`%o<%lO%^l2ZYf[o`Oy%^z!Q%^!Q![2y![!c%^!c!i2y!i#T%^#T#Z2y#Z;'S%^;'S;=`%o<%lO%^l3QYf[o`Oy%^z!Q%^!Q![3p![!c%^!c!i3p!i#T%^#T#Z3p#Z;'S%^;'S;=`%o<%lO%^l3uYo`Oy%^z!Q%^!Q![4e![!c%^!c!i4e!i#T%^#T#Z4e#Z;'S%^;'S;=`%o<%lO%^l4lYf[o`Oy%^z!Q%^!Q![5[![!c%^!c!i5[!i#T%^#T#Z5[#Z;'S%^;'S;=`%o<%lO%^l5aYo`Oy%^z!Q%^!Q![6P![!c%^!c!i6P!i#T%^#T#Z6P#Z;'S%^;'S;=`%o<%lO%^l6WSf[o`Oy%^z;'S%^;'S;=`%o<%lO%^d6gUOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^d7QS|So`Oy%^z;'S%^;'S;=`%o<%lO%^b7cSXQOy%^z;'S%^;'S;=`%o<%lO%^~7rWOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W<%lO7o~8_RO;'S7o;'S;=`8h;=`O7o~8kXOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W;=`<%l7o<%lO7o~9ZP;=`<%l7on9cSb^Oy%^z;'S%^;'S;=`%o<%lO%^~9tOa~n9{UUQjWOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^n:fWjW!RQOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^l;TUo`Oy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^l;nYo`#e[Oy%^z!Q%^!Q![;g![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^l<cYo`Oy%^z{%^{|=R|}%^}!O=R!O!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=WUo`Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=qUo`#e[Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l>[[o`#e[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^n?VSt^Oy%^z;'S%^;'S;=`%o<%lO%^l?hWjWOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^n@VU#bQOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^~@nTjWOy%^z{@}{;'S%^;'S;=`%o<%lO%^~AUSo`#[~Oy%^z;'S%^;'S;=`%o<%lO%^lAg[#e[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^bBbU]QOy%^z![%^![!]Bt!];'S%^;'S;=`%o<%lO%^bB{S^Qo`Oy%^z;'S%^;'S;=`%o<%lO%^nC^S!Y^Oy%^z;'S%^;'S;=`%o<%lO%^dCoS|SOy%^z;'S%^;'S;=`%o<%lO%^bDQU!OQOy%^z!`%^!`!aDd!a;'S%^;'S;=`%o<%lO%^bDkS!OQo`Oy%^z;'S%^;'S;=`%o<%lO%^bDzWOy%^z!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^bEk[![Qo`Oy%^z}%^}!OEd!O!Q%^!Q![Ed![!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^nFfSq^Oy%^z;'S%^;'S;=`%o<%lO%^nFwSp^Oy%^z;'S%^;'S;=`%o<%lO%^bGWUOy%^z#b%^#b#cGj#c;'S%^;'S;=`%o<%lO%^bGoUo`Oy%^z#W%^#W#XHR#X;'S%^;'S;=`%o<%lO%^bHYS!bQo`Oy%^z;'S%^;'S;=`%o<%lO%^bHiUOy%^z#f%^#f#gHR#g;'S%^;'S;=`%o<%lO%^fIQS!TUOy%^z;'S%^;'S;=`%o<%lO%^nIcS!S^Oy%^z;'S%^;'S;=`%o<%lO%^fItU!RQOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^`JZP;=`<%l$}",
  tokenizers: [IP, UP, DP, 1, 2, 3, 4, new el("m~RRYZ[z{a~~g~aO#^~~dP!P!Qg~lO#_~~", 28, 105)],
  topRules: { StyleSheet: [0, 4], Styles: [1, 86] },
  specialized: [{ term: 100, get: (r) => NP[r] || -1 }, { term: 58, get: (r) => FP[r] || -1 }, { term: 101, get: (r) => HP[r] || -1 }],
  tokenPrec: 1200
});
let ga = null;
function ba() {
  if (!ga && typeof document == "object" && document.body) {
    let { style: r } = document.body, e = [], t = /* @__PURE__ */ new Set();
    for (let i in r)
      i != "cssText" && i != "cssFloat" && typeof r[i] == "string" && (/[A-Z]/.test(i) && (i = i.replace(/[A-Z]/g, (n) => "-" + n.toLowerCase())), t.has(i) || (e.push(i), t.add(i)));
    ga = e.sort().map((i) => ({ type: "property", label: i }));
  }
  return ga || [];
}
const Up = /* @__PURE__ */ [
  "active",
  "after",
  "any-link",
  "autofill",
  "backdrop",
  "before",
  "checked",
  "cue",
  "default",
  "defined",
  "disabled",
  "empty",
  "enabled",
  "file-selector-button",
  "first",
  "first-child",
  "first-letter",
  "first-line",
  "first-of-type",
  "focus",
  "focus-visible",
  "focus-within",
  "fullscreen",
  "has",
  "host",
  "host-context",
  "hover",
  "in-range",
  "indeterminate",
  "invalid",
  "is",
  "lang",
  "last-child",
  "last-of-type",
  "left",
  "link",
  "marker",
  "modal",
  "not",
  "nth-child",
  "nth-last-child",
  "nth-last-of-type",
  "nth-of-type",
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "part",
  "placeholder",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "selection",
  "slotted",
  "target",
  "target-text",
  "valid",
  "visited",
  "where"
].map((r) => ({ type: "class", label: r })), Gp = /* @__PURE__ */ [
  "above",
  "absolute",
  "activeborder",
  "additive",
  "activecaption",
  "after-white-space",
  "ahead",
  "alias",
  "all",
  "all-scroll",
  "alphabetic",
  "alternate",
  "always",
  "antialiased",
  "appworkspace",
  "asterisks",
  "attr",
  "auto",
  "auto-flow",
  "avoid",
  "avoid-column",
  "avoid-page",
  "avoid-region",
  "axis-pan",
  "background",
  "backwards",
  "baseline",
  "below",
  "bidi-override",
  "blink",
  "block",
  "block-axis",
  "bold",
  "bolder",
  "border",
  "border-box",
  "both",
  "bottom",
  "break",
  "break-all",
  "break-word",
  "bullets",
  "button",
  "button-bevel",
  "buttonface",
  "buttonhighlight",
  "buttonshadow",
  "buttontext",
  "calc",
  "capitalize",
  "caps-lock-indicator",
  "caption",
  "captiontext",
  "caret",
  "cell",
  "center",
  "checkbox",
  "circle",
  "cjk-decimal",
  "clear",
  "clip",
  "close-quote",
  "col-resize",
  "collapse",
  "color",
  "color-burn",
  "color-dodge",
  "column",
  "column-reverse",
  "compact",
  "condensed",
  "contain",
  "content",
  "contents",
  "content-box",
  "context-menu",
  "continuous",
  "copy",
  "counter",
  "counters",
  "cover",
  "crop",
  "cross",
  "crosshair",
  "currentcolor",
  "cursive",
  "cyclic",
  "darken",
  "dashed",
  "decimal",
  "decimal-leading-zero",
  "default",
  "default-button",
  "dense",
  "destination-atop",
  "destination-in",
  "destination-out",
  "destination-over",
  "difference",
  "disc",
  "discard",
  "disclosure-closed",
  "disclosure-open",
  "document",
  "dot-dash",
  "dot-dot-dash",
  "dotted",
  "double",
  "down",
  "e-resize",
  "ease",
  "ease-in",
  "ease-in-out",
  "ease-out",
  "element",
  "ellipse",
  "ellipsis",
  "embed",
  "end",
  "ethiopic-abegede-gez",
  "ethiopic-halehame-aa-er",
  "ethiopic-halehame-gez",
  "ew-resize",
  "exclusion",
  "expanded",
  "extends",
  "extra-condensed",
  "extra-expanded",
  "fantasy",
  "fast",
  "fill",
  "fill-box",
  "fixed",
  "flat",
  "flex",
  "flex-end",
  "flex-start",
  "footnotes",
  "forwards",
  "from",
  "geometricPrecision",
  "graytext",
  "grid",
  "groove",
  "hand",
  "hard-light",
  "help",
  "hidden",
  "hide",
  "higher",
  "highlight",
  "highlighttext",
  "horizontal",
  "hsl",
  "hsla",
  "hue",
  "icon",
  "ignore",
  "inactiveborder",
  "inactivecaption",
  "inactivecaptiontext",
  "infinite",
  "infobackground",
  "infotext",
  "inherit",
  "initial",
  "inline",
  "inline-axis",
  "inline-block",
  "inline-flex",
  "inline-grid",
  "inline-table",
  "inset",
  "inside",
  "intrinsic",
  "invert",
  "italic",
  "justify",
  "keep-all",
  "landscape",
  "large",
  "larger",
  "left",
  "level",
  "lighter",
  "lighten",
  "line-through",
  "linear",
  "linear-gradient",
  "lines",
  "list-item",
  "listbox",
  "listitem",
  "local",
  "logical",
  "loud",
  "lower",
  "lower-hexadecimal",
  "lower-latin",
  "lower-norwegian",
  "lowercase",
  "ltr",
  "luminosity",
  "manipulation",
  "match",
  "matrix",
  "matrix3d",
  "medium",
  "menu",
  "menutext",
  "message-box",
  "middle",
  "min-intrinsic",
  "mix",
  "monospace",
  "move",
  "multiple",
  "multiple_mask_images",
  "multiply",
  "n-resize",
  "narrower",
  "ne-resize",
  "nesw-resize",
  "no-close-quote",
  "no-drop",
  "no-open-quote",
  "no-repeat",
  "none",
  "normal",
  "not-allowed",
  "nowrap",
  "ns-resize",
  "numbers",
  "numeric",
  "nw-resize",
  "nwse-resize",
  "oblique",
  "opacity",
  "open-quote",
  "optimizeLegibility",
  "optimizeSpeed",
  "outset",
  "outside",
  "outside-shape",
  "overlay",
  "overline",
  "padding",
  "padding-box",
  "painted",
  "page",
  "paused",
  "perspective",
  "pinch-zoom",
  "plus-darker",
  "plus-lighter",
  "pointer",
  "polygon",
  "portrait",
  "pre",
  "pre-line",
  "pre-wrap",
  "preserve-3d",
  "progress",
  "push-button",
  "radial-gradient",
  "radio",
  "read-only",
  "read-write",
  "read-write-plaintext-only",
  "rectangle",
  "region",
  "relative",
  "repeat",
  "repeating-linear-gradient",
  "repeating-radial-gradient",
  "repeat-x",
  "repeat-y",
  "reset",
  "reverse",
  "rgb",
  "rgba",
  "ridge",
  "right",
  "rotate",
  "rotate3d",
  "rotateX",
  "rotateY",
  "rotateZ",
  "round",
  "row",
  "row-resize",
  "row-reverse",
  "rtl",
  "run-in",
  "running",
  "s-resize",
  "sans-serif",
  "saturation",
  "scale",
  "scale3d",
  "scaleX",
  "scaleY",
  "scaleZ",
  "screen",
  "scroll",
  "scrollbar",
  "scroll-position",
  "se-resize",
  "self-start",
  "self-end",
  "semi-condensed",
  "semi-expanded",
  "separate",
  "serif",
  "show",
  "single",
  "skew",
  "skewX",
  "skewY",
  "skip-white-space",
  "slide",
  "slider-horizontal",
  "slider-vertical",
  "sliderthumb-horizontal",
  "sliderthumb-vertical",
  "slow",
  "small",
  "small-caps",
  "small-caption",
  "smaller",
  "soft-light",
  "solid",
  "source-atop",
  "source-in",
  "source-out",
  "source-over",
  "space",
  "space-around",
  "space-between",
  "space-evenly",
  "spell-out",
  "square",
  "start",
  "static",
  "status-bar",
  "stretch",
  "stroke",
  "stroke-box",
  "sub",
  "subpixel-antialiased",
  "svg_masks",
  "super",
  "sw-resize",
  "symbolic",
  "symbols",
  "system-ui",
  "table",
  "table-caption",
  "table-cell",
  "table-column",
  "table-column-group",
  "table-footer-group",
  "table-header-group",
  "table-row",
  "table-row-group",
  "text",
  "text-bottom",
  "text-top",
  "textarea",
  "textfield",
  "thick",
  "thin",
  "threeddarkshadow",
  "threedface",
  "threedhighlight",
  "threedlightshadow",
  "threedshadow",
  "to",
  "top",
  "transform",
  "translate",
  "translate3d",
  "translateX",
  "translateY",
  "translateZ",
  "transparent",
  "ultra-condensed",
  "ultra-expanded",
  "underline",
  "unidirectional-pan",
  "unset",
  "up",
  "upper-latin",
  "uppercase",
  "url",
  "var",
  "vertical",
  "vertical-text",
  "view-box",
  "visible",
  "visibleFill",
  "visiblePainted",
  "visibleStroke",
  "visual",
  "w-resize",
  "wait",
  "wave",
  "wider",
  "window",
  "windowframe",
  "windowtext",
  "words",
  "wrap",
  "wrap-reverse",
  "x-large",
  "x-small",
  "xor",
  "xx-large",
  "xx-small"
].map((r) => ({ type: "keyword", label: r })).concat(/* @__PURE__ */ [
  "aliceblue",
  "antiquewhite",
  "aqua",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blue",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "fuchsia",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "gray",
  "grey",
  "green",
  "greenyellow",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightsteelblue",
  "lightyellow",
  "lime",
  "limegreen",
  "linen",
  "magenta",
  "maroon",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "navy",
  "oldlace",
  "olive",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "purple",
  "rebeccapurple",
  "red",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "silver",
  "skyblue",
  "slateblue",
  "slategray",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "teal",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "white",
  "whitesmoke",
  "yellow",
  "yellowgreen"
].map((r) => ({ type: "constant", label: r }))), JP = /* @__PURE__ */ [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "b",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "figcaption",
  "figure",
  "footer",
  "form",
  "header",
  "hgroup",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "meter",
  "nav",
  "ol",
  "output",
  "p",
  "pre",
  "ruby",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "tr",
  "u",
  "ul"
].map((r) => ({ type: "type", label: r })), mr = /^(\w[\w-]*|-\w[\w-]*|)$/, e2 = /^-(-[\w-]*)?$/;
function t2(r, e) {
  var t;
  if ((r.name == "(" || r.type.isError) && (r = r.parent || r), r.name != "ArgList")
    return !1;
  let i = (t = r.parent) === null || t === void 0 ? void 0 : t.firstChild;
  return (i == null ? void 0 : i.name) != "Callee" ? !1 : e.sliceString(i.from, i.to) == "var";
}
const Np = /* @__PURE__ */ new $c(), r2 = ["Declaration"];
function i2(r) {
  for (let e = r; ; ) {
    if (e.type.isTop)
      return e;
    if (!(e = e.parent))
      return r;
  }
}
function _0(r, e, t) {
  if (e.to - e.from > 4096) {
    let i = Np.get(e);
    if (i)
      return i;
    let n = [], s = /* @__PURE__ */ new Set(), o = e.cursor(ne.IncludeAnonymous);
    if (o.firstChild())
      do
        for (let l of _0(r, o.node, t))
          s.has(l.label) || (s.add(l.label), n.push(l));
      while (o.nextSibling());
    return Np.set(e, n), n;
  } else {
    let i = [], n = /* @__PURE__ */ new Set();
    return e.cursor().iterate((s) => {
      var o;
      if (t(s) && s.matchContext(r2) && ((o = s.node.nextSibling) === null || o === void 0 ? void 0 : o.name) == ":") {
        let l = r.sliceString(s.from, s.to);
        n.has(l) || (n.add(l), i.push({ label: l, type: "variable" }));
      }
    }), i;
  }
}
const n2 = (r) => (e) => {
  let { state: t, pos: i } = e, n = te(t).resolveInner(i, -1), s = n.type.isError && n.from == n.to - 1 && t.doc.sliceString(n.from, n.to) == "-";
  if (n.name == "PropertyName" || (s || n.name == "TagName") && /^(Block|Styles)$/.test(n.resolve(n.to).name))
    return { from: n.from, options: ba(), validFor: mr };
  if (n.name == "ValueName")
    return { from: n.from, options: Gp, validFor: mr };
  if (n.name == "PseudoClassName")
    return { from: n.from, options: Up, validFor: mr };
  if (r(n) || (e.explicit || s) && t2(n, t.doc))
    return {
      from: r(n) || s ? n.from : i,
      options: _0(t.doc, i2(n), r),
      validFor: e2
    };
  if (n.name == "TagName") {
    for (let { parent: a } = n; a; a = a.parent)
      if (a.name == "Block")
        return { from: n.from, options: ba(), validFor: mr };
    return { from: n.from, options: JP, validFor: mr };
  }
  if (!e.explicit)
    return null;
  let o = n.resolve(i), l = o.childBefore(i);
  return l && l.name == ":" && o.name == "PseudoClassSelector" ? { from: i, options: Up, validFor: mr } : l && l.name == ":" && o.name == "Declaration" || o.name == "ArgList" ? { from: i, options: Gp, validFor: mr } : o.name == "Block" || o.name == "Styles" ? { from: i, options: ba(), validFor: mr } : null;
}, s2 = /* @__PURE__ */ n2((r) => r.name == "VariableName"), tl = /* @__PURE__ */ Nt.define({
  name: "css",
  parser: /* @__PURE__ */ KP.configure({
    props: [
      /* @__PURE__ */ Br.add({
        Declaration: /* @__PURE__ */ si()
      }),
      /* @__PURE__ */ fr.add({
        "Block KeyframeList": wl
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*\}$/,
    wordChars: "-"
  }
});
function R0() {
  return new cr(tl, tl.data.of({ autocomplete: s2 }));
}
const o2 = 54, l2 = 1, a2 = 55, h2 = 2, c2 = 56, u2 = 3, Fp = 4, d2 = 5, rl = 6, A0 = 7, E0 = 8, q0 = 9, z0 = 10, p2 = 11, f2 = 12, O2 = 13, wa = 57, m2 = 14, Hp = 58, Y0 = 20, g2 = 22, W0 = 23, b2 = 24, zh = 26, V0 = 27, w2 = 28, y2 = 31, v2 = 34, x2 = 36, S2 = 37, k2 = 0, $2 = 1, Q2 = {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  command: !0,
  embed: !0,
  frame: !0,
  hr: !0,
  img: !0,
  input: !0,
  keygen: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0,
  menuitem: !0
}, P2 = {
  dd: !0,
  li: !0,
  optgroup: !0,
  option: !0,
  p: !0,
  rp: !0,
  rt: !0,
  tbody: !0,
  td: !0,
  tfoot: !0,
  th: !0,
  tr: !0
}, Kp = {
  dd: { dd: !0, dt: !0 },
  dt: { dd: !0, dt: !0 },
  li: { li: !0 },
  option: { option: !0, optgroup: !0 },
  optgroup: { optgroup: !0 },
  p: {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    dir: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    menu: !0,
    nav: !0,
    ol: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    ul: !0
  },
  rp: { rp: !0, rt: !0 },
  rt: { rp: !0, rt: !0 },
  tbody: { tbody: !0, tfoot: !0 },
  td: { td: !0, th: !0 },
  tfoot: { tbody: !0 },
  th: { td: !0, th: !0 },
  thead: { tbody: !0, tfoot: !0 },
  tr: { tr: !0 }
};
function T2(r) {
  return r == 45 || r == 46 || r == 58 || r >= 65 && r <= 90 || r == 95 || r >= 97 && r <= 122 || r >= 161;
}
function M0(r) {
  return r == 9 || r == 10 || r == 13 || r == 32;
}
let Jp = null, ef = null, tf = 0;
function Yh(r, e) {
  let t = r.pos + e;
  if (tf == t && ef == r)
    return Jp;
  let i = r.peek(e);
  for (; M0(i); )
    i = r.peek(++e);
  let n = "";
  for (; T2(i); )
    n += String.fromCharCode(i), i = r.peek(++e);
  return ef = r, tf = t, Jp = n ? n.toLowerCase() : i == C2 || i == X2 ? void 0 : null;
}
const j0 = 60, il = 62, Jc = 47, C2 = 63, X2 = 33, Z2 = 45;
function rf(r, e) {
  this.name = r, this.parent = e, this.hash = e ? e.hash : 0;
  for (let t = 0; t < r.length; t++)
    this.hash += (this.hash << 4) + r.charCodeAt(t) + (r.charCodeAt(t) << 8);
}
const _2 = [rl, z0, A0, E0, q0], R2 = new Kc({
  start: null,
  shift(r, e, t, i) {
    return _2.indexOf(e) > -1 ? new rf(Yh(i, 1) || "", r) : r;
  },
  reduce(r, e) {
    return e == Y0 && r ? r.parent : r;
  },
  reuse(r, e, t, i) {
    let n = e.type.id;
    return n == rl || n == x2 ? new rf(Yh(i, 1) || "", r) : r;
  },
  hash(r) {
    return r ? r.hash : 0;
  },
  strict: !1
}), A2 = new Ae((r, e) => {
  if (r.next != j0) {
    r.next < 0 && e.context && r.acceptToken(wa);
    return;
  }
  r.advance();
  let t = r.next == Jc;
  t && r.advance();
  let i = Yh(r, 0);
  if (i === void 0)
    return;
  if (!i)
    return r.acceptToken(t ? m2 : rl);
  let n = e.context ? e.context.name : null;
  if (t) {
    if (i == n)
      return r.acceptToken(p2);
    if (n && P2[n])
      return r.acceptToken(wa, -2);
    if (e.dialectEnabled(k2))
      return r.acceptToken(f2);
    for (let s = e.context; s; s = s.parent)
      if (s.name == i)
        return;
    r.acceptToken(O2);
  } else {
    if (i == "script")
      return r.acceptToken(A0);
    if (i == "style")
      return r.acceptToken(E0);
    if (i == "textarea")
      return r.acceptToken(q0);
    if (Q2.hasOwnProperty(i))
      return r.acceptToken(z0);
    n && Kp[n] && Kp[n][i] ? r.acceptToken(wa, -1) : r.acceptToken(rl);
  }
}, { contextual: !0 }), E2 = new Ae((r) => {
  for (let e = 0, t = 0; ; t++) {
    if (r.next < 0) {
      t && r.acceptToken(Hp);
      break;
    }
    if (r.next == Z2)
      e++;
    else if (r.next == il && e >= 2) {
      t >= 3 && r.acceptToken(Hp, -2);
      break;
    } else
      e = 0;
    r.advance();
  }
});
function q2(r) {
  for (; r; r = r.parent)
    if (r.name == "svg" || r.name == "math")
      return !0;
  return !1;
}
const z2 = new Ae((r, e) => {
  if (r.next == Jc && r.peek(1) == il) {
    let t = e.dialectEnabled($2) || q2(e.context);
    r.acceptToken(t ? d2 : Fp, 2);
  } else
    r.next == il && r.acceptToken(Fp, 1);
});
function eu(r, e, t) {
  let i = 2 + r.length;
  return new Ae((n) => {
    for (let s = 0, o = 0, l = 0; ; l++) {
      if (n.next < 0) {
        l && n.acceptToken(e);
        break;
      }
      if (s == 0 && n.next == j0 || s == 1 && n.next == Jc || s >= 2 && s < i && n.next == r.charCodeAt(s - 2))
        s++, o++;
      else if ((s == 2 || s == i) && M0(n.next))
        o++;
      else if (s == i && n.next == il) {
        l > o ? n.acceptToken(e, -o) : n.acceptToken(t, -(o - 2));
        break;
      } else if ((n.next == 10 || n.next == 13) && l) {
        n.acceptToken(e, 1);
        break;
      } else
        s = o = 0;
      n.advance();
    }
  });
}
const Y2 = eu("script", o2, l2), W2 = eu("style", a2, h2), V2 = eu("textarea", c2, u2), M2 = Jt({
  "Text RawText": O.content,
  "StartTag StartCloseTag SelfClosingEndTag EndTag": O.angleBracket,
  TagName: O.tagName,
  "MismatchedCloseTag/TagName": [O.tagName, O.invalid],
  AttributeName: O.attributeName,
  "AttributeValue UnquotedAttributeValue": O.attributeValue,
  Is: O.definitionOperator,
  "EntityReference CharacterReference": O.character,
  Comment: O.blockComment,
  ProcessingInst: O.processingInstruction,
  DoctypeDecl: O.documentMeta
}), j2 = Ft.deserialize({
  version: 14,
  states: ",xOVO!rOOO!WQ#tO'#CqO!]Q#tO'#CzO!bQ#tO'#C}O!gQ#tO'#DQO!lQ#tO'#DSO!qOaO'#CpO!|ObO'#CpO#XOdO'#CpO$eO!rO'#CpOOO`'#Cp'#CpO$lO$fO'#DTO$tQ#tO'#DVO$yQ#tO'#DWOOO`'#Dk'#DkOOO`'#DY'#DYQVO!rOOO%OQ&rO,59]O%WQ&rO,59fO%`Q&rO,59iO%hQ&rO,59lO%sQ&rO,59nOOOa'#D^'#D^O%{OaO'#CxO&WOaO,59[OOOb'#D_'#D_O&`ObO'#C{O&kObO,59[OOOd'#D`'#D`O&sOdO'#DOO'OOdO,59[OOO`'#Da'#DaO'WO!rO,59[O'_Q#tO'#DROOO`,59[,59[OOOp'#Db'#DbO'dO$fO,59oOOO`,59o,59oO'lQ#|O,59qO'qQ#|O,59rOOO`-E7W-E7WO'vQ&rO'#CsOOQW'#DZ'#DZO(UQ&rO1G.wOOOa1G.w1G.wO(^Q&rO1G/QOOOb1G/Q1G/QO(fQ&rO1G/TOOOd1G/T1G/TO(nQ&rO1G/WOOO`1G/W1G/WOOO`1G/Y1G/YO(yQ&rO1G/YOOOa-E7[-E7[O)RQ#tO'#CyOOO`1G.v1G.vOOOb-E7]-E7]O)WQ#tO'#C|OOOd-E7^-E7^O)]Q#tO'#DPOOO`-E7_-E7_O)bQ#|O,59mOOOp-E7`-E7`OOO`1G/Z1G/ZOOO`1G/]1G/]OOO`1G/^1G/^O)gQ,UO,59_OOQW-E7X-E7XOOOa7+$c7+$cOOOb7+$l7+$lOOOd7+$o7+$oOOO`7+$r7+$rOOO`7+$t7+$tO)rQ#|O,59eO)wQ#|O,59hO)|Q#|O,59kOOO`1G/X1G/XO*RO7[O'#CvO*dOMhO'#CvOOQW1G.y1G.yOOO`1G/P1G/POOO`1G/S1G/SOOO`1G/V1G/VOOOO'#D['#D[O*uO7[O,59bOOQW,59b,59bOOOO'#D]'#D]O+WOMhO,59bOOOO-E7Y-E7YOOQW1G.|1G.|OOOO-E7Z-E7Z",
  stateData: "+s~O!^OS~OUSOVPOWQOXROYTO[]O][O^^O`^Oa^Ob^Oc^Ox^O{_O!dZO~OfaO~OfbO~OfcO~OfdO~OfeO~O!WfOPlP!ZlP~O!XiOQoP!ZoP~O!YlORrP!ZrP~OUSOVPOWQOXROYTOZqO[]O][O^^O`^Oa^Ob^Oc^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OfvO~OfwO~OS|OhyO~OS!OOhyO~OS!QOhyO~OS!SOT!TOhyO~OS!TOhyO~O!WfOPlX!ZlX~OP!WO!Z!XO~O!XiOQoX!ZoX~OQ!ZO!Z!XO~O!YlORrX!ZrX~OR!]O!Z!XO~O!Z!XO~P#dOf!_O~O![sO!e!aO~OS!bO~OS!cO~Oi!dOSgXhgXTgX~OS!fOhyO~OS!gOhyO~OS!hOhyO~OS!iOT!jOhyO~OS!jOhyO~Of!kO~Of!lO~Of!mO~OS!nO~Ok!qO!`!oO!b!pO~OS!rO~OS!sO~OS!tO~Oa!uOb!uOc!uO!`!wO!a!uO~Oa!xOb!xOc!xO!b!wO!c!xO~Oa!uOb!uOc!uO!`!{O!a!uO~Oa!xOb!xOc!xO!b!{O!c!xO~OT~bac!dx{!d~",
  goto: "%p!`PPPPPPPPPPPPPPPPPPPP!a!gP!mPP!yP!|#P#S#Y#]#`#f#i#l#r#x!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{}!P!R!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ}bQ!PcQ!RdQ!UeZ!e{}!P!R!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
  nodeNames: "⚠ StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
  maxTerm: 67,
  context: R2,
  nodeProps: [
    ["closedBy", -10, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13, "EndTag", 6, "EndTag SelfClosingEndTag", -4, 21, 30, 33, 36, "CloseTag"],
    ["openedBy", 4, "StartTag StartCloseTag", 5, "StartTag", -4, 29, 32, 35, 37, "OpenTag"],
    ["group", -9, 14, 17, 18, 19, 20, 39, 40, 41, 42, "Entity", 16, "Entity TextContent", -3, 28, 31, 34, "TextContent Entity"],
    ["isolate", -11, 21, 29, 30, 32, 33, 35, 36, 37, 38, 41, 42, "ltr", -3, 26, 27, 39, ""]
  ],
  propSources: [M2],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|c`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT`POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYkWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]``P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebhSkWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXhSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vchS`P!a`!cpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!`h`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WihSkWc!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zbkWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOa!R!R7tP;=`<%l7S!Z8OYkWa!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{ihSkWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbhSkWa!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QchSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXhSa!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TakWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOb!R!RAwP;=`<%lAY!ZBRYkWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbhSkWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbhSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXhSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!bx`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYlhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_khS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_X`P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZhSfQ`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!a`!cpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!a`!cp!dPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!a`!cpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!a`!cpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!a`!cpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!a`!cpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!a`!cpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!a`!cpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!a`!cpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!cpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO{PP!-nP;=`<%l!-Sq!-xS!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!a`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!a`!cpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!a`!cpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!a`!cpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!a`!cpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!a`!cpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!a`!cpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!cpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOxPP!7TP;=`<%l!6Vq!7]V!cpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!a`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!a`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXiS`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
  tokenizers: [Y2, W2, V2, z2, A2, E2, 0, 1, 2, 3, 4, 5],
  topRules: { Document: [0, 15] },
  dialects: { noMatch: 0, selfClosing: 485 },
  tokenPrec: 487
});
function L0(r, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let i of r.getChildren(W0)) {
    let n = i.getChild(b2), s = i.getChild(zh) || i.getChild(V0);
    n && (t[e.read(n.from, n.to)] = s ? s.type.id == zh ? e.read(s.from + 1, s.to - 1) : e.read(s.from, s.to) : "");
  }
  return t;
}
function nf(r, e) {
  let t = r.getChild(g2);
  return t ? e.read(t.from, t.to) : " ";
}
function ya(r, e, t) {
  let i;
  for (let n of t)
    if (!n.attrs || n.attrs(i || (i = L0(r.node.parent.firstChild, e))))
      return { parser: n.parser };
  return null;
}
function B0(r = [], e = []) {
  let t = [], i = [], n = [], s = [];
  for (let l of r)
    (l.tag == "script" ? t : l.tag == "style" ? i : l.tag == "textarea" ? n : s).push(l);
  let o = e.length ? /* @__PURE__ */ Object.create(null) : null;
  for (let l of e)
    (o[l.name] || (o[l.name] = [])).push(l);
  return Lm((l, a) => {
    let h = l.type.id;
    if (h == w2)
      return ya(l, a, t);
    if (h == y2)
      return ya(l, a, i);
    if (h == v2)
      return ya(l, a, n);
    if (h == Y0 && s.length) {
      let c = l.node, u = c.firstChild, d = u && nf(u, a), p;
      if (d) {
        for (let f of s)
          if (f.tag == d && (!f.attrs || f.attrs(p || (p = L0(c, a))))) {
            let m = c.lastChild, g = m.type.id == S2 ? m.from : c.to;
            if (g > u.to)
              return { parser: f.parser, overlay: [{ from: u.to, to: g }] };
          }
      }
    }
    if (o && h == W0) {
      let c = l.node, u;
      if (u = c.firstChild) {
        let d = o[a.read(u.from, u.to)];
        if (d)
          for (let p of d) {
            if (p.tagName && p.tagName != nf(c.parent, a))
              continue;
            let f = c.lastChild;
            if (f.type.id == zh) {
              let m = f.from + 1, g = f.lastChild, b = f.to - (g && g.isError ? 0 : 1);
              if (b > m)
                return { parser: p.parser, overlay: [{ from: m, to: b }] };
            } else if (f.type.id == V0)
              return { parser: p.parser, overlay: [{ from: f.from, to: f.to }] };
          }
      }
    }
    return null;
  });
}
const L2 = 309, sf = 1, B2 = 2, D2 = 3, I2 = 310, U2 = 312, G2 = 313, N2 = 4, F2 = 5, H2 = 0, Wh = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], D0 = 125, K2 = 59, Vh = 47, J2 = 42, eT = 43, tT = 45, rT = 60, iT = 44, nT = new Kc({
  start: !1,
  shift(r, e) {
    return e == N2 || e == F2 || e == U2 ? r : e == G2;
  },
  strict: !1
}), sT = new Ae((r, e) => {
  let { next: t } = r;
  (t == D0 || t == -1 || e.context) && r.acceptToken(I2);
}, { contextual: !0, fallback: !0 }), oT = new Ae((r, e) => {
  let { next: t } = r, i;
  Wh.indexOf(t) > -1 || t == Vh && ((i = r.peek(1)) == Vh || i == J2) || t != D0 && t != K2 && t != -1 && !e.context && r.acceptToken(L2);
}, { contextual: !0 }), lT = new Ae((r, e) => {
  let { next: t } = r;
  if ((t == eT || t == tT) && (r.advance(), t == r.next)) {
    r.advance();
    let i = !e.context && e.canShift(sf);
    r.acceptToken(i ? sf : B2);
  }
}, { contextual: !0 });
function va(r, e) {
  return r >= 65 && r <= 90 || r >= 97 && r <= 122 || r == 95 || r >= 192 || !e && r >= 48 && r <= 57;
}
const aT = new Ae((r, e) => {
  if (r.next != rT || !e.dialectEnabled(H2) || (r.advance(), r.next == Vh))
    return;
  let t = 0;
  for (; Wh.indexOf(r.next) > -1; )
    r.advance(), t++;
  if (va(r.next, !0)) {
    for (r.advance(), t++; va(r.next, !1); )
      r.advance(), t++;
    for (; Wh.indexOf(r.next) > -1; )
      r.advance(), t++;
    if (r.next == iT)
      return;
    for (let i = 0; ; i++) {
      if (i == 7) {
        if (!va(r.next, !0))
          return;
        break;
      }
      if (r.next != "extends".charCodeAt(i))
        break;
      r.advance(), t++;
    }
  }
  r.acceptToken(D2, -t);
}), hT = Jt({
  "get set async static": O.modifier,
  "for while do if else switch try catch finally return throw break continue default case": O.controlKeyword,
  "in of await yield void typeof delete instanceof": O.operatorKeyword,
  "let var const using function class extends": O.definitionKeyword,
  "import export from": O.moduleKeyword,
  "with debugger as new": O.keyword,
  TemplateString: O.special(O.string),
  super: O.atom,
  BooleanLiteral: O.bool,
  this: O.self,
  null: O.null,
  Star: O.modifier,
  VariableName: O.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": O.function(O.variableName),
  VariableDefinition: O.definition(O.variableName),
  Label: O.labelName,
  PropertyName: O.propertyName,
  PrivatePropertyName: O.special(O.propertyName),
  "CallExpression/MemberExpression/PropertyName": O.function(O.propertyName),
  "FunctionDeclaration/VariableDefinition": O.function(O.definition(O.variableName)),
  "ClassDeclaration/VariableDefinition": O.definition(O.className),
  PropertyDefinition: O.definition(O.propertyName),
  PrivatePropertyDefinition: O.definition(O.special(O.propertyName)),
  UpdateOp: O.updateOperator,
  "LineComment Hashbang": O.lineComment,
  BlockComment: O.blockComment,
  Number: O.number,
  String: O.string,
  Escape: O.escape,
  ArithOp: O.arithmeticOperator,
  LogicOp: O.logicOperator,
  BitOp: O.bitwiseOperator,
  CompareOp: O.compareOperator,
  RegExp: O.regexp,
  Equals: O.definitionOperator,
  Arrow: O.function(O.punctuation),
  ": Spread": O.punctuation,
  "( )": O.paren,
  "[ ]": O.squareBracket,
  "{ }": O.brace,
  "InterpolationStart InterpolationEnd": O.special(O.brace),
  ".": O.derefOperator,
  ", ;": O.separator,
  "@": O.meta,
  TypeName: O.typeName,
  TypeDefinition: O.definition(O.typeName),
  "type enum interface implements namespace module declare": O.definitionKeyword,
  "abstract global Privacy readonly override": O.modifier,
  "is keyof unique infer": O.operatorKeyword,
  JSXAttributeValue: O.attributeValue,
  JSXText: O.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": O.angleBracket,
  "JSXIdentifier JSXNameSpacedName": O.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": O.attributeName,
  "JSXBuiltin/JSXIdentifier": O.standard(O.tagName)
}), cT = { __proto__: null, export: 18, as: 23, from: 31, default: 34, async: 39, function: 40, extends: 52, this: 56, true: 64, false: 64, null: 76, void: 80, typeof: 84, super: 102, new: 136, delete: 152, yield: 161, await: 165, class: 170, public: 227, private: 227, protected: 227, readonly: 229, instanceof: 248, satisfies: 251, in: 252, const: 254, import: 286, keyof: 339, unique: 343, infer: 349, is: 385, abstract: 405, implements: 407, type: 409, let: 412, var: 414, using: 417, interface: 423, enum: 427, namespace: 433, module: 435, declare: 439, global: 443, for: 462, of: 471, while: 474, with: 478, do: 482, if: 486, else: 488, switch: 492, case: 498, try: 504, catch: 508, finally: 512, return: 516, throw: 520, break: 524, continue: 528, debugger: 532 }, uT = { __proto__: null, async: 123, get: 125, set: 127, declare: 187, public: 189, private: 189, protected: 189, static: 191, abstract: 193, override: 195, readonly: 201, accessor: 203, new: 389 }, dT = { __proto__: null, "<": 143 }, pT = Ft.deserialize({
  version: 14,
  states: "$<UO%TQ^OOO%[Q^OOO'_Q`OOP(lOWOOO*zQ08SO'#ChO+RO!bO'#CiO+aO#tO'#CiO+oO?MpO'#D^O.QQ^O'#DdO.bQ^O'#DoO%[Q^O'#DyO0fQ^O'#EROOQ07b'#EZ'#EZO1PQWO'#EWOOQO'#El'#ElOOQO'#Ie'#IeO1XQWO'#GmO1dQWO'#EkO1iQWO'#EkO3kQ08SO'#JiO6[Q08SO'#JjO6xQWO'#FZO6}Q&jO'#FqOOQ07b'#Fc'#FcO7YO,YO'#FcO7hQ7[O'#FxO9UQWO'#FwOOQ07b'#Jj'#JjOOQ07`'#Ji'#JiO9ZQWO'#GqOOQU'#KU'#KUO9fQWO'#IRO9kQ07hO'#ISOOQU'#JW'#JWOOQU'#IW'#IWQ`Q^OOO`Q^OOO%[Q^O'#DqO9sQ^O'#D}O9zQ^O'#EPO9aQWO'#GmO:RQ7[O'#CnO:aQWO'#EjO:lQWO'#EuO:qQ7[O'#FbO;`QWO'#GmOOQO'#KV'#KVO;eQWO'#KVO;sQWO'#GuO;sQWO'#GvO;sQWO'#GxO9aQWO'#G{O<jQWO'#HOO>RQWO'#CdO>cQWO'#H[O>kQWO'#HbO>kQWO'#HdO`Q^O'#HfO>kQWO'#HhO>kQWO'#HkO>pQWO'#HqO>uQ07iO'#HwO%[Q^O'#HyO?QQ07iO'#H{O?]Q07iO'#H}O9kQ07hO'#IPO?hQ08SO'#ChO@jQ`O'#DiQOQWOOO%[Q^O'#EPOAQQWO'#ESO:RQ7[O'#EjOA]QWO'#EjOAhQpO'#FbOOQU'#Cf'#CfOOQ07`'#Dn'#DnOOQ07`'#Jm'#JmO%[Q^O'#JmOOQO'#Jq'#JqOOQO'#Ib'#IbOBhQ`O'#EcOOQ07`'#Eb'#EbOCdQ07pO'#EcOCnQ`O'#EVOOQO'#Jp'#JpODSQ`O'#JqOEaQ`O'#EVOCnQ`O'#EcPEnO!0LbO'#CaPOOO)CDu)CDuOOOO'#IX'#IXOEyO!bO,59TOOQ07b,59T,59TOOOO'#IY'#IYOFXO#tO,59TO%[Q^O'#D`OOOO'#I['#I[OFgO?MpO,59xOOQ07b,59x,59xOFuQ^O'#I]OGYQWO'#JkOI[QrO'#JkO+}Q^O'#JkOIcQWO,5:OOIyQWO'#ElOJWQWO'#JyOJcQWO'#JxOJcQWO'#JxOJkQWO,5;YOJpQWO'#JwOOQ07f,5:Z,5:ZOJwQ^O,5:ZOLxQ08SO,5:eOMiQWO,5:mONSQ07hO'#JvONZQWO'#JuO9ZQWO'#JuONoQWO'#JuONwQWO,5;XON|QWO'#JuO!#UQrO'#JjOOQ07b'#Ch'#ChO%[Q^O'#ERO!#tQpO,5:rOOQO'#Jr'#JrOOQO-E<c-E<cO9aQWO,5=XO!$[QWO,5=XO!$aQ^O,5;VO!&dQ7[O'#EgO!'}QWO,5;VO!)mQ7[O'#DsO!)tQ^O'#DxO!*OQ`O,5;`O!*WQ`O,5;`O%[Q^O,5;`OOQU'#FR'#FROOQU'#FT'#FTO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aOOQU'#FX'#FXO!*fQ^O,5;rOOQ07b,5;w,5;wOOQ07b,5;x,5;xO!,iQWO,5;xOOQ07b,5;y,5;yO%[Q^O'#IiO!,qQ07hO,5<eO!&dQ7[O,5;aO!-`Q7[O,5;aO%[Q^O,5;uO!-gQ&jO'#FgO!.dQ&jO'#J}O!.OQ&jO'#J}O!.kQ&jO'#J}OOQO'#J}'#J}O!/PQ&jO,5<POOOS,5<],5<]O!/bQ^O'#FsOOOS'#Ih'#IhO7YO,YO,5;}O!/iQ&jO'#FuOOQ07b,5;},5;}O!0YQMhO'#CuOOQ07b'#Cy'#CyO!0mQWO'#CyO!0rO?MpO'#C}O!1`Q7[O,5<bO!1gQWO,5<dO!3SQ!LQO'#GSO!3aQWO'#GTO!3fQWO'#GTO!3kQ!LQO'#GXO!4jQ`O'#G]OOQO'#Gh'#GhO!(SQ7[O'#GgOOQO'#Gj'#GjO!(SQ7[O'#GiO!5]QMhO'#JdOOQ07b'#Jd'#JdO!5gQWO'#JcO!5uQWO'#JbO!5}QWO'#CtOOQ07b'#Cw'#CwOOQ07b'#DR'#DROOQ07b'#DT'#DTO1SQWO'#DVO!(SQ7[O'#FzO!(SQ7[O'#F|O!6VQWO'#GOO!6[QWO'#GPO!3fQWO'#GVO!(SQ7[O'#G[O!6aQWO'#EmO!7OQWO,5<cOOQ07`'#Cq'#CqO!7WQWO'#EnO!8QQ`O'#EoOOQ07`'#Jw'#JwO!8XQ07hO'#KWO9kQ07hO,5=]O`Q^O,5>mOOQU'#J`'#J`OOQU,5>n,5>nOOQU-E<U-E<UO!:ZQ08SO,5:]O!<wQ08SO,5:iO%[Q^O,5:iO!?bQ08SO,5:kOOQO,5@q,5@qO!@RQ7[O,5=XO!@aQ07hO'#JaO9UQWO'#JaO!@rQ07hO,59YO!@}Q`O,59YO!AVQ7[O,59YO:RQ7[O,59YO!AbQWO,5;VO!AjQWO'#HZO!BOQWO'#KZO%[Q^O,5;zO!7{Q`O,5;|O!BWQWO,5=tO!B]QWO,5=tO!BbQWO,5=tO9kQ07hO,5=tO;sQWO,5=dOOQO'#Cu'#CuO!BpQ`O,5=aO!BxQ7[O,5=bO!CTQWO,5=dO!CYQpO,5=gO!CbQWO'#KVO>pQWO'#HQO9aQWO'#HSO!CgQWO'#HSO:RQ7[O'#HUO!ClQWO'#HUOOQU,5=j,5=jO!CqQWO'#HVO!DSQWO'#CnO!DXQWO,59OO!DcQWO,59OO!FhQ^O,59OOOQU,59O,59OO!FxQ07hO,59OO%[Q^O,59OO!ITQ^O'#H^OOQU'#H_'#H_OOQU'#H`'#H`O`Q^O,5=vO!IkQWO,5=vO`Q^O,5=|O`Q^O,5>OO!IpQWO,5>QO`Q^O,5>SO!IuQWO,5>VO!IzQ^O,5>]OOQU,5>c,5>cO%[Q^O,5>cO9kQ07hO,5>eOOQU,5>g,5>gO!NUQWO,5>gOOQU,5>i,5>iO!NUQWO,5>iOOQU,5>k,5>kO!NZQ`O'#D[O%[Q^O'#JmO!NxQ`O'#JmO# gQ`O'#DjO# xQ`O'#DjO#$ZQ^O'#DjO#$bQWO'#JlO#$jQWO,5:TO#$oQWO'#EpO#$}QWO'#JzO#%VQWO,5;ZO#%[Q`O'#DjO#%iQ`O'#EUOOQ07b,5:n,5:nO%[Q^O,5:nO#%pQWO,5:nO>pQWO,5;UO!@}Q`O,5;UO!AVQ7[O,5;UO:RQ7[O,5;UO#%xQWO,5@XO#%}Q$ISO,5:rOOQO-E<`-E<`O#'TQ07pO,5:}OCnQ`O,5:qO#'_Q`O,5:qOCnQ`O,5:}O!@rQ07hO,5:qOOQ07`'#Ef'#EfOOQO,5:},5:}O%[Q^O,5:}O#'lQ07hO,5:}O#'wQ07hO,5:}O!@}Q`O,5:qOOQO,5;T,5;TO#(VQ07hO,5:}POOO'#IV'#IVP#(kO!0LbO,58{POOO,58{,58{OOOO-E<V-E<VOOQ07b1G.o1G.oOOOO-E<W-E<WO#(vQpO,59zOOOO-E<Y-E<YOOQ07b1G/d1G/dO#({QrO,5>wO+}Q^O,5>wOOQO,5>},5>}O#)VQ^O'#I]OOQO-E<Z-E<ZO#)dQWO,5@VO#)lQrO,5@VO#)sQWO,5@dOOQ07b1G/j1G/jO%[Q^O,5@eO#){QWO'#IcOOQO-E<a-E<aO#)sQWO,5@dOOQ07`1G0t1G0tOOQ07f1G/u1G/uOOQ07f1G0X1G0XO%[Q^O,5@bO#*aQ07hO,5@bO#*rQ07hO,5@bO#*yQWO,5@aO9ZQWO,5@aO#+RQWO,5@aO#+aQWO'#IfO#*yQWO,5@aOOQ07`1G0s1G0sO!*OQ`O,5:tO!*ZQ`O,5:tOOQO,5:v,5:vO#,RQWO,5:vO#,ZQ7[O1G2sO9aQWO1G2sOOQ07b1G0q1G0qO#,iQ08SO1G0qO#-nQ08QO,5;ROOQ07b'#GR'#GRO#.[Q08SO'#JdO!$aQ^O1G0qO#0dQ7[O'#JnO#0nQWO,5:_O#0sQrO'#JoO%[Q^O'#JoO#0}QWO,5:dOOQ07b'#D['#D[OOQ07b1G0z1G0zO%[Q^O1G0zOOQ07b1G1d1G1dO#1SQWO1G0zO#3kQ08SO1G0{O#3rQ08SO1G0{O#6]Q08SO1G0{O#6dQ08SO1G0{O#8nQ08SO1G0{O#9UQ08SO1G0{O#<OQ08SO1G0{O#<VQ08SO1G0{O#>jQ08SO1G0{O#>wQ08SO1G0{O#@uQ08SO1G0{O#CuQ(CYO'#ChO#EsQ(CYO1G1^O#EzQ(CYO'#JjO!,lQWO1G1dO#F[Q08SO,5?TOOQ07`-E<g-E<gO#GOQ08SO1G0{OOQ07b1G0{1G0{O#IZQ08SO1G1aO#I}Q&jO,5<TO#JVQ&jO,5<UO#J_Q&jO'#FlO#JvQWO'#FkOOQO'#KO'#KOOOQO'#Ig'#IgO#J{Q&jO1G1kOOQ07b1G1k1G1kOOOS1G1v1G1vO#K^Q(CYO'#JiO#KhQWO,5<_O!*fQ^O,5<_OOOS-E<f-E<fOOQ07b1G1i1G1iO#KmQ`O'#J}OOQ07b,5<a,5<aO#KuQ`O,5<aOOQ07b,59e,59eO!&dQ7[O'#DPOOOO'#IZ'#IZO#KzO?MpO,59iOOQ07b,59i,59iO%[Q^O1G1|O!6[QWO'#IkO#LVQ7[O,5<uOOQ07b,5<r,5<rO!(SQ7[O'#InO#LuQ7[O,5=RO!(SQ7[O'#IpO#MhQ7[O,5=TO!&dQ7[O,5=VOOQO1G2O1G2OO#MrQpO'#CqO#NVQpO,5<nO#N^QWO'#KRO9aQWO'#KRO#NlQWO,5<pO!(SQ7[O,5<oO#NqQWO'#GUO#N|QWO,5<oO$ RQpO'#GRO$ `QpO'#KSO$ jQWO'#KSO!&dQ7[O'#KSO$ oQWO,5<sO$ tQ`O'#G^O!4eQ`O'#G^O$!VQWO'#G`O$![QWO'#GbO!3fQWO'#GeO$!aQ07hO'#ImO$!lQ`O,5<wOOQ07f,5<w,5<wO$!sQ`O'#G^O$#RQ`O'#G_O$#ZQ`O'#G_O$#`Q7[O,5=RO$#pQ7[O,5=TOOQ07b,5=W,5=WO!(SQ7[O,5?}O!(SQ7[O,5?}O$$QQWO'#IrO$$]QWO,5?|O$$eQWO,59`O$%UQ7[O,59qOOQ07b,59q,59qO$%wQ7[O,5<fO$&jQ7[O,5<hO@bQWO,5<jOOQ07b,5<k,5<kO$&tQWO,5<qO$&yQ7[O,5<vO$'ZQWO'#JuO!$aQ^O1G1}O$'`QWO1G1}O9ZQWO'#JxO9ZQWO'#EpO%[Q^O'#EpO9ZQWO'#ItO$'eQ07hO,5@rOOQU1G2w1G2wOOQU1G4X1G4XOOQ07b1G/w1G/wO!,iQWO1G/wO$)jQ08SO1G0TOOQU1G2s1G2sO!&dQ7[O1G2sO%[Q^O1G2sO#,^QWO1G2sO$+nQ7[O'#EgOOQ07`,5?{,5?{O$+xQ07hO,5?{OOQU1G.t1G.tO!@rQ07hO1G.tO!@}Q`O1G.tO!AVQ7[O1G.tO$,ZQWO1G0qO$,`QWO'#ChO$,kQWO'#K[O$,sQWO,5=uO$,xQWO'#K[O$,}QWO'#K[O$-]QWO'#IzO$-kQWO,5@uO$-sQrO1G1fOOQ07b1G1h1G1hO9aQWO1G3`O@bQWO1G3`O$-zQWO1G3`O$.PQWO1G3`OOQU1G3`1G3`O!CTQWO1G3OO!&dQ7[O1G2{O$.UQWO1G2{OOQU1G2|1G2|O!&dQ7[O1G2|O$.ZQWO1G2|O$.cQ`O'#GzOOQU1G3O1G3OO!4eQ`O'#IvO!CYQpO1G3ROOQU1G3R1G3ROOQU,5=l,5=lO$.kQ7[O,5=nO9aQWO,5=nO$![QWO,5=pO9UQWO,5=pO!@}Q`O,5=pO!AVQ7[O,5=pO:RQ7[O,5=pO$.yQWO'#KYO$/UQWO,5=qOOQU1G.j1G.jO$/ZQ07hO1G.jO@bQWO1G.jO$/fQWO1G.jO9kQ07hO1G.jO$1kQrO,5@wO$1{QWO,5@wO9ZQWO,5@wO$2WQ^O,5=xO$2_QWO,5=xOOQU1G3b1G3bO`Q^O1G3bOOQU1G3h1G3hOOQU1G3j1G3jO>kQWO1G3lO$2dQ^O1G3nO$6hQ^O'#HmOOQU1G3q1G3qO$6uQWO'#HsO>pQWO'#HuOOQU1G3w1G3wO$6}Q^O1G3wO9kQ07hO1G3}OOQU1G4P1G4POOQ07`'#GY'#GYO9kQ07hO1G4RO9kQ07hO1G4TO$;UQWO,5@XO!*fQ^O,5;[O9ZQWO,5;[O>pQWO,5:UO!*fQ^O,5:UO!@}Q`O,5:UO$;ZQ(CYO,5:UOOQO,5;[,5;[O$;eQ`O'#I^O$;{QWO,5@WOOQ07b1G/o1G/oO$<TQ`O'#IdO$<_QWO,5@fOOQ07`1G0u1G0uO# xQ`O,5:UOOQO'#Ia'#IaO$<gQ`O,5:pOOQ07f,5:p,5:pO#%sQWO1G0YOOQ07b1G0Y1G0YO%[Q^O1G0YOOQ07b1G0p1G0pO>pQWO1G0pO!@}Q`O1G0pO!AVQ7[O1G0pOOQ07`1G5s1G5sO!@rQ07hO1G0]OOQO1G0i1G0iO%[Q^O1G0iO$<nQ07hO1G0iO$<yQ07hO1G0iO!@}Q`O1G0]OCnQ`O1G0]O$=XQ07hO1G0iOOQO1G0]1G0]O$=mQ08SO1G0iPOOO-E<T-E<TPOOO1G.g1G.gOOOO1G/f1G/fO$=wQpO,5<eO$>PQrO1G4cOOQO1G4i1G4iO%[Q^O,5>wO$>ZQWO1G5qO$>cQWO1G6OO$>kQrO1G6PO9ZQWO,5>}O$>uQ08SO1G5|O%[Q^O1G5|O$?VQ07hO1G5|O$?hQWO1G5{O$?hQWO1G5{O9ZQWO1G5{O$?pQWO,5?QO9ZQWO,5?QOOQO,5?Q,5?QO$@UQWO,5?QO$'ZQWO,5?QOOQO-E<d-E<dOOQO1G0`1G0`OOQO1G0b1G0bO!,lQWO1G0bOOQU7+(_7+(_O!&dQ7[O7+(_O%[Q^O7+(_O$@dQWO7+(_O$@oQ7[O7+(_O$@}Q08SO,5=RO$CYQ08SO,5=TO$EeQ08SO,5=RO$GvQ08SO,5=TO$JXQ08SO,59qO$LaQ08SO,5<fO$NlQ08SO,5<hO%!wQ08SO,5<vOOQ07b7+&]7+&]O%%YQ08SO7+&]O%%|Q7[O'#I_O%&WQWO,5@YOOQ07b1G/y1G/yO%&`Q^O'#I`O%&mQWO,5@ZO%&uQrO,5@ZOOQ07b1G0O1G0OO%'PQWO7+&fOOQ07b7+&f7+&fO%'UQ(CYO,5:eO%[Q^O7+&xO%'`Q(CYO,5:]O%'mQ(CYO,5:iO%'wQ(CYO,5:kOOQ07b7+'O7+'OOOQO1G1o1G1oOOQO1G1p1G1pO%(RQtO,5<WO!*fQ^O,5<VOOQO-E<e-E<eOOQ07b7+'V7+'VOOOS7+'b7+'bOOOS1G1y1G1yO%(^QWO1G1yOOQ07b1G1{1G1{O%(cQpO,59kOOOO-E<X-E<XOOQ07b1G/T1G/TO%(jQ08SO7+'hOOQ07b,5?V,5?VO%)^QpO,5?VOOQ07b1G2a1G2aP!&dQ7[O'#IkPOQ07b-E<i-E<iO%)|Q7[O,5?YOOQ07b-E<l-E<lO%*oQ7[O,5?[OOQ07b-E<n-E<nO%*yQpO1G2qOOQ07b1G2Y1G2YO%+QQWO'#IjO%+`QWO,5@mO%+`QWO,5@mO%+hQWO,5@mO%+sQWO,5@mOOQO1G2[1G2[O%,RQ7[O1G2ZO!(SQ7[O1G2ZO%,cQ!LQO'#IlO%,sQWO,5@nO!&dQ7[O,5@nO%,{QpO,5@nOOQ07b1G2_1G2_OOQ07`,5<x,5<xOOQ07`,5<y,5<yO$'ZQWO,5<yOC_QWO,5<yO!@}Q`O,5<xOOQO'#Ga'#GaO%-VQWO,5<zOOQ07`,5<|,5<|O$'ZQWO,5=POOQO,5?X,5?XOOQO-E<k-E<kOOQ07f1G2c1G2cO!4eQ`O,5<xO%-_QWO,5<yO$!VQWO,5<zO!4eQ`O,5<yO!(SQ7[O'#InO%.RQ7[O1G2mO!(SQ7[O'#IpO%.tQ7[O1G2oO%/OQ7[O1G5iO%/YQ7[O1G5iOOQO,5?^,5?^OOQO-E<p-E<pOOQO1G.z1G.zO!7{Q`O,59sO%[Q^O,59sO%/gQWO1G2UO!(SQ7[O1G2]O%/lQ08SO7+'iOOQ07b7+'i7+'iO!$aQ^O7+'iO%0`QWO,5;[OOQ07`,5?`,5?`OOQ07`-E<r-E<rOOQ07b7+%c7+%cO%0eQpO'#KTO#%sQWO7+(_O%0oQrO7+(_O$@gQWO7+(_O%0vQ08QO'#ChO%1ZQ08QO,5<}O%1{QWO,5<}OOQ07`1G5g1G5gOOQU7+$`7+$`O!@rQ07hO7+$`O!@}Q`O7+$`O!$aQ^O7+&]O%2QQWO'#IyO%2iQWO,5@vOOQO1G3a1G3aO9aQWO,5@vO%2iQWO,5@vO%2qQWO,5@vOOQO,5?f,5?fOOQO-E<x-E<xOOQ07b7+'Q7+'QO%2vQWO7+(zO9kQ07hO7+(zO9aQWO7+(zO@bQWO7+(zOOQU7+(j7+(jO%2{Q08QO7+(gO!&dQ7[O7+(gO%3VQpO7+(hOOQU7+(h7+(hO!&dQ7[O7+(hO%3^QWO'#KXO%3iQWO,5=fOOQO,5?b,5?bOOQO-E<t-E<tOOQU7+(m7+(mO%4xQ`O'#HTOOQU1G3Y1G3YO!&dQ7[O1G3YO%[Q^O1G3YO%5PQWO1G3YO%5[Q7[O1G3YO9kQ07hO1G3[O$![QWO1G3[O9UQWO1G3[O!@}Q`O1G3[O!AVQ7[O1G3[O%5jQWO'#IxO%6OQWO,5@tO%6WQ`O,5@tOOQ07`1G3]1G3]OOQU7+$U7+$UO@bQWO7+$UO9kQ07hO7+$UO%6cQWO7+$UO%[Q^O1G6cO%[Q^O1G6dO%6hQ07hO1G6cO%6rQ^O1G3dO%6yQWO1G3dO%7OQ^O1G3dOOQU7+(|7+(|O9kQ07hO7+)WO`Q^O7+)YOOQU'#K_'#K_OOQU'#I{'#I{O%7VQ^O,5>XOOQU,5>X,5>XO%[Q^O'#HnO%7dQWO'#HpOOQU,5>_,5>_O9ZQWO,5>_OOQU,5>a,5>aOOQU7+)c7+)cOOQU7+)i7+)iOOQU7+)m7+)mOOQU7+)o7+)oO%7iQ`O1G5sO%7}Q(CYO1G0vO%8XQWO1G0vOOQO1G/p1G/pO%8dQ(CYO1G/pO>pQWO1G/pO!*fQ^O'#DjOOQO,5>x,5>xOOQO-E<[-E<[OOQO,5?O,5?OOOQO-E<b-E<bO!@}Q`O1G/pOOQO-E<_-E<_OOQ07f1G0[1G0[OOQ07b7+%t7+%tO#%sQWO7+%tOOQ07b7+&[7+&[O>pQWO7+&[O!@}Q`O7+&[OOQO7+%w7+%wO$=mQ08SO7+&TOOQO7+&T7+&TO%[Q^O7+&TO%8nQ07hO7+&TO!@rQ07hO7+%wO!@}Q`O7+%wO%8yQ07hO7+&TO%9XQ08SO7++hO%[Q^O7++hO%9iQWO7++gO%9iQWO7++gOOQO1G4l1G4lO9ZQWO1G4lO%9qQWO1G4lOOQO7+%|7+%|O#%sQWO<<KyO%0oQrO<<KyO%:PQWO<<KyOOQU<<Ky<<KyO!&dQ7[O<<KyO%[Q^O<<KyO%:XQWO<<KyO%:dQ08SO,5?YO%<oQ08SO,5?[O%>zQ08SO1G2ZO%A]Q08SO1G2mO%ChQ08SO1G2oO%EsQ7[O,5>yOOQO-E<]-E<]O%E}QrO,5>zO%[Q^O,5>zOOQO-E<^-E<^O%FXQWO1G5uOOQ07b<<JQ<<JQO%FaQ(CYO1G0qO%HkQ(CYO1G0{O%HrQ(CYO1G0{O%JvQ(CYO1G0{O%J}Q(CYO1G0{O%LrQ(CYO1G0{O%MYQ(CYO1G0{O& mQ(CYO1G0{O& tQ(CYO1G0{O&#rQ(CYO1G0{O&$PQ(CYO1G0{O&%}Q(CYO1G0{O&&bQ08SO<<JdO&'gQ(CYO1G0{O&)]Q(CYO'#JdO&+`Q(CYO1G1aO&+mQ(CYO1G0TO!*fQ^O'#FnOOQO'#KP'#KPOOQO1G1r1G1rO&+wQWO1G1qO&+|Q(CYO,5?TOOOS7+'e7+'eOOOO1G/V1G/VOOQ07b1G4q1G4qO!(SQ7[O7+(]O&,WQWO,5?UO9aQWO,5?UOOQO-E<h-E<hO&,fQWO1G6XO&,fQWO1G6XO&,nQWO1G6XO&,yQ7[O7+'uO&-ZQpO,5?WO&-eQWO,5?WO!&dQ7[O,5?WOOQO-E<j-E<jO&-jQpO1G6YO&-tQWO1G6YOOQ07`1G2e1G2eO$'ZQWO1G2eOOQ07`1G2d1G2dO&-|QWO1G2fO!&dQ7[O1G2fOOQ07`1G2k1G2kO!@}Q`O1G2dOC_QWO1G2eO&.RQWO1G2fO&.ZQWO1G2eO&.}Q7[O,5?YOOQ07b-E<m-E<mO&/pQ7[O,5?[OOQ07b-E<o-E<oO!(SQ7[O7++TOOQ07b1G/_1G/_O&/zQWO1G/_OOQ07b7+'p7+'pO&0PQ7[O7+'wO&0aQ08SO<<KTOOQ07b<<KT<<KTO&1TQWO1G0vO!&dQ7[O'#IsO&1YQWO,5@oO!&dQ7[O1G2iOOQU<<Gz<<GzO!@rQ07hO<<GzO&1bQ08SO<<IwOOQ07b<<Iw<<IwOOQO,5?e,5?eO&2UQWO,5?eO&2ZQWO,5?eOOQO-E<w-E<wO&2iQWO1G6bO&2iQWO1G6bO9aQWO1G6bO@bQWO<<LfOOQU<<Lf<<LfO&2qQWO<<LfO9kQ07hO<<LfOOQU<<LR<<LRO%2{Q08QO<<LROOQU<<LS<<LSO%3VQpO<<LSO&2vQ`O'#IuO&3RQWO,5@sO!*fQ^O,5@sOOQU1G3Q1G3QO&3ZQ^O'#JmOOQO'#Iw'#IwO9kQ07hO'#IwO&3eQ`O,5=oOOQU,5=o,5=oO&3lQ`O'#EcO&4QQWO7+(tO&4VQWO7+(tOOQU7+(t7+(tO!&dQ7[O7+(tO%[Q^O7+(tO&4_QWO7+(tOOQU7+(v7+(vO9kQ07hO7+(vO$![QWO7+(vO9UQWO7+(vO!@}Q`O7+(vO&4jQWO,5?dOOQO-E<v-E<vOOQO'#HW'#HWO&4uQWO1G6`O9kQ07hO<<GpOOQU<<Gp<<GpO@bQWO<<GpO&4}QWO7++}O&5SQWO7+,OO%[Q^O7++}O%[Q^O7+,OOOQU7+)O7+)OO&5XQWO7+)OO&5^Q^O7+)OO&5eQWO7+)OOOQU<<Lr<<LrOOQU<<Lt<<LtOOQU-E<y-E<yOOQU1G3s1G3sO&5jQWO,5>YOOQU,5>[,5>[O&5oQWO1G3yO9ZQWO7+&bO!*fQ^O7+&bOOQO7+%[7+%[O&5tQ(CYO1G6PO>pQWO7+%[OOQ07b<<I`<<I`OOQ07b<<Iv<<IvO>pQWO<<IvOOQO<<Io<<IoO$=mQ08SO<<IoO%[Q^O<<IoOOQO<<Ic<<IcO!@rQ07hO<<IcO&6OQ07hO<<IoO&6ZQ08SO<= SO&6kQWO<= ROOQO7+*W7+*WO9ZQWO7+*WOOQUANAeANAeO&6sQWOANAeO!&dQ7[OANAeO#%sQWOANAeO%0oQrOANAeO%[Q^OANAeO&6{Q08SO7+'uO&9^Q08SO,5?YO&;iQ08SO,5?[O&=tQ08SO7+'wO&@VQrO1G4fO&@aQ(CYO7+&]O&BeQ(CYO,5=RO&DlQ(CYO,5=TO&D|Q(CYO,5=RO&E^Q(CYO,5=TO&EnQ(CYO,59qO&GqQ(CYO,5<fO&ItQ(CYO,5<hO&KwQ(CYO,5<vO&MmQ(CYO7+'hO&MzQ(CYO7+'iO&NXQWO,5<YOOQO7+']7+']O&N^Q7[O<<KwOOQO1G4p1G4pO&NeQWO1G4pO&NpQWO1G4pO' OQWO7++sO' OQWO7++sO!&dQ7[O1G4rO' WQpO1G4rO' bQWO7++tOOQ07`7+(P7+(PO$'ZQWO7+(QO' jQpO7+(QOOQ07`7+(O7+(OO$'ZQWO7+(PO' qQWO7+(QO!&dQ7[O7+(QOC_QWO7+(PO' vQ7[O<<NoOOQ07b7+$y7+$yO'!QQpO,5?_OOQO-E<q-E<qO'![Q08QO7+(TOOQUAN=fAN=fO9aQWO1G5POOQO1G5P1G5PO'!lQWO1G5PO'!qQWO7++|O'!qQWO7++|O9kQ07hOANBQO@bQWOANBQOOQUANBQANBQOOQUANAmANAmOOQUANAnANAnO'!yQWO,5?aOOQO-E<s-E<sO'#UQ(CYO1G6_O'%fQrO'#ChOOQO,5?c,5?cOOQO-E<u-E<uOOQU1G3Z1G3ZO&3ZQ^O,5<zOOQU<<L`<<L`O!&dQ7[O<<L`O&4QQWO<<L`O'%pQWO<<L`O%[Q^O<<L`OOQU<<Lb<<LbO9kQ07hO<<LbO$![QWO<<LbO9UQWO<<LbO'%xQ`O1G5OO'&TQWO7++zOOQUAN=[AN=[O9kQ07hOAN=[OOQU<= i<= iOOQU<= j<= jO'&]QWO<= iO'&bQWO<= jOOQU<<Lj<<LjO'&gQWO<<LjO'&lQ^O<<LjOOQU1G3t1G3tO>pQWO7+)eO'&sQWO<<I|O''OQ(CYO<<I|OOQO<<Hv<<HvOOQ07bAN?bAN?bOOQOAN?ZAN?ZO$=mQ08SOAN?ZOOQOAN>}AN>}O%[Q^OAN?ZOOQO<<Mr<<MrOOQUG27PG27PO!&dQ7[OG27PO#%sQWOG27PO''YQWOG27PO%0oQrOG27PO''bQ(CYO<<JdO''oQ(CYO1G2ZO')eQ(CYO,5?YO'+hQ(CYO,5?[O'-kQ(CYO1G2mO'/nQ(CYO1G2oO'1qQ(CYO<<KTO'2OQ(CYO<<IwOOQO1G1t1G1tO!(SQ7[OANAcOOQO7+*[7+*[O'2]QWO7+*[O'2hQWO<= _O'2pQpO7+*^OOQ07`<<Kl<<KlO$'ZQWO<<KlOOQ07`<<Kk<<KkO'2zQpO<<KlO$'ZQWO<<KkOOQO7+*k7+*kO9aQWO7+*kO'3RQWO<= hOOQUG27lG27lO9kQ07hOG27lO!*fQ^O1G4{O'3ZQWO7++yO&4QQWOANAzOOQUANAzANAzO!&dQ7[OANAzO'3cQWOANAzOOQUANA|ANA|O9kQ07hOANA|O$![QWOANA|OOQO'#HX'#HXOOQO7+*j7+*jOOQUG22vG22vOOQUANETANETOOQUANEUANEUOOQUANBUANBUO'3kQWOANBUOOQU<<MP<<MPO!*fQ^OAN?hOOQOG24uG24uO$=mQ08SOG24uO#%sQWOLD,kOOQULD,kLD,kO!&dQ7[OLD,kO'3pQWOLD,kO'3xQ(CYO7+'uO'5nQ(CYO,5?YO'7qQ(CYO,5?[O'9tQ(CYO7+'wO';jQ7[OG26}OOQO<<Mv<<MvOOQ07`ANAWANAWO$'ZQWOANAWOOQ07`ANAVANAVOOQO<<NV<<NVOOQULD-WLD-WO';zQ(CYO7+*gOOQUG27fG27fO&4QQWOG27fO!&dQ7[OG27fOOQUG27hG27hO9kQ07hOG27hOOQUG27pG27pO'<UQ(CYOG25SOOQOLD*aLD*aOOQU!$(!V!$(!VO#%sQWO!$(!VO!&dQ7[O!$(!VO'<`Q08SOG26}OOQ07`G26rG26rOOQULD-QLD-QO&4QQWOLD-QOOQULD-SLD-SOOQU!)9Eq!)9EqO#%sQWO!)9EqOOQU!$(!l!$(!lOOQU!.K;]!.K;]O'>qQ(CYOG26}O!*fQ^O'#DyO1PQWO'#EWO'@gQrO'#JiO!*fQ^O'#DqO'@nQ^O'#D}O'@uQrO'#ChO'C]QrO'#ChO!*fQ^O'#EPO'CmQ^O,5;VO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O'#IiO'EpQWO,5<eO'ExQ7[O,5;aO'GcQ7[O,5;aO!*fQ^O,5;uO!&dQ7[O'#GgO'ExQ7[O'#GgO!&dQ7[O'#GiO'ExQ7[O'#GiO1SQWO'#DVO1SQWO'#DVO!&dQ7[O'#FzO'ExQ7[O'#FzO!&dQ7[O'#F|O'ExQ7[O'#F|O!&dQ7[O'#G[O'ExQ7[O'#G[O!*fQ^O,5:iO!*fQ^O,5@eO'CmQ^O1G0qO'GjQ(CYO'#ChO!*fQ^O1G1|O!&dQ7[O'#InO'ExQ7[O'#InO!&dQ7[O'#IpO'ExQ7[O'#IpO!&dQ7[O,5<oO'ExQ7[O,5<oO'CmQ^O1G1}O!*fQ^O7+&xO!&dQ7[O1G2ZO'ExQ7[O1G2ZO!&dQ7[O'#InO'ExQ7[O'#InO!&dQ7[O'#IpO'ExQ7[O'#IpO!&dQ7[O1G2]O'ExQ7[O1G2]O'CmQ^O7+'iO'CmQ^O7+&]O!&dQ7[OANAcO'ExQ7[OANAcO'GtQWO'#EkO'GyQWO'#EkO'HRQWO'#FZO'HWQWO'#EuO'H]QWO'#JyO'HhQWO'#JwO'HsQWO,5;VO'HxQ7[O,5<bO'IPQWO'#GTO'IUQWO'#GTO'IZQWO,5<cO'IcQWO,5;VO'IkQ(CYO1G1^O'IrQWO,5<oO'IwQWO,5<oO'I|QWO,5<qO'JRQWO,5<qO'JWQWO1G1}O'J]QWO1G0qO'JbQ7[O<<KwO'JiQ7[O<<KwO7hQ7[O'#FxO9UQWO'#FwOA]QWO'#EjO!*fQ^O,5;rO!3fQWO'#GTO!3fQWO'#GTO!3fQWO'#GVO!3fQWO'#GVO!(SQ7[O7+(]O!(SQ7[O7+(]O%*yQpO1G2qO%*yQpO1G2qO!&dQ7[O,5=VO!&dQ7[O,5=V",
  stateData: "'Km~O'tOS'uOSSOS'vRQ~OPYOQYORfOX!VO`qOczOdyOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![XO!fuO!kZO!nYO!oYO!pYO!rvO!twO!wxO!{]O#s!PO$T|O%b}O%d!QO%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO%s!UO&P!WO&V!XO&X!YO&Z!ZO&]![O&`!]O&f!^O&l!_O&n!`O&p!aO&r!bO&t!cO'{SO'}TO(QUO(XVO(g[O(tiO~OVtO~P`OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~O`!vOo!nO!P!oO!_!xO!`!uO!a!uO!{:dO#P!pO#Q!pO#R!wO#S!pO#T!pO#W!yO#X!yO'|!lO'}TO(QUO([!mO(g!sO~O'v!zO~OP[XZ[X`[Xn[X|[X}[X!P[X!Y[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X'r[X(X[X(h[X(o[X(p[X~O!d$|X~P(qO^!|O'}#OO(O!|O(P#OO~O^#PO(P#OO(Q#OO(R#PO~Ot#RO!R#SO(Y#SO(Z#UO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{:hO'}TO(QUO(XVO(g[O(tiO~O!X#YO!Y#VO!V(_P!V(lP~P+}O!Z#bO~P`OPYOQYORfOc!jOd!iOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'}TO(QUO(XVO(g[O(tiO~Ol#lO!X#hO!{]O#e#kO#f#hO'{:iO!j(iP~P.iO!k#nO'{#mO~O!w#rO!{]O%b#sO~O#g#tO~O!d#uO#g#tO~OP$]OZ$dOn$QO|#yO}#zO!P#{O!Y$aO!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O`(]X'r(]X'p(]X!j(]X!V(]X![(]X%c(]X!d(]X~P1qO#[$eO$O$eOP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#r(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X![(^X%c(^X~O`(^X!i(^X'r(^X'p(^X!V(^X!j(^Xr(^X!d(^X~P4XO#[$eO~O$Y$gO$[$fO$c$lO~ORfO![$mO$f$nO$h$pO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz%ZO!P${O![$|O!f%`O!k$xO#f%aO$T%^O$o%[O$q%]O$t%_O'{$rO'}TO(QUO(X$uO(o$}O(p%POf(UP~O!k%bO~O!P%eO![%fO'{%dO~O!d%jO~O`%kO'r%kO~O'|!lO~P%[O%h%rO~P%[Og%VO!k%bO'{%dO'|!lO~Od%yO!k%bO'{%dO~O#r$SO~O|&OO![%{O!k%}O%d&RO'{%dO'|!lO'}TO(QUO_(}P~O!w#rO~O%m&TO!P(yX![(yX'{(yX~O'{&UO~O!t&ZO#s!PO%d!QO%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO~Oc&`Od&_O!w&]O%b&^O%u&[O~P;xOc&cOdyO![&bO!t&ZO!wxO!{]O#s!PO%b}O%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO%s!UO~Oa&fO#[&iO%d&dO'|!lO~P<}O!k&jO!t&nO~O!k#nO~O![XO~O`%kO'q&vO'r%kO~O`%kO'q&yO'r%kO~O`%kO'q&{O'r%kO~O'p[X!V[Xr[X!j[X&T[X![[X%c[X!d[X~P(qO!_'YO!`'RO!a'RO'|!lO'}TO(QUO~Oo'PO!P'OO!X'SO([&}O!Z(`P!Z(nP~P@UOj']O!['ZO'{%dO~Od'bO!k%bO'{%dO~O|&OO!k%}O~Oo!nO!P!oO!{:dO#P!pO#Q!pO#S!pO#T!pO'|!lO'}TO(QUO([!mO(g!sO~O!_'hO!`'gO!a'gO#R!pO#W'iO#X'iO~PApO`%kOg%VO!d#uO!k%bO'r%kO(h'kO~O!o'oO#['mO~PCOOo!nO!P!oO'}TO(QUO([!mO(g!sO~O![XOo(eX!P(eX!_(eX!`(eX!a(eX!{(eX#P(eX#Q(eX#R(eX#S(eX#T(eX#W(eX#X(eX'|(eX'}(eX(Q(eX([(eX(g(eX~O!`'gO!a'gO'|!lO~PCnO'w'sO'x'sO'y'uO~O^!|O'}'wO(O!|O(P'wO~O^#PO(P'wO(Q'wO(R#PO~Ot#RO!R#SO(Y#SO(Z'{O~O!X'}O!V'PX!V'VX!Y'PX!Y'VX~P+}O!Y(PO!V(_X~OP$]OZ$dOn$QO|#yO}#zO!P#{O!Y(PO!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O!V(_X~PGbO!V(UO~O!V(kX!Y(kX!d(kX!j(kX(h(kX~O#[(kX#g#`X!Z(kX~PIhO#[(VO!V(mX!Y(mX~O!Y(WO!V(lX~O!V(ZO~O#[$eO~PIhO!Z([O~P`O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!maZ!man!ma!Y!ma!h!ma!o!ma#j!ma#k!ma#l!ma#m!ma#n!ma#o!ma#p!ma#q!ma#r!ma#t!ma#v!ma#x!ma#y!ma(h!ma(o!ma(p!ma~O`!ma'r!ma'p!ma!V!ma!j!mar!ma![!ma%c!ma!d!ma~PKOO!j(]O~O!d#uO#[(^O(h'kO!Y(jX`(jX'r(jX~O!j(jX~PMnO!P%eO![%fO!{]O#e(cO#f(bO'{%dO~O!Y(dO!j(iX~O!j(fO~O!P%eO![%fO#f(bO'{%dO~OP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!i(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#r(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X~O!d#uO!j(^X~P! [O|(gO}(hO!i#wO!k#xO!{!za!P!za~O!w!za%b!za![!za#e!za#f!za'{!za~P!#`O!w(lO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![XO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~O#g(rO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz%ZO!P${O![$|O!f%`O!k$xO#f%aO$T%^O$o%[O$q%]O$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~Of(bP~P!(SO!X(vO!j(cP~P%[O([(xO(g[O~O!P(zO!k#xO([(xO(g[O~OP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![!eO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'{)YO'}TO(QUO(XVO(g[O(t<YO~O})]O!k#xO~O!Y$aO`$ma'r$ma'p$ma!j$ma!V$ma![$ma%c$ma!d$ma~O#s)aO~P!&dO|)dO!d)cO![$ZX$W$ZX$Y$ZX$[$ZX$c$ZX~O!d)cO![(qX$W(qX$Y(qX$[(qX$c(qX~O|)dO~P!.OO|)dO![(qX$W(qX$Y(qX$[(qX$c(qX~O![)fO$W)jO$Y)eO$[)eO$c)kO~O!X)nO~P!*fO$Y$gO$[$fO$c)rO~Oj$uX|$uX!P$uX!i$uX(o$uX(p$uX~OfiXf$uXjiX!YiX#[iX~P!/tOo)tO~Ot)uO(Y)vO(Z)xO~Oj*RO|)zO!P){O(o$}O(p%PO~Of)yO~P!0}Of*SO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'}TO(QUO(X$uO(o$}O(p%PO~O!X*WO'{*TO!j(uP~P!1lO#g*YO~O!k*ZO~O!X*`O'{*]O!V(vP~P!1lOn*lO!P*dO!_*jO!`*cO!a*cO!k*ZO#W*kO%Y*fO'|!lO([!mO~O!Z*iO~P!3xO!i#wOj(WX|(WX!P(WX(o(WX(p(WX!Y(WX#[(WX~Of(WX#|(WX~P!4qOj*qO#[*pOf(VX!Y(VX~O!Y*rOf(UX~O'{&UOf(UP~O!k*yO~O'{(pO~Ol*}O!P%eO!X#hO![%fO!{]O#e#kO#f#hO'{%dO!j(iP~O!d#uO#g+OO~O!P%eO!X+QO!Y(WO![%fO'{%dO!V(lP~Oo'VO!P+SO!X+RO'}TO(QUO([(xO~O!Z(nP~P!7lO!Y+TO`(zX'r(zX~OP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O`!ea!Y!ea'r!ea'p!ea!V!ea!j!ear!ea![!ea%c!ea!d!ea~P!8dO|#yO}#zO!P#{O!i#wO!k#xO(XVOP!qaZ!qan!qa!Y!qa!h!qa!o!qa#j!qa#k!qa#l!qa#m!qa#n!qa#o!qa#p!qa#q!qa#r!qa#t!qa#v!qa#x!qa#y!qa(h!qa(o!qa(p!qa~O`!qa'r!qa'p!qa!V!qa!j!qar!qa![!qa%c!qa!d!qa~P!:}O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!saZ!san!sa!Y!sa!h!sa!o!sa#j!sa#k!sa#l!sa#m!sa#n!sa#o!sa#p!sa#q!sa#r!sa#t!sa#v!sa#x!sa#y!sa(h!sa(o!sa(p!sa~O`!sa'r!sa'p!sa!V!sa!j!sar!sa![!sa%c!sa!d!sa~P!=hOg%VOj+^O!['ZO%c+]O~O!d+`O`(TX![(TX'r(TX!Y(TX~O`%kO![XO'r%kO~Og%VO!k%bO~Og%VO!k%bO'{%dO~O!d#uO#g(rO~Oa+kO%d+lO'{+hO'}TO(QUO!Z)OP~O!Y+mO_(}X~OZ+qO~O_+rO~O![%{O'{%dO'|!lO_(}P~Og%VO#[+wO~Og%VOj+zO![$|O~O![+|O~O|,OO![XO~O%h%rO~O!w,TO~Od,YO~Oa,ZO'{#mO'}TO(QUO!Z(|P~Od%yO~O%d!QO'{&UO~P<}OZ,`O_,_O~OPYOQYORfOczOdyOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO!fuO!kZO!nYO!oYO!pYO!rvO!wxO!{]O%b}O'}TO(QUO(XVO(g[O(tiO~O![!eO!t!gO$T!kO'{!dO~P!DkO_,_O`%kO'r%kO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~O`,eO!twO#s!OO%f!OO%g!OO%h!OO~P!GTO!k&jO~O&V,kO~O![,mO~O&h,oO&j,pOP&eaQ&eaR&eaX&ea`&eac&ead&eal&ean&eao&eap&eav&eax&eaz&ea!P&ea!T&ea!U&ea![&ea!f&ea!k&ea!n&ea!o&ea!p&ea!r&ea!t&ea!w&ea!{&ea#s&ea$T&ea%b&ea%d&ea%f&ea%g&ea%h&ea%k&ea%m&ea%p&ea%q&ea%s&ea&P&ea&V&ea&X&ea&Z&ea&]&ea&`&ea&f&ea&l&ea&n&ea&p&ea&r&ea&t&ea'p&ea'{&ea'}&ea(Q&ea(X&ea(g&ea(t&ea!Z&ea&^&eaa&ea&c&ea~O'{,uO~Og!bX!Y!OX!Y!bX!Z!OX!Z!bX!d!OX!d!bX!k!bX#[!OX~O!d,zO#[,yOg(aX!Y#dX!Y(aX!Z#dX!Z(aX!d(aX!k(aX~Og%VO!d,|O!k%bO!Y!^X!Z!^X~Oo!nO!P!oO'}TO(QUO([!mO~OP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![!eO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'}TO(QUO(XVO(g[O(t<YO~O'{;]O~P#!ZO!Y-QO!Z(`X~O!Z-SO~O!d,zO#[,yO!Y#dX!Z#dX~O!Y-TO!Z(nX~O!Z-VO~O!`-WO!a-WO'|!lO~P# xO!Z-ZO~P'_Oj-^O!['ZO~O!V-cO~Oo!za!_!za!`!za!a!za#P!za#Q!za#R!za#S!za#T!za#W!za#X!za'|!za'}!za(Q!za([!za(g!za~P!#`O!o-hO#[-fO~PCOO!`-jO!a-jO'|!lO~PCnO`%kO#[-fO'r%kO~O`%kO!d#uO#[-fO'r%kO~O`%kO!d#uO!o-hO#[-fO'r%kO(h'kO~O'w'sO'x'sO'y-oO~Or-pO~O!V'Pa!Y'Pa~P!8dO!X-tO!V'PX!Y'PX~P%[O!Y(PO!V(_a~O!V(_a~PGbO!Y(WO!V(la~O!P%eO!X-xO![%fO'{%dO!V'VX!Y'VX~O#[-zO!Y(ja!j(ja`(ja'r(ja~O!d#uO~P#*aO!Y(dO!j(ia~O!P%eO![%fO#f.OO'{%dO~Ol.TO!P%eO!X.QO![%fO!{]O#e.SO#f.QO'{%dO!Y'YX!j'YX~O}.XO!k#xO~Og%VOj.[O!['ZO%c.ZO~O`#_i!Y#_i'r#_i'p#_i!V#_i!j#_ir#_i![#_i%c#_i!d#_i~P!8dOj<fO|)zO!P){O(o$}O(p%PO~O#g#Za`#Za#[#Za'r#Za!Y#Za!j#Za![#Za!V#Za~P#-]O#g(WXP(WXZ(WX`(WXn(WX}(WX!h(WX!k(WX!o(WX#j(WX#k(WX#l(WX#m(WX#n(WX#o(WX#p(WX#q(WX#r(WX#t(WX#v(WX#x(WX#y(WX'r(WX(X(WX(h(WX!j(WX!V(WX'p(WXr(WX![(WX%c(WX!d(WX~P!4qO!Y.iOf(bX~P!0}Of.kO~O!Y.lO!j(cX~P!8dO!j.oO~O!V.qO~OP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O(XVOZ#ii`#iin#ii!Y#ii!h#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O#j#ii~P#1XO#j$OO~P#1XOP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO(XVOZ#ii`#ii!Y#ii!h#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~On#ii~P#3yOn$QO~P#3yOP$]On$QO|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO(XVO`#ii!Y#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~OZ#ii!h#ii#o#ii#p#ii#q#ii#r#ii~P#6kOZ$dO!h$SO#o$SO#p$SO#q$cO#r$SO~P#6kOP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO(XVO(p#}O`#ii!Y#ii#x#ii#y#ii'r#ii(h#ii(o#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O#v$VO~P#9lO#v#ii~P#9lOP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO(XVO`#ii!Y#ii#x#ii#y#ii'r#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O#v#ii(o#ii(p#ii~P#<^O#v$VO(o#|O(p#}O~P#<^OP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO(XVO(o#|O(p#}O~O`#ii!Y#ii#y#ii'r#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~P#?UOP[XZ[Xn[X|[X}[X!P[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X!Y[X!Z[X~O#|[X~P#AoOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO#v:sO#x:uO#y:vO(XVO(h$ZO(o#|O(p#}O~O#|.sO~P#C|O#[:{O$O:{O#|(^X!Z(^X~P! [O`']a!Y']a'r']a'p']a!j']a!V']ar']a![']a%c']a!d']a~P!8dOP#iiZ#ii`#iin#ii}#ii!Y#ii!h#ii!i#ii!k#ii!o#ii#j#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(X#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~P#-]O`#}i!Y#}i'r#}i'p#}i!V#}i!j#}ir#}i![#}i%c#}i!d#}i~P!8dO$Y.xO$[.xO~O$Y.yO$[.yO~O!d)cO#[.zO![$`X$W$`X$Y$`X$[$`X$c$`X~O!X.{O~O![)fO$W.}O$Y)eO$[)eO$c/OO~O!Y:wO!Z(]X~P#C|O!Z/PO~O!d)cO$c(qX~O$c/RO~Ot)uO(Y)vO(Z/UO~O!V/YO~P!&dO(o$}Oj%Za|%Za!P%Za(p%Za!Y%Za#[%Za~Of%Za#|%Za~P#L^O(p%POj%]a|%]a!P%]a(o%]a!Y%]a#[%]a~Of%]a#|%]a~P#MPO!YeX!deX!jeX!j$uX(heX~P!/tO!j/bO~P#-]O!Y/cO!d#uO(h'kO!j(uX~O!j/hO~O!X*WO'{%dO!j(uP~O#g/jO~O!V$uX!Y$uX!d$|X~P!/tO!Y/kO!V(vX~P#-]O!d/mO~O!V/oO~Og%VOn/sO!d#uO!k%bO(h'kO~O'{/uO~O!d+`O~O`%kO!Y/yO'r%kO~O!Z/{O~P!3xO!`/|O!a/|O'|!lO([!mO~O!P0OO([!mO~O#W0PO~Of%Za!Y%Za#[%Za#|%Za~P!0}Of%]a!Y%]a#[%]a#|%]a~P!0}O'{&UOf'fX!Y'fX~O!Y*rOf(Ua~Of0YO~O|0ZO}0ZO!P0[Ojya(oya(pya!Yya#[ya~Ofya#|ya~P$$jO|)zO!P){Oj$na(o$na(p$na!Y$na#[$na~Of$na#|$na~P$%`O|)zO!P){Oj$pa(o$pa(p$pa!Y$pa#[$pa~Of$pa#|$pa~P$&RO#g0^O~Of%Oa!Y%Oa#[%Oa#|%Oa~P!0}O!d#uO~O#g0aO~O!Y+TO`(za'r(za~O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!qiZ!qin!qi!Y!qi!h!qi!o!qi#j!qi#k!qi#l!qi#m!qi#n!qi#o!qi#p!qi#q!qi#r!qi#t!qi#v!qi#x!qi#y!qi(h!qi(o!qi(p!qi~O`!qi'r!qi'p!qi!V!qi!j!qir!qi![!qi%c!qi!d!qi~P$'pOg%VOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'}TO(QUO(X$uO(o$}O(p%PO~Ol0kO'{0jO~P$*ZO!d+`O`(Ta![(Ta'r(Ta!Y(Ta~O#g0qO~OZ[X!YeX!ZeX~O!Y0rO!Z)OX~O!Z0tO~OZ0uO~Oa0wO'{+hO'}TO(QUO~O![%{O'{%dO_'nX!Y'nX~O!Y+mO_(}a~O!j0zO~P!8dOZ0}O~O_1OO~O#[1RO~Oj1UO![$|O~O([(xO!Z({P~Og%VOj1_O![1[O%c1^O~OZ1iO!Y1gO!Z(|X~O!Z1jO~O_1lO`%kO'r%kO~O'{#mO'}TO(QUO~O#[$eO$O$eOP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X~O#r1oO&T1pO`(^X!i(^X~P$/qO#[$eO#r1oO&T1pO~O`1rO~P%[O`1tO~O&^1wOP&[iQ&[iR&[iX&[i`&[ic&[id&[il&[in&[io&[ip&[iv&[ix&[iz&[i!P&[i!T&[i!U&[i![&[i!f&[i!k&[i!n&[i!o&[i!p&[i!r&[i!t&[i!w&[i!{&[i#s&[i$T&[i%b&[i%d&[i%f&[i%g&[i%h&[i%k&[i%m&[i%p&[i%q&[i%s&[i&P&[i&V&[i&X&[i&Z&[i&]&[i&`&[i&f&[i&l&[i&n&[i&p&[i&r&[i&t&[i'p&[i'{&[i'}&[i(Q&[i(X&[i(g&[i(t&[i!Z&[ia&[i&c&[i~Oa1}O!Z1{O&c1|O~P`O![XO!k2PO~O&j,pOP&eiQ&eiR&eiX&ei`&eic&eid&eil&ein&eio&eip&eiv&eix&eiz&ei!P&ei!T&ei!U&ei![&ei!f&ei!k&ei!n&ei!o&ei!p&ei!r&ei!t&ei!w&ei!{&ei#s&ei$T&ei%b&ei%d&ei%f&ei%g&ei%h&ei%k&ei%m&ei%p&ei%q&ei%s&ei&P&ei&V&ei&X&ei&Z&ei&]&ei&`&ei&f&ei&l&ei&n&ei&p&ei&r&ei&t&ei'p&ei'{&ei'}&ei(Q&ei(X&ei(g&ei(t&ei!Z&ei&^&eia&ei&c&ei~O!V2VO~O!Y!^a!Z!^a~P#C|Oo!nO!P!oO!X2]O([!mO!Y'QX!Z'QX~P@UO!Y-QO!Z(`a~O!Y'WX!Z'WX~P!7lO!Y-TO!Z(na~O!Z2dO~P'_O`%kO#[2mO'r%kO~O`%kO!d#uO#[2mO'r%kO~O`%kO!d#uO!o2qO#[2mO'r%kO(h'kO~O`%kO'r%kO~P!8dO!Y$aOr$ma~O!V'Pi!Y'Pi~P!8dO!Y(PO!V(_i~O!Y(WO!V(li~O!V(mi!Y(mi~P!8dO!Y(ji!j(ji`(ji'r(ji~P!8dO#[2sO!Y(ji!j(ji`(ji'r(ji~O!Y(dO!j(ii~O!P%eO![%fO!{]O#e2xO#f2wO'{%dO~O!P%eO![%fO#f2wO'{%dO~Oj3PO!['ZO%c3OO~Og%VOj3PO!['ZO%c3OO~O#g%ZaP%ZaZ%Za`%Zan%Za}%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za'r%Za(X%Za(h%Za!j%Za!V%Za'p%Zar%Za![%Za%c%Za!d%Za~P#L^O#g%]aP%]aZ%]a`%]an%]a}%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a'r%]a(X%]a(h%]a!j%]a!V%]a'p%]ar%]a![%]a%c%]a!d%]a~P#MPO#g%ZaP%ZaZ%Za`%Zan%Za}%Za!Y%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za'r%Za(X%Za(h%Za!j%Za!V%Za'p%Za#[%Zar%Za![%Za%c%Za!d%Za~P#-]O#g%]aP%]aZ%]a`%]an%]a}%]a!Y%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a'r%]a(X%]a(h%]a!j%]a!V%]a'p%]a#[%]ar%]a![%]a%c%]a!d%]a~P#-]O#gyaPyaZya`yanya!hya!iya!kya!oya#jya#kya#lya#mya#nya#oya#pya#qya#rya#tya#vya#xya#yya'rya(Xya(hya!jya!Vya'pyarya![ya%cya!dya~P$$jO#g$naP$naZ$na`$nan$na}$na!h$na!i$na!k$na!o$na#j$na#k$na#l$na#m$na#n$na#o$na#p$na#q$na#r$na#t$na#v$na#x$na#y$na'r$na(X$na(h$na!j$na!V$na'p$nar$na![$na%c$na!d$na~P$%`O#g$paP$paZ$pa`$pan$pa}$pa!h$pa!i$pa!k$pa!o$pa#j$pa#k$pa#l$pa#m$pa#n$pa#o$pa#p$pa#q$pa#r$pa#t$pa#v$pa#x$pa#y$pa'r$pa(X$pa(h$pa!j$pa!V$pa'p$par$pa![$pa%c$pa!d$pa~P$&RO#g%OaP%OaZ%Oa`%Oan%Oa}%Oa!Y%Oa!h%Oa!i%Oa!k%Oa!o%Oa#j%Oa#k%Oa#l%Oa#m%Oa#n%Oa#o%Oa#p%Oa#q%Oa#r%Oa#t%Oa#v%Oa#x%Oa#y%Oa'r%Oa(X%Oa(h%Oa!j%Oa!V%Oa'p%Oa#[%Oar%Oa![%Oa%c%Oa!d%Oa~P#-]O`#_q!Y#_q'r#_q'p#_q!V#_q!j#_qr#_q![#_q%c#_q!d#_q~P!8dOf'RX!Y'RX~P!(SO!Y.iOf(ba~O!X3ZO!Y'SX!j'SX~P%[O!Y.lO!j(ca~O!Y.lO!j(ca~P!8dO!V3^O~O#|!ma!Z!ma~PKOO#|!ea!Y!ea!Z!ea~P#C|O#|!qa!Z!qa~P!:}O#|!sa!Z!sa~P!=hORfO![3pO$a3qO~O!Z3uO~Or3vO~P#-]O`$jq!Y$jq'r$jq'p$jq!V$jq!j$jqr$jq![$jq%c$jq!d$jq~P!8dO!V3wO~P#-]O|)zO!P){O(p%POj'ba(o'ba!Y'ba#['ba~Of'ba#|'ba~P%)eO|)zO!P){Oj'da(o'da(p'da!Y'da#['da~Of'da#|'da~P%*WO(h$ZO~P#-]O!X3zO'{%dO!Y'^X!j'^X~O!Y/cO!j(ua~O!Y/cO!d#uO!j(ua~O!Y/cO!d#uO(h'kO!j(ua~Of$wi!Y$wi#[$wi#|$wi~P!0}O!X4SO'{*]O!V'`X!Y'`X~P!1lO!Y/kO!V(va~O!Y/kO!V(va~P#-]O!d#uO#r4[O~On4_O!d#uO(h'kO~O(o$}Oj%Zi|%Zi!P%Zi(p%Zi!Y%Zi#[%Zi~Of%Zi#|%Zi~P%-jO(p%POj%]i|%]i!P%]i(o%]i!Y%]i#[%]i~Of%]i#|%]i~P%.]Of(Vi!Y(Vi~P!0}O#[4fOf(Vi!Y(Vi~P!0}O!j4iO~O`$kq!Y$kq'r$kq'p$kq!V$kq!j$kqr$kq![$kq%c$kq!d$kq~P!8dO!V4mO~O!Y4nO![(wX~P#-]O!i#wO~P4XO`$uX![$uX%W[X'r$uX!Y$uX~P!/tO%W4pO`kXjkX|kX!PkX![kX'rkX(okX(pkX!YkX~O%W4pO~Oa4vO%d4wO'{+hO'}TO(QUO!Y'mX!Z'mX~O!Y0rO!Z)Oa~OZ4{O~O_4|O~O`%kO'r%kO~P#-]O![$|O~P#-]O!Y5UO#[5WO!Z({X~O!Z5XO~Oo!nO!P5YO!_!xO!`!uO!a!uO!{:dO#P!pO#Q!pO#R!pO#S!pO#T!pO#W5_O#X!yO'|!lO'}TO(QUO([!mO(g!sO~O!Z5^O~P%3nOj5dO![1[O%c5cO~Og%VOj5dO![1[O%c5cO~Oa5kO'{#mO'}TO(QUO!Y'lX!Z'lX~O!Y1gO!Z(|a~O'}TO(QUO([5mO~O_5qO~O#r5tO&T5uO~PMnO!j5vO~P%[O`5xO~O`5xO~P%[Oa1}O!Z5}O&c1|O~P`O!d6PO~O!d6ROg(ai!Y(ai!Z(ai!d(ai!k(ai~O!Y#di!Z#di~P#C|O#[6SO!Y#di!Z#di~O!Y!^i!Z!^i~P#C|O`%kO#[6]O'r%kO~O`%kO!d#uO#[6]O'r%kO~O!Y(jq!j(jq`(jq'r(jq~P!8dO!Y(dO!j(iq~O!P%eO![%fO#f6dO'{%dO~O!['ZO%c6gO~Oj6jO!['ZO%c6gO~O#g'baP'baZ'ba`'ban'ba}'ba!h'ba!i'ba!k'ba!o'ba#j'ba#k'ba#l'ba#m'ba#n'ba#o'ba#p'ba#q'ba#r'ba#t'ba#v'ba#x'ba#y'ba'r'ba(X'ba(h'ba!j'ba!V'ba'p'bar'ba!['ba%c'ba!d'ba~P%)eO#g'daP'daZ'da`'dan'da}'da!h'da!i'da!k'da!o'da#j'da#k'da#l'da#m'da#n'da#o'da#p'da#q'da#r'da#t'da#v'da#x'da#y'da'r'da(X'da(h'da!j'da!V'da'p'dar'da!['da%c'da!d'da~P%*WO#g$wiP$wiZ$wi`$win$wi}$wi!Y$wi!h$wi!i$wi!k$wi!o$wi#j$wi#k$wi#l$wi#m$wi#n$wi#o$wi#p$wi#q$wi#r$wi#t$wi#v$wi#x$wi#y$wi'r$wi(X$wi(h$wi!j$wi!V$wi'p$wi#[$wir$wi![$wi%c$wi!d$wi~P#-]O#g%ZiP%ZiZ%Zi`%Zin%Zi}%Zi!h%Zi!i%Zi!k%Zi!o%Zi#j%Zi#k%Zi#l%Zi#m%Zi#n%Zi#o%Zi#p%Zi#q%Zi#r%Zi#t%Zi#v%Zi#x%Zi#y%Zi'r%Zi(X%Zi(h%Zi!j%Zi!V%Zi'p%Zir%Zi![%Zi%c%Zi!d%Zi~P%-jO#g%]iP%]iZ%]i`%]in%]i}%]i!h%]i!i%]i!k%]i!o%]i#j%]i#k%]i#l%]i#m%]i#n%]i#o%]i#p%]i#q%]i#r%]i#t%]i#v%]i#x%]i#y%]i'r%]i(X%]i(h%]i!j%]i!V%]i'p%]ir%]i![%]i%c%]i!d%]i~P%.]Of'Ra!Y'Ra~P!0}O!Y'Sa!j'Sa~P!8dO!Y.lO!j(ci~O#|#_i!Y#_i!Z#_i~P#C|OP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O(XVOZ#iin#ii!h#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~O#j#ii~P%FnO#j:lO~P%FnOP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO(XVOZ#ii!h#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~On#ii~P%HyOn:nO~P%HyOP$]On:nO|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO(XVO#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~OZ#ii!h#ii#o#ii#p#ii#q#ii#r#ii~P%KUOZ:zO!h:pO#o:pO#p:pO#q:yO#r:pO~P%KUOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO(XVO(p#}O#x#ii#y#ii#|#ii(h#ii(o#ii!Y#ii!Z#ii~O#v:sO~P%MpO#v#ii~P%MpOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO(XVO#x#ii#y#ii#|#ii(h#ii!Y#ii!Z#ii~O#v#ii(o#ii(p#ii~P& {O#v:sO(o#|O(p#}O~P& {OP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO#v:sO#x:uO(XVO(o#|O(p#}O~O#y#ii#|#ii(h#ii!Y#ii!Z#ii~P&$^O`#zy!Y#zy'r#zy'p#zy!V#zy!j#zyr#zy![#zy%c#zy!d#zy~P!8dOj<gO|)zO!P){O(o$}O(p%PO~OP#iiZ#iin#ii}#ii!h#ii!i#ii!k#ii!o#ii#j#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(X#ii(h#ii!Y#ii!Z#ii~P&'UO!i#wOP(WXZ(WXj(WXn(WX|(WX}(WX!P(WX!h(WX!k(WX!o(WX#j(WX#k(WX#l(WX#m(WX#n(WX#o(WX#p(WX#q(WX#r(WX#t(WX#v(WX#x(WX#y(WX#|(WX(X(WX(h(WX(o(WX(p(WX!Y(WX!Z(WX~O#|#}i!Y#}i!Z#}i~P#C|O#|!qi!Z!qi~P$'pO!Z6|O~O!Y']a!Z']a~P#C|O!d#uO(h'kO!Y'^a!j'^a~O!Y/cO!j(ui~O!Y/cO!d#uO!j(ui~Of$wq!Y$wq#[$wq#|$wq~P!0}O!V'`a!Y'`a~P#-]O!d7TO~O!Y/kO!V(vi~P#-]O!Y/kO!V(vi~O!V7XO~O!d#uO#r7^O~On7_O!d#uO(h'kO~O|)zO!P){O(p%POj'ca(o'ca!Y'ca#['ca~Of'ca#|'ca~P&.fO|)zO!P){Oj'ea(o'ea(p'ea!Y'ea#['ea~Of'ea#|'ea~P&/XO!V7aO~Of$yq!Y$yq#[$yq#|$yq~P!0}O`$ky!Y$ky'r$ky'p$ky!V$ky!j$kyr$ky![$ky%c$ky!d$ky~P!8dO!d6RO~O!Y4nO![(wa~O`#_y!Y#_y'r#_y'p#_y!V#_y!j#_yr#_y![#_y%c#_y!d#_y~P!8dOZ7fO~Oa7hO'{+hO'}TO(QUO~O!Y0rO!Z)Oi~O_7lO~O([(xO!Y'iX!Z'iX~O!Y5UO!Z({a~OlkO'{7sO~P.iO!Z7vO~P%3nOo!nO!P7wO'}TO(QUO([!mO(g!sO~O![1[O~O![1[O%c7yO~Oj7|O![1[O%c7yO~OZ8RO!Y'la!Z'la~O!Y1gO!Z(|i~O!j8VO~O!j8WO~O!j8ZO~O!j8ZO~P%[O`8]O~O!d8^O~O!j8_O~O!Y(mi!Z(mi~P#C|O`%kO#[8gO'r%kO~O!Y(jy!j(jy`(jy'r(jy~P!8dO!Y(dO!j(iy~O!['ZO%c8jO~O#g$wqP$wqZ$wq`$wqn$wq}$wq!Y$wq!h$wq!i$wq!k$wq!o$wq#j$wq#k$wq#l$wq#m$wq#n$wq#o$wq#p$wq#q$wq#r$wq#t$wq#v$wq#x$wq#y$wq'r$wq(X$wq(h$wq!j$wq!V$wq'p$wq#[$wqr$wq![$wq%c$wq!d$wq~P#-]O#g'caP'caZ'ca`'can'ca}'ca!h'ca!i'ca!k'ca!o'ca#j'ca#k'ca#l'ca#m'ca#n'ca#o'ca#p'ca#q'ca#r'ca#t'ca#v'ca#x'ca#y'ca'r'ca(X'ca(h'ca!j'ca!V'ca'p'car'ca!['ca%c'ca!d'ca~P&.fO#g'eaP'eaZ'ea`'ean'ea}'ea!h'ea!i'ea!k'ea!o'ea#j'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#t'ea#v'ea#x'ea#y'ea'r'ea(X'ea(h'ea!j'ea!V'ea'p'ear'ea!['ea%c'ea!d'ea~P&/XO#g$yqP$yqZ$yq`$yqn$yq}$yq!Y$yq!h$yq!i$yq!k$yq!o$yq#j$yq#k$yq#l$yq#m$yq#n$yq#o$yq#p$yq#q$yq#r$yq#t$yq#v$yq#x$yq#y$yq'r$yq(X$yq(h$yq!j$yq!V$yq'p$yq#[$yqr$yq![$yq%c$yq!d$yq~P#-]O!Y'Si!j'Si~P!8dO#|#_q!Y#_q!Z#_q~P#C|O(o$}OP%ZaZ%Zan%Za}%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za#|%Za(X%Za(h%Za!Y%Za!Z%Za~Oj%Za|%Za!P%Za(p%Za~P&@nO(p%POP%]aZ%]an%]a}%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a#|%]a(X%]a(h%]a!Y%]a!Z%]a~Oj%]a|%]a!P%]a(o%]a~P&BuOj<gO|)zO!P){O(p%PO~P&@nOj<gO|)zO!P){O(o$}O~P&BuO|0ZO}0ZO!P0[OPyaZyajyanya!hya!iya!kya!oya#jya#kya#lya#mya#nya#oya#pya#qya#rya#tya#vya#xya#yya#|ya(Xya(hya(oya(pya!Yya!Zya~O|)zO!P){OP$naZ$naj$nan$na}$na!h$na!i$na!k$na!o$na#j$na#k$na#l$na#m$na#n$na#o$na#p$na#q$na#r$na#t$na#v$na#x$na#y$na#|$na(X$na(h$na(o$na(p$na!Y$na!Z$na~O|)zO!P){OP$paZ$paj$pan$pa}$pa!h$pa!i$pa!k$pa!o$pa#j$pa#k$pa#l$pa#m$pa#n$pa#o$pa#p$pa#q$pa#r$pa#t$pa#v$pa#x$pa#y$pa#|$pa(X$pa(h$pa(o$pa(p$pa!Y$pa!Z$pa~OP%OaZ%Oan%Oa}%Oa!h%Oa!i%Oa!k%Oa!o%Oa#j%Oa#k%Oa#l%Oa#m%Oa#n%Oa#o%Oa#p%Oa#q%Oa#r%Oa#t%Oa#v%Oa#x%Oa#y%Oa#|%Oa(X%Oa(h%Oa!Y%Oa!Z%Oa~P&'UO#|$jq!Y$jq!Z$jq~P#C|O#|$kq!Y$kq!Z$kq~P#C|O!Z8vO~O#|8wO~P!0}O!d#uO!Y'^i!j'^i~O!d#uO(h'kO!Y'^i!j'^i~O!Y/cO!j(uq~O!V'`i!Y'`i~P#-]O!Y/kO!V(vq~O!V8}O~P#-]O!V8}O~Of(Vy!Y(Vy~P!0}O!Y'ga!['ga~P#-]O`%Vq![%Vq'r%Vq!Y%Vq~P#-]OZ9SO~O!Y0rO!Z)Oq~O#[9WO!Y'ia!Z'ia~O!Y5UO!Z({i~P#C|OP[XZ[Xn[X|[X}[X!P[X!V[X!Y[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X~O!d%TX#r%TX~P'#`O![1[O%c9[O~O'}TO(QUO([9aO~O!Y1gO!Z(|q~O!j9dO~O!j9eO~O!j9fO~O!j9fO~P%[O#[9iO!Y#dy!Z#dy~O!Y#dy!Z#dy~P#C|O!['ZO%c9nO~O#|#zy!Y#zy!Z#zy~P#C|OP$wiZ$win$wi}$wi!h$wi!i$wi!k$wi!o$wi#j$wi#k$wi#l$wi#m$wi#n$wi#o$wi#p$wi#q$wi#r$wi#t$wi#v$wi#x$wi#y$wi#|$wi(X$wi(h$wi!Y$wi!Z$wi~P&'UO|)zO!P){O(p%POP'baZ'baj'ban'ba}'ba!h'ba!i'ba!k'ba!o'ba#j'ba#k'ba#l'ba#m'ba#n'ba#o'ba#p'ba#q'ba#r'ba#t'ba#v'ba#x'ba#y'ba#|'ba(X'ba(h'ba(o'ba!Y'ba!Z'ba~O|)zO!P){OP'daZ'daj'dan'da}'da!h'da!i'da!k'da!o'da#j'da#k'da#l'da#m'da#n'da#o'da#p'da#q'da#r'da#t'da#v'da#x'da#y'da#|'da(X'da(h'da(o'da(p'da!Y'da!Z'da~O(o$}OP%ZiZ%Zij%Zin%Zi|%Zi}%Zi!P%Zi!h%Zi!i%Zi!k%Zi!o%Zi#j%Zi#k%Zi#l%Zi#m%Zi#n%Zi#o%Zi#p%Zi#q%Zi#r%Zi#t%Zi#v%Zi#x%Zi#y%Zi#|%Zi(X%Zi(h%Zi(p%Zi!Y%Zi!Z%Zi~O(p%POP%]iZ%]ij%]in%]i|%]i}%]i!P%]i!h%]i!i%]i!k%]i!o%]i#j%]i#k%]i#l%]i#m%]i#n%]i#o%]i#p%]i#q%]i#r%]i#t%]i#v%]i#x%]i#y%]i#|%]i(X%]i(h%]i(o%]i!Y%]i!Z%]i~O#|$ky!Y$ky!Z$ky~P#C|O#|#_y!Y#_y!Z#_y~P#C|O!d#uO!Y'^q!j'^q~O!Y/cO!j(uy~O!V'`q!Y'`q~P#-]O!V9wO~P#-]O!Y0rO!Z)Oy~O!Y5UO!Z({q~O![1[O%c:OO~O!j:RO~O!['ZO%c:WO~OP$wqZ$wqn$wq}$wq!h$wq!i$wq!k$wq!o$wq#j$wq#k$wq#l$wq#m$wq#n$wq#o$wq#p$wq#q$wq#r$wq#t$wq#v$wq#x$wq#y$wq#|$wq(X$wq(h$wq!Y$wq!Z$wq~P&'UO|)zO!P){O(p%POP'caZ'caj'can'ca}'ca!h'ca!i'ca!k'ca!o'ca#j'ca#k'ca#l'ca#m'ca#n'ca#o'ca#p'ca#q'ca#r'ca#t'ca#v'ca#x'ca#y'ca#|'ca(X'ca(h'ca(o'ca!Y'ca!Z'ca~O|)zO!P){OP'eaZ'eaj'ean'ea}'ea!h'ea!i'ea!k'ea!o'ea#j'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#t'ea#v'ea#x'ea#y'ea#|'ea(X'ea(h'ea(o'ea(p'ea!Y'ea!Z'ea~OP$yqZ$yqn$yq}$yq!h$yq!i$yq!k$yq!o$yq#j$yq#k$yq#l$yq#m$yq#n$yq#o$yq#p$yq#q$yq#r$yq#t$yq#v$yq#x$yq#y$yq#|$yq(X$yq(h$yq!Y$yq!Z$yq~P&'UOf%_!Z!Y%_!Z#[%_!Z#|%_!Z~P!0}O!Y'iq!Z'iq~P#C|O!Y#d!Z!Z#d!Z~P#C|O#g%_!ZP%_!ZZ%_!Z`%_!Zn%_!Z}%_!Z!Y%_!Z!h%_!Z!i%_!Z!k%_!Z!o%_!Z#j%_!Z#k%_!Z#l%_!Z#m%_!Z#n%_!Z#o%_!Z#p%_!Z#q%_!Z#r%_!Z#t%_!Z#v%_!Z#x%_!Z#y%_!Z'r%_!Z(X%_!Z(h%_!Z!j%_!Z!V%_!Z'p%_!Z#[%_!Zr%_!Z![%_!Z%c%_!Z!d%_!Z~P#-]OP%_!ZZ%_!Zn%_!Z}%_!Z!h%_!Z!i%_!Z!k%_!Z!o%_!Z#j%_!Z#k%_!Z#l%_!Z#m%_!Z#n%_!Z#o%_!Z#p%_!Z#q%_!Z#r%_!Z#t%_!Z#v%_!Z#x%_!Z#y%_!Z#|%_!Z(X%_!Z(h%_!Z!Y%_!Z!Z%_!Z~P&'UOr(]X~P1qO'|!lO~P!*fO!VeX!YeX#[eX~P'#`OP[XZ[Xn[X|[X}[X!P[X!Y[X!YeX!h[X!i[X!k[X!o[X#[[X#[eX#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X~O!deX!j[X!jeX(heX~P'ASOP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![XO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'{)YO'}TO(QUO(XVO(g[O(t<YO~O!Y:wO!Z$ma~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;RO!P${O![$|O!f<aO!k$xO#f;XO$T%^O$o;TO$q;VO$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~O#s)aO~P'ExO!Z[X!ZeX~P'ASO#g:kO~O!d#uO#g:kO~O#[:{O~O#r:pO~O#[;ZO!Y(mX!Z(mX~O#[:{O!Y(kX!Z(kX~O#g;[O~Of;^O~P!0}O#g;cO~O#g;dO~O!d#uO#g;eO~O!d#uO#g;[O~O#|;fO~P#C|O#g;gO~O#g;hO~O#g;mO~O#g;nO~O#g;oO~O#g;pO~O#|;qO~P!0}O#|;rO~P!0}O!i#P#Q#S#T#W#e#f#q(t$o$q$t%W%b%c%d%k%m%p%q%s%u~'vS#k!U't'|#lo#j#mn|'u$Y'u'{$[([~",
  goto: "$2p)SPPPPP)TPP)WP)iP*x.|PPPP5pPP6WPP<S?gP?zP?zPPP?zPAxP?zP?zP?zPA|PPBRPBlPGdPPPGhPPPPGhJiPPPJoKjPGhPMxPPPP!!WGhPPPGhPGhP!$fGhP!'z!(|!)VP!)y!)}!)yPPPPP!-Y!(|PP!-v!.pP!1dGhGh!1i!4s!9Y!9Y!=OPPP!=VGhPPPPPPPPPPP!@dP!AqPPGh!CSPGhPGhGhGhGhPGh!DfP!GnP!JrP!Jv!KQ!KU!KUP!GkP!KY!KYP!N^P!NbGhGh!Nh##k?zP?zP?z?zP#$v?z?z#'O?z#)k?z#+m?z?z#,[#.f#.f#.j#.r#.f#.zP#.fP?z#/d?z#3R?z?z5pPPP#6vPPP#7a#7aP#7aP#7w#7aPP#7}P#7tP#7t#8b#7t#8|#9S5m)W#9V)WP#9^#9^#9^P)WP)WP)WP)WPP)WP#9d#9gP#9g)WP#9kP#9nP)WP)WP)WP)WP)WP)W)WPP#9t#9z#:V#:]#:c#:i#:o#:}#;T#;Z#;e#;k#;u#<U#<[#<|#=`#=f#=l#=z#>a#@O#@^#@d#Ax#BW#Cr#DQ#DW#D^#Dd#Dn#Dt#Dz#EU#Eh#EnPPPPPPPPPP#EtPPPPPPP#Fi#Ip#KP#KW#K`PPPP$!d$%Z$+r$+u$+x$,q$,t$,w$-O$-WPP$-^$-b$.Y$/X$/]$/qPP$/u$/{$0PP$0S$0W$0Z$1P$1h$2P$2T$2W$2Z$2a$2d$2h$2lR!{RoqOXst!Z#c%j&m&o&p&r,h,m1w1zY!uQ'Z-Y1[5]Q%pvQ%xyQ&P|Q&e!VS'R!e-QQ'a!iS'g!r!xS*c$|*hQ+f%yQ+s&RQ,X&_Q-W'YQ-b'bQ-j'hQ/|*jQ1f,YR;Y:g%OdOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S,e,h,m-^-f-t-z.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3Z5Y5d5t5u5x6]7w7|8]8gS#p]:d!r)[$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q*u%ZQ+k%{Q,Z&bQ,b&jQ.c;QQ0h+^Q0l+`Q0w+lQ1n,`Q2{.[Q4v0rQ5k1gQ6i3PQ6u;RQ7h4wR8m6j&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]t!nQ!r!u!x!y'R'Y'Z'g'h'i-Q-W-Y-j1[5]5_$v$si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gQ&S|Q'P!eS'V%f-TQ+k%{Q,Z&bQ0]*yQ0w+lQ0|+rQ1m,_Q1n,`Q4v0rQ5P1OQ5k1gQ5n1iQ5o1lQ7h4wQ7k4|Q8U5qQ9V7lR9b8RrnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zR,]&f&v^OPXYstuvwz!Z!`!g!j!o#R#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O']'m(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<[<][#[WZ#V#Y'S'}!S%gm#g#h#k%b%e(W(b(c(d+Q+R+T,d,z-x.O.P.Q.S2P2w2x6R6dQ%sxQ%wyS%||&RQ&Y!TQ'^!hQ'`!iQ(k#rS*V$x*ZS+e%x%yQ+i%{Q,S&]Q,W&_S-a'a'bQ.^(lQ/g*WQ0p+fQ0v+lQ0x+mQ0{+qQ1a,TS1e,X,YQ2i-bQ3y/cQ4u0rQ4y0uQ5O0}Q5j1fQ7Q3zQ7g4wQ7j4{Q9R7fR9y9S!O$zi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c!S%uy!i!t%w%x%y'Q'`'a'b'f'p*b+e+f,}-a-b-i/t0p2b2i2p4^Q+_%sQ+x&VQ+{&WQ,V&_Q.](kQ1`,SU1d,W,X,YQ3Q.^Q5e1aS5i1e1fQ8Q5j#W<^#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<go<_:y:z:};P;T;V;X;`;b;d;h;j;l;n;rW%Ti%V*r<YS&V!Q&dQ&W!RQ&X!SR+v&T$w%Si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gT)v$u)wV*v%Z;Q;RU'V!e%f-TS(y#y#zQ+p&OS.V(g(hQ1V+|Q4g0ZR7p5U&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]$i$`c#X#d%n%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.t.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PT#SV#T&}kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q'T!eR2^-Qv!nQ!e!r!u!x!y'R'Y'Z'g'h'i-Q-W-Y-j1[5]5_S*b$|*hS/t*c*jQ/}*kQ1X,OQ4^/|R4a0PnqOXst!Z#c%j&m&o&p&r,h,m1w1zQ&t!^Q'q!wS(m#t:kQ+c%vQ,Q&YQ,R&[Q-_'_Q-l'jS.g(r;[S0`+O;eQ0n+dQ1Z,PQ2O,oQ2Q,pQ2Y,{Q2g-`Q2j-dS4l0a;oQ4q0oS4t0q;pQ6T2[Q6X2hQ6^2oQ7e4rQ8b6VQ8c6YQ8f6_R9h8_$d$_c#X#d%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PS(j#o'dU*o%R(q3mS+Y%n.tQ2|0hQ6f2{Q8l6iR9o8m$d$^c#X#d%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PS(i#o'dS({#z$_S+X%n.tS.W(h(jQ.w)]Q0e+YR2y.X&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]S#p]:dQ&o!XQ&p!YQ&r![Q&s!]R1v,kQ'[!hQ+[%sQ-]'^S.Y(k+_Q2e-[W2}.].^0g0iQ6W2fU6e2z2|3QS8i6f6hS9m8k8lS:U9l9oQ:^:VR:a:_U!vQ'Z-YT5Z1[5]!Q_OXZ`st!V!Z#c#g%b%j&d&f&m&o&p&r(d,h,m.P1w1z]!pQ!r'Z-Y1[5]T#p]:d%Y{OPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gS(y#y#zS.V(g(h!s;v$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Y!tQ'Z-Y1[5]Q'f!rS'p!u!xS'r!y5_S-i'g'hQ-k'iR2p-jQ'o!tS(`#f1qS-h'f'rQ/f*VQ/r*bQ2q-kQ4O/gS4X/s/}Q7P3yS7[4_4aQ8y7QR9Q7_Q#vbQ'n!tS(_#f1qS(a#l*}Q+P%cQ+a%tQ+g%zU-g'f'o'rQ-{(`Q/e*VQ/q*bQ/w*eQ0m+bQ1b,US2n-h-kQ2v.TS3}/f/gS4W/r/}Q4Z/vQ4]/xQ5g1cQ6`2qQ7O3yQ7S4OS7W4X4aQ7]4`Q8O5hS8x7P7QQ8|7XQ9O7[Q9_8PQ9u8yQ9v8}Q9x9QQ:Q9`Q:Y9wQ;y;tQ<U;}R<V<OV!vQ'Z-Y%YaOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gS#vz!j!r;s$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]R;y<[%YbOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gQ%cj!S%ty!i!t%w%x%y'Q'`'a'b'f'p*b+e+f,}-a-b-i/t0p2b2i2p4^S%zz!jQ+b%uQ,U&_W1c,V,W,X,YU5h1d1e1fS8P5i5jQ9`8Q!r;t$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q;}<ZR<O<[$|eOPXYstuvw!Z!`!g!o#R#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gY#aWZ#V#Y'}!S%gm#g#h#k%b%e(W(b(c(d+Q+R+T,d,z-x.O.P.Q.S2P2w2x6R6dQ,c&j!p;u$[$m)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]R;x'SS'W!e%fR2`-T%OdOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S,e,h,m-^-f-t-z.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3Z5Y5d5t5u5x6]7w7|8]8g!r)[$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q,b&jQ0h+^Q2{.[Q6i3PR8m6j!b$Uc#X%n'|(S(n(u)W)X)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:e!P:r)Z)l-O.t2W2Z3_3i3j3n3t6U6p6y6z7r8a8n8t8u9{:S<P!f$Wc#X%n'|(S(n(u)T)U)W)X)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:e!T:t)Z)l-O.t2W2Z3_3f3g3i3j3n3t6U6p6y6z7r8a8n8t8u9{:S<P!^$[c#X%n'|(S(n(u)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:eQ3x/az<])Z)l-O.t2W2Z3_3n3t6U6p6y6z7r8a8n8t8u9{:S<PQ<b<dR<c<e&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]S$nh$oR3q.z'TgOPWXYZhstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m$o%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.z.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]T$jf$pQ$hfS)e$k)iR)q$pT$if$pT)g$k)i'ThOPWXYZhstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m$o%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.z.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]T$nh$oQ$qhR)p$o%YjOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8g!s<Z$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]#clOPXZst!Z!`!o#R#c#n#{$m%j&f&i&j&m&o&p&r&v'O'](z)n+S+^,e,h,m-^.[.{0[1_1o1p1r1t1w1z1|3P3p5Y5d5t5u5x6j7w7|8]!O%Ri#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c#W(q#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gQ*z%_Q/W)zo3m:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!O$yi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cQ*[$zS*e$|*hQ*{%`Q/x*f#W;{#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn;|:y:z:};P;T;V;X;`;b;d;h;j;l;n;rQ<Q<^Q<R<_Q<S<`R<T<a!O%Ri#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c#W(q#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<go3m:y:z:};P;T;V;X;`;b;d;h;j;l;n;rnoOXst!Z#c%j&m&o&p&r,h,m1w1zQ*_${Q,v&yQ,w&{R4R/k$v%Si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gQ+y&WQ1T+{Q5S1SR7o5TT*g$|*hS*g$|*hT5[1[5]S/v*d5YT4`0O7wQ+a%tQ/w*eQ0m+bQ1b,UQ5g1cQ8O5hQ9_8PR:Q9`!O%Oi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cr)}$v(s*O*n*|/i0U0V3W4P4j6}7`9t;z<W<XS0Q*m0R#W:|#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn:}:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!^;_(o)`*U*^._.b.f/S/X/a/n0f1Q1S3T4Q4U5R5T6k6n7U7Y7b7d8{9P:X<d<e`;`3l6q6t6x8o9p9s:bS;i.a3UT;j6s8r!O%Qi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cv*P$v(s*Q*m*|/]/i0U0V3W4P4b4j6}7`9t;z<W<XS0S*n0T#W;O#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn;P:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!b;a(o)`*U*^.`.a.f/S/X/a/n0f1Q1S3R3T4Q4U5R5T6k6l6n7U7Y7b7d8{9P:X<d<ed;b3l6r6s6x8o8p9p9q9s:bS;k.b3VT;l6t8srnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zQ&a!UR,e&jrnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zR&a!UQ+}&XR1P+vsnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zQ1],SS5b1`1aU7x5`5a5eS9Z7z7{S9|9Y9]Q:Z9}R:`:[Q&h!VR,^&dR5n1iS%||&RR0x+mQ&m!WR,h&nR,n&sT1x,m1zR,r&tQ,q&tR2R,rQ't!zR-n'tSsOtQ#cXT%ms#cQ!}TR'v!}Q#QUR'x#QQ)w$uR/T)wQ#TVR'z#TQ#WWU(Q#W(R-uQ(R#XR-u(SQ-R'TR2_-RQ.j(sR3X.jQ.m(uS3[.m3]R3].nQ-Y'ZR2c-YY!rQ'Z-Y1[5]R'e!rS#^W%eU(X#^(Y-vQ(Y#_R-v(TQ-U'WR2a-Ut`OXst!V!Z#c%j&d&f&m&o&p&r,h,m1w1zS#gZ%bU#q`#g.PR.P(dQ(e#iQ-|(aW.U(e-|2t6bQ2t-}R6b2uQ)i$kR.|)iQ$ohR)o$oQ$bcU)_$b-q:xQ-q:eR:x)lQ/d*VW3{/d3|7R8zU3|/e/f/gS7R3}4OR8z7S$X)|$v(o(s)`*U*^*m*n*w*x*|.a.b.d.e.f/S/X/]/_/a/i/n0U0V0f1Q1S3R3S3T3W3l4P4Q4U4b4d4j5R5T6k6l6m6n6s6t6v6w6x6}7U7Y7`7b7d8o8p8q8{9P9p9q9r9s9t:X:b;z<W<X<d<eQ/l*^U4T/l4V7VQ4V/nR7V4UQ*h$|R/z*hr*O$v(s*m*n*|/i0U0V3W4P4j6}7`9t;z<W<X!^._(o)`*U*^.a.b.f/S/X/a/n0f1Q1S3T4Q4U5R5T6k6n7U7Y7b7d8{9P:X<d<eU/^*O._6qa6q3l6s6t6x8o9p9s:bQ0R*mQ3U.aU4c0R3U8rR8r6sv*Q$v(s*m*n*|/]/i0U0V3W4P4b4j6}7`9t;z<W<X!b.`(o)`*U*^.a.b.f/S/X/a/n0f1Q1S3R3T4Q4U5R5T6k6l6n7U7Y7b7d8{9P:X<d<eU/`*Q.`6re6r3l6s6t6x8o8p9p9q9s:bQ0T*nQ3V.bU4e0T3V8sR8s6tQ*s%UR0X*sQ4o0fR7c4oQ+U%hR0d+UQ5V1VS7q5V9XR9X7rQ,P&YR1Y,PQ5]1[R7u5]Q1h,ZS5l1h8SR8S5nQ0s+iW4x0s4z7i9TQ4z0vQ7i4yR9T7jQ+n%|R0y+nQ1z,mR5|1zYrOXst#cQ&q!ZQ+W%jQ,g&mQ,i&oQ,j&pQ,l&rQ1u,hS1x,m1zR5{1wQ%lpQ&u!_Q&x!aQ&z!bQ&|!cQ'l!tQ+V%iQ+c%vQ+u&SQ,]&hQ,t&wW-e'f'n'o'rQ-l'jQ/y*gQ0n+dS1k,^,aQ2S,sQ2T,vQ2U,wQ2j-dW2l-g-h-k-mQ4q0oQ4}0|Q5Q1QQ5f1bQ5p1mQ5z1vU6Z2k2n2qQ6^2oQ7e4rQ7m5PQ7n5RQ7t5[Q7}5gQ8T5oS8d6[6`Q8f6_Q9U7kQ9^8OQ9c8UQ9j8eQ9z9VQ:P9_Q:T9kR:]:QQ%vyQ'_!iQ'j!tU+d%w%x%yQ,{'QU-`'`'a'bS-d'f'pQ/p*bS0o+e+fQ2[,}S2h-a-bQ2o-iQ4Y/tQ4r0pQ6V2bQ6Y2iQ6_2pR7Z4^S$wi<YR*t%VU%Ui%V<YR0W*rQ$viS(o#u+`Q(s#wS)`$c$dQ*U$xQ*^${Q*m%OQ*n%QQ*w%[Q*x%]Q*|%aQ.a:|Q.b;OQ.d;SQ.e;UQ.f;WQ/S)uS/X){/ZQ/])}Q/_*PQ/a*RQ/i*YQ/n*`Q0U*pQ0V*qh0f+].Z1^3O5c6g7y8j9[9n:O:WQ1Q+wQ1S+zQ3R;_Q3S;aQ3T;cQ3W.iS3l:y:zQ4P/jQ4Q/kQ4U/mQ4b0QQ4d0SQ4j0^Q5R1RQ5T1UQ6k;gQ6l;iQ6m;kQ6n;mQ6s:}Q6t;PQ6v;TQ6w;VQ6x;XQ6}3xQ7U4SQ7Y4[Q7`4fQ7b4nQ7d4pQ8o;dQ8p;`Q8q;bQ8{7TQ9P7^Q9p;hQ9q;jQ9r;lQ9s;nQ9t8wQ:X;qQ:b;rQ;z<YQ<W<bQ<X<cQ<d<fR<e<gnpOXst!Z#c%j&m&o&p&r,h,m1w1zQ!fPS#eZ#nQ&w!`U'c!o5Y7wQ'y#RQ(|#{Q)m$mS,a&f&iQ,f&jQ,s&vQ,x'OQ-[']Q.p(zQ/Q)nQ0b+SQ0i+^Q1s,eQ2f-^Q2|.[Q3s.{Q4h0[Q5a1_Q5r1oQ5s1pQ5w1rQ5y1tQ6O1|Q6f3PQ6{3pQ7{5dQ8X5tQ8Y5uQ8[5xQ8l6jQ9]7|R9g8]#WcOPXZst!Z!`!o#c#n#{%j&f&i&j&m&o&p&r&v'O'](z+S+^,e,h,m-^.[0[1_1o1p1r1t1w1z1|3P5Y5d5t5u5x6j7w7|8]Q#XWQ#dYQ%nuQ%ovS%qw!gS'|#V(PQ(S#YQ(n#tQ(u#xQ(}$OQ)O$PQ)P$QQ)Q$RQ)R$SQ)S$TQ)T$UQ)U$VQ)V$WQ)W$XQ)X$YQ)Z$[Q)^$aQ)b$eW)l$m)n.{3pQ+Z%pQ+o%}S-O'S2]Q-m'mS-r'}-tQ-w(VQ-y(^Q.h(rQ.n(vQ.r:cQ.t:fQ.u:gQ.v:jQ/V)yQ0_+OQ2W,yQ2Z,|Q2k-fQ2r-zQ3Y.lQ3_:kQ3`:lQ3a:mQ3b:nQ3c:oQ3d:pQ3e:qQ3f:rQ3g:sQ3h:tQ3i:uQ3j:vQ3k.sQ3n:{Q3o;YQ3t:wQ4k0aQ4s0qQ6U;ZQ6[2mQ6a2sQ6o3ZQ6p;[Q6y;^Q6z;eQ7r5WQ8a6SQ8e6]Q8n;fQ8t;oQ8u;pQ9k8gQ9{9WQ:S9iQ:e#RR<P<]R#ZWR'U!eY!tQ'Z-Y1[5]S'Q!e-QQ'f!rS'p!u!xS'r!y5_S,}'R'YS-i'g'hQ-k'iQ2b-WR2p-jR(t#wR(w#xQ!fQT-X'Z-Y]!qQ!r'Z-Y1[5]Q#o]R'd:dT#jZ%bS#iZ%bS%hm,dU(a#g#h#kS-}(b(cQ.R(dQ0c+TQ2u.OU2v.P.Q.SS6c2w2xR8h6d`#]W#V#Y%e'}(W+Q-xr#fZm#g#h#k%b(b(c(d+T.O.P.Q.S2w2x6dQ1q,dQ2X,zQ6Q2PQ8`6RT;w'S+RT#`W%eS#_W%eS(O#V(WS(T#Y+QS-P'S+RT-s'}-xT'X!e%fQ$kfR)s$pT)h$k)iR3r.zT*X$x*ZR*a${Q0g+]Q2z.ZQ5`1^Q6h3OQ7z5cQ8k6gQ9Y7yQ9l8jQ9}9[Q:V9nQ:[:OR:_:WnqOXst!Z#c%j&m&o&p&r,h,m1w1zQ&g!VR,]&dtmOXst!U!V!Z#c%j&d&m&o&p&r,h,m1w1zR,d&jT%im,dR1W+|R,[&bQ&Q|R+t&RR+j%{T&k!W&nT&l!W&nT1y,m1z",
  nodeNames: "⚠ ArithOp ArithOp JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . ?. PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewExpression new TypeArgList CompareOp < ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 371,
  context: nT,
  nodeProps: [
    ["isolate", -8, 4, 5, 13, 33, 35, 48, 50, 52, ""],
    ["group", -26, 8, 16, 18, 65, 201, 205, 209, 210, 212, 215, 218, 228, 230, 236, 238, 240, 242, 245, 251, 257, 259, 261, 263, 265, 267, 268, "Statement", -32, 12, 13, 28, 31, 32, 38, 48, 51, 52, 54, 59, 67, 75, 79, 81, 83, 84, 106, 107, 116, 117, 134, 137, 139, 140, 141, 142, 144, 145, 164, 165, 167, "Expression", -23, 27, 29, 33, 37, 39, 41, 168, 170, 172, 173, 175, 176, 177, 179, 180, 181, 183, 184, 185, 195, 197, 199, 200, "Type", -3, 87, 99, 105, "ClassItem"],
    ["openedBy", 22, "<", 34, "InterpolationStart", 53, "[", 57, "{", 72, "(", 157, "JSXStartCloseTag"],
    ["closedBy", 23, ">", 36, "InterpolationEnd", 47, "]", 58, "}", 73, ")", 162, "JSXEndTag"]
  ],
  propSources: [hT],
  skippedNodes: [0, 4, 5, 271],
  repeatNodeCount: 37,
  tokenData: "$Fj(CSR!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#8g!R![#:v![!]#Gv!]!^#IS!^!_#J^!_!`#Ns!`!a$#_!a!b$(l!b!c$,k!c!}Er!}#O$-u#O#P$/P#P#Q$4h#Q#R$5r#R#SEr#S#T$7P#T#o$8Z#o#p$<k#p#q$=a#q#r$>q#r#s$?}#s$f%Z$f$g+g$g#BYEr#BY#BZ$AX#BZ$ISEr$IS$I_$AX$I_$I|Er$I|$I}$Dd$I}$JO$Dd$JO$JTEr$JT$JU$AX$JU$KVEr$KV$KW$AX$KW&FUEr&FU&FV$AX&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$AX?HUOEr(n%d_$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$f&j(R!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(R!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$f&j(OpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(OpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z(CS+rq$f&j(Op(R!b't(;dOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z(CS.ST(P#S$f&j'u(;dO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c(CS.n_$f&j(Op(R!b'u(;dOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`/x`$f&j!o$Ip(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S1V`#t$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S2d_#t$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/|3l_'}$(n$f&j(R!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$f&j(R!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$f&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$a`$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$a``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$a`$f&j(R!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(R!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$a`(R!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k#%|:hh$f&j(Op(R!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__VS$f&j(Op(R!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]VS$f&j(R!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXVS$f&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSVSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWVS(R!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]VS$f&j(OpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWVS(OpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYVS(Op(R!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S#%|C}i$f&j(g!L^(Op(R!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr#%|EoP;=`<%lCr(CSFRk$f&j(Op(R!b$Y#t'{&;d([!LYOY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$f&j(Op(R!b$Y#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv(CSJPP;=`<%lEr%#SJ_`$f&j(Op(R!b#l$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SKl_$f&j$O$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&COLva(p&;`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SNW`$f&j#x$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/|! c_(Q$)`$f&j(OpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$f&j(OpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$f&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$a`$f&j(OpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(OpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$a`(OpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b(*Q!'t_!k(!b$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'l!)O_!jM|$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h!*[b$f&j(Op(R!b'|#)d#m$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S!+o`$f&j(Op(R!b#j$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&-O!,|`$f&j(Op(R!bn&%`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&C[!.Z_!Y&;l$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!/ec$f&j(Op(R!b|'<nOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!0ya$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!2Z_!XMt$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!3eg$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!5Vg$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!6wc$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!8_c$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!9uf$f&j(Op(R!b#k$IdOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpxz!;Zz{#,f{!P!;Z!P!Q#-{!Q!^!;Z!^!_#'Z!_!`#5k!`!a#7Q!a!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(r!;fb$f&j(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(Q!<w`$f&j(R!b!USOY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eb!Q!^!<n!^!_!GY!_!}!<n!}#O!Ja#O#P!Dj#P#o!<n#o#p!GY#p;'S!<n;'S;=`!Kj<%lO!<n&n!>Q^$f&j!USOY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@Y!_!}!=y!}#O!Bw#O#P!Dj#P#o!=y#o#p!@Y#p;'S!=y;'S;=`!E[<%lO!=y&n!?Ta$f&j!USO!^&c!_#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&cS!@_X!USOY!@YZ!P!@Y!P!Q!@z!Q!}!@Y!}#O!Ac#O#P!Bb#P;'S!@Y;'S;=`!Bq<%lO!@YS!APU!US#Z#[!@z#]#^!@z#a#b!@z#g#h!@z#i#j!@z#m#n!@zS!AfVOY!AcZ#O!Ac#O#P!A{#P#Q!@Y#Q;'S!Ac;'S;=`!B[<%lO!AcS!BOSOY!AcZ;'S!Ac;'S;=`!B[<%lO!AcS!B_P;=`<%l!AcS!BeSOY!@YZ;'S!@Y;'S;=`!Bq<%lO!@YS!BtP;=`<%l!@Y&n!B|[$f&jOY!BwYZ&cZ!^!Bw!^!_!Ac!_#O!Bw#O#P!Cr#P#Q!=y#Q#o!Bw#o#p!Ac#p;'S!Bw;'S;=`!Dd<%lO!Bw&n!CwX$f&jOY!BwYZ&cZ!^!Bw!^!_!Ac!_#o!Bw#o#p!Ac#p;'S!Bw;'S;=`!Dd<%lO!Bw&n!DgP;=`<%l!Bw&n!DoX$f&jOY!=yYZ&cZ!^!=y!^!_!@Y!_#o!=y#o#p!@Y#p;'S!=y;'S;=`!E[<%lO!=y&n!E_P;=`<%l!=y(Q!Eki$f&j(R!b!USOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#Z&}#Z#[!Eb#[#]&}#]#^!Eb#^#a&}#a#b!Eb#b#g&}#g#h!Eb#h#i&}#i#j!Eb#j#m&}#m#n!Eb#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!f!GaZ(R!b!USOY!GYZw!GYwx!@Yx!P!GY!P!Q!HS!Q!}!GY!}#O!Ic#O#P!Bb#P;'S!GY;'S;=`!JZ<%lO!GY!f!HZb(R!b!USOY'}Zw'}x#O'}#P#Z'}#Z#[!HS#[#]'}#]#^!HS#^#a'}#a#b!HS#b#g'}#g#h!HS#h#i'}#i#j!HS#j#m'}#m#n!HS#n;'S'};'S;=`(f<%lO'}!f!IhX(R!bOY!IcZw!Icwx!Acx#O!Ic#O#P!A{#P#Q!GY#Q;'S!Ic;'S;=`!JT<%lO!Ic!f!JWP;=`<%l!Ic!f!J^P;=`<%l!GY(Q!Jh^$f&j(R!bOY!JaYZ&cZw!Jawx!Bwx!^!Ja!^!_!Ic!_#O!Ja#O#P!Cr#P#Q!<n#Q#o!Ja#o#p!Ic#p;'S!Ja;'S;=`!Kd<%lO!Ja(Q!KgP;=`<%l!Ja(Q!KmP;=`<%l!<n'`!Ky`$f&j(Op!USOY!KpYZ&cZr!Kprs!=ys!P!Kp!P!Q!L{!Q!^!Kp!^!_!Ns!_!}!Kp!}#O##z#O#P!Dj#P#o!Kp#o#p!Ns#p;'S!Kp;'S;=`#%T<%lO!Kp'`!MUi$f&j(Op!USOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#Z(r#Z#[!L{#[#](r#]#^!L{#^#a(r#a#b!L{#b#g(r#g#h!L{#h#i(r#i#j!L{#j#m(r#m#n!L{#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rt!NzZ(Op!USOY!NsZr!Nsrs!@Ys!P!Ns!P!Q# m!Q!}!Ns!}#O#!|#O#P!Bb#P;'S!Ns;'S;=`##t<%lO!Nst# tb(Op!USOY)rZr)rs#O)r#P#Z)r#Z#[# m#[#])r#]#^# m#^#a)r#a#b# m#b#g)r#g#h# m#h#i)r#i#j# m#j#m)r#m#n# m#n;'S)r;'S;=`*Z<%lO)rt##RX(OpOY#!|Zr#!|rs!Acs#O#!|#O#P!A{#P#Q!Ns#Q;'S#!|;'S;=`##n<%lO#!|t##qP;=`<%l#!|t##wP;=`<%l!Ns'`#$R^$f&j(OpOY##zYZ&cZr##zrs!Bws!^##z!^!_#!|!_#O##z#O#P!Cr#P#Q!Kp#Q#o##z#o#p#!|#p;'S##z;'S;=`#$}<%lO##z'`#%QP;=`<%l##z'`#%WP;=`<%l!Kp(r#%fk$f&j(Op(R!b!USOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#Z%Z#Z#[#%Z#[#]%Z#]#^#%Z#^#a%Z#a#b#%Z#b#g%Z#g#h#%Z#h#i%Z#i#j#%Z#j#m%Z#m#n#%Z#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#W#'d](Op(R!b!USOY#'ZZr#'Zrs!GYsw#'Zwx!Nsx!P#'Z!P!Q#(]!Q!}#'Z!}#O#)w#O#P!Bb#P;'S#'Z;'S;=`#*w<%lO#'Z#W#(fe(Op(R!b!USOY*gZr*grs'}sw*gwx)rx#O*g#P#Z*g#Z#[#(]#[#]*g#]#^#(]#^#a*g#a#b#(]#b#g*g#g#h#(]#h#i*g#i#j#(]#j#m*g#m#n#(]#n;'S*g;'S;=`+Z<%lO*g#W#*OZ(Op(R!bOY#)wZr#)wrs!Icsw#)wwx#!|x#O#)w#O#P!A{#P#Q#'Z#Q;'S#)w;'S;=`#*q<%lO#)w#W#*tP;=`<%l#)w#W#*zP;=`<%l#'Z(r#+W`$f&j(Op(R!bOY#*}YZ&cZr#*}rs!Jasw#*}wx##zx!^#*}!^!_#)w!_#O#*}#O#P!Cr#P#Q!;Z#Q#o#*}#o#p#)w#p;'S#*};'S;=`#,Y<%lO#*}(r#,]P;=`<%l#*}(r#,cP;=`<%l!;Z(CS#,sb$f&j(Op(R!b'v(;d!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(CS#.W_$f&j(Op(R!bS(;dOY#-{YZ&cZr#-{rs#/Vsw#-{wx#2gx!^#-{!^!_#4f!_#O#-{#O#P#0X#P#o#-{#o#p#4f#p;'S#-{;'S;=`#5e<%lO#-{(Bb#/`]$f&j(R!bS(;dOY#/VYZ&cZw#/Vwx#0Xx!^#/V!^!_#1j!_#O#/V#O#P#0X#P#o#/V#o#p#1j#p;'S#/V;'S;=`#2a<%lO#/V(AO#0`X$f&jS(;dOY#0XYZ&cZ!^#0X!^!_#0{!_#o#0X#o#p#0{#p;'S#0X;'S;=`#1d<%lO#0X(;d#1QSS(;dOY#0{Z;'S#0{;'S;=`#1^<%lO#0{(;d#1aP;=`<%l#0{(AO#1gP;=`<%l#0X(<v#1qW(R!bS(;dOY#1jZw#1jwx#0{x#O#1j#O#P#0{#P;'S#1j;'S;=`#2Z<%lO#1j(<v#2^P;=`<%l#1j(Bb#2dP;=`<%l#/V(Ap#2p]$f&j(OpS(;dOY#2gYZ&cZr#2grs#0Xs!^#2g!^!_#3i!_#O#2g#O#P#0X#P#o#2g#o#p#3i#p;'S#2g;'S;=`#4`<%lO#2g(<U#3pW(OpS(;dOY#3iZr#3irs#0{s#O#3i#O#P#0{#P;'S#3i;'S;=`#4Y<%lO#3i(<U#4]P;=`<%l#3i(Ap#4cP;=`<%l#2g(=h#4oY(Op(R!bS(;dOY#4fZr#4frs#1jsw#4fwx#3ix#O#4f#O#P#0{#P;'S#4f;'S;=`#5_<%lO#4f(=h#5bP;=`<%l#4f(CS#5hP;=`<%l#-{%#W#5xb$f&j$O$Id(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z+h#7_b$W#t$f&j(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z$/l#8rp$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#:v![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#:v#S#U%Z#U#V#>Q#V#X%Z#X#Y!4|#Y#b%Z#b#c#<v#c#d#AY#d#l%Z#l#m#D[#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#;Rk$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#:v![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#:v#S#X%Z#X#Y!4|#Y#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#=R_$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#>Zd$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#?i!R!S#?i!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#?i#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#?tf$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#?i!R!S#?i!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#?i#S#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Acc$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#Bn!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#Bn#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Bye$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#Bn!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#Bn#S#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Deg$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#E|![!^%Z!^!_*g!_!c%Z!c!i#E|!i#O%Z#O#P&c#P#R%Z#R#S#E|#S#T%Z#T#Z#E|#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#FXi$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#E|![!^%Z!^!_*g!_!c%Z!c!i#E|!i#O%Z#O#P&c#P#R%Z#R#S#E|#S#T%Z#T#Z#E|#Z#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh#HT_!d$b$f&j#|%<f(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#I__`l$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(@^#Jk^g!*v!h'.r(Op(R!b(tSOY*gZr*grs'}sw*gwx)rx!P*g!P!Q#Kg!Q!^*g!^!_#L]!_!`#M}!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#KpX$h&j(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#LfZ#n$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#MX!`#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#MbX$O$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#NWX#o$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g%Gh$ Oa#[%?x$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$!T!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#W$!`_#g$Ih$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh$#nafBf#o$Id$c#|$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$$s!`!a$%}!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$%O_#o$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$&Ya#n$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$'_!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$'j`#n$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h$(wc(h$Ip$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P$*S!P!^%Z!^!_*g!_!a%Z!a!b$+^!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+`$*__}'#p$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$+i`$f&j#y$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&^$,v_!{!Ln$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(@^$.Q_!P(8n$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/UZ$f&jO!^$/w!^!_$0_!_#i$/w#i#j$0d#j#l$/w#l#m$2V#m#o$/w#o#p$0_#p;'S$/w;'S;=`$4b<%lO$/w(n$0OT^#S$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0dO^#S(n$0i[$f&jO!Q&c!Q![$1_![!^&c!_!c&c!c!i$1_!i#T&c#T#Z$1_#Z#o&c#o#p$3u#p;'S&c;'S;=`&w<%lO&c(n$1dZ$f&jO!Q&c!Q![$2V![!^&c!_!c&c!c!i$2V!i#T&c#T#Z$2V#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2[Z$f&jO!Q&c!Q![$2}![!^&c!_!c&c!c!i$2}!i#T&c#T#Z$2}#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3SZ$f&jO!Q&c!Q![$/w![!^&c!_!c&c!c!i$/w!i#T&c#T#Z$/w#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$3xR!Q![$4R!c!i$4R#T#Z$4R#S$4US!Q![$4R!c!i$4R#T#Z$4R#q#r$0_(n$4eP;=`<%l$/w!2r$4s_!V!+S$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$5}`#v$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&,v$7[_$f&j(Op(R!b(X&%WOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$8jk$f&j(Op(R!b'{&;d$[#t([!LYOY%ZYZ&cZr%Zrs&}st%Ztu$8Zuw%Zwx(rx}%Z}!O$:_!O!Q%Z!Q![$8Z![!^%Z!^!_*g!_!c%Z!c!}$8Z!}#O%Z#O#P&c#P#R%Z#R#S$8Z#S#T%Z#T#o$8Z#o#p*g#p$g%Z$g;'S$8Z;'S;=`$<e<%lO$8Z+d$:jk$f&j(Op(R!b$[#tOY%ZYZ&cZr%Zrs&}st%Ztu$:_uw%Zwx(rx}%Z}!O$:_!O!Q%Z!Q![$:_![!^%Z!^!_*g!_!c%Z!c!}$:_!}#O%Z#O#P&c#P#R%Z#R#S$:_#S#T%Z#T#o$:_#o#p*g#p$g%Z$g;'S$:_;'S;=`$<_<%lO$:_+d$<bP;=`<%l$:_(CS$<hP;=`<%l$8Z!5p$<tX![!3l(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g&CO$=la(o&;`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+^#q;'S%Z;'S;=`+a<%lO%Z%#`$?O_!Z$I`r`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(r$@Y_!pS$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$Aj|$f&j(Op(R!b't(;d$Y#t'{&;d([!LYOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$AX#BZ$ISEr$IS$I_$AX$I_$JTEr$JT$JU$AX$JU$KVEr$KV$KW$AX$KW&FUEr&FU&FV$AX&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$AX?HUOEr(CS$Duk$f&j(Op(R!b'u(;d$Y#t'{&;d([!LYOY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
  tokenizers: [oT, lT, aT, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, sT, new el("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOt~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!R~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(Z~~", 141, 332), new el("j~RQYZXz{^~^O'x~~aP!P!Qd~iO'y~~", 25, 315)],
  topRules: { Script: [0, 6], SingleExpression: [1, 269], SingleClassItem: [2, 270] },
  dialects: { jsx: 0, ts: 14614 },
  dynamicPrecedences: { 69: 1, 79: 1, 81: 1, 165: 1, 193: 1 },
  specialized: [{ term: 319, get: (r) => cT[r] || -1 }, { term: 334, get: (r) => uT[r] || -1 }, { term: 70, get: (r) => dT[r] || -1 }],
  tokenPrec: 14638
}), I0 = [
  /* @__PURE__ */ Oe("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Oe("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Oe("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Oe("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Oe("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Oe(`try {
	\${}
} catch (\${error}) {
	\${}
}`, {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  /* @__PURE__ */ Oe("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ Oe(`if (\${}) {
	\${}
} else {
	\${}
}`, {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ Oe(`class \${name} {
	constructor(\${params}) {
		\${}
	}
}`, {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Oe('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ Oe('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
], fT = /* @__PURE__ */ I0.concat([
  /* @__PURE__ */ Oe("interface ${name} {\n	${}\n}", {
    label: "interface",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Oe("type ${name} = ${type}", {
    label: "type",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Oe("enum ${name} {\n	${}\n}", {
    label: "enum",
    detail: "definition",
    type: "keyword"
  })
]), of = /* @__PURE__ */ new $c(), U0 = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function wn(r) {
  return (e, t) => {
    let i = e.node.getChild("VariableDefinition");
    return i && t(i, r), !0;
  };
}
const OT = ["FunctionDeclaration"], mT = {
  FunctionDeclaration: /* @__PURE__ */ wn("function"),
  ClassDeclaration: /* @__PURE__ */ wn("class"),
  ClassExpression: () => !0,
  EnumDeclaration: /* @__PURE__ */ wn("constant"),
  TypeAliasDeclaration: /* @__PURE__ */ wn("type"),
  NamespaceDeclaration: /* @__PURE__ */ wn("namespace"),
  VariableDefinition(r, e) {
    r.matchContext(OT) || e(r, "variable");
  },
  TypeDefinition(r, e) {
    e(r, "type");
  },
  __proto__: null
};
function G0(r, e) {
  let t = of.get(e);
  if (t)
    return t;
  let i = [], n = !0;
  function s(o, l) {
    let a = r.sliceString(o.from, o.to);
    i.push({ label: a, type: l });
  }
  return e.cursor(ne.IncludeAnonymous).iterate((o) => {
    if (n)
      n = !1;
    else if (o.name) {
      let l = mT[o.name];
      if (l && l(o, s) || U0.has(o.name))
        return !1;
    } else if (o.to - o.from > 8192) {
      for (let l of G0(r, o.node))
        i.push(l);
      return !1;
    }
  }), of.set(e, i), i;
}
const lf = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/, N0 = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName",
  ".",
  "?."
];
function gT(r) {
  let e = te(r.state).resolveInner(r.pos, -1);
  if (N0.indexOf(e.name) > -1)
    return null;
  let t = e.name == "VariableName" || e.to - e.from < 20 && lf.test(r.state.sliceDoc(e.from, e.to));
  if (!t && !r.explicit)
    return null;
  let i = [];
  for (let n = e; n; n = n.parent)
    U0.has(n.name) && (i = i.concat(G0(r.state.doc, n)));
  return {
    options: i,
    from: t ? e.from : r.pos,
    validFor: lf
  };
}
const Ut = /* @__PURE__ */ Nt.define({
  name: "javascript",
  parser: /* @__PURE__ */ pT.configure({
    props: [
      /* @__PURE__ */ Br.add({
        IfStatement: /* @__PURE__ */ si({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ si({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: YS,
        SwitchBody: (r) => {
          let e = r.textAfter, t = /^\s*\}/.test(e), i = /^\s*(case|default)\b/.test(e);
          return r.baseIndent + (t ? 0 : i ? 1 : 2) * r.unit;
        },
        Block: /* @__PURE__ */ wo({ closing: "}" }),
        ArrowFunction: (r) => r.baseIndent + r.unit,
        "TemplateString BlockComment": () => null,
        "Statement Property": /* @__PURE__ */ si({ except: /^{/ }),
        JSXElement(r) {
          let e = /^\s*<\//.test(r.textAfter);
          return r.lineIndent(r.node.from) + (e ? 0 : r.unit);
        },
        JSXEscape(r) {
          let e = /\s*\}/.test(r.textAfter);
          return r.lineIndent(r.node.from) + (e ? 0 : r.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(r) {
          return r.column(r.node.from) + r.unit;
        }
      }),
      /* @__PURE__ */ fr.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": wl,
        BlockComment(r) {
          return { from: r.from + 2, to: r.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
}), F0 = {
  test: (r) => /^JSX/.test(r.name),
  facet: /* @__PURE__ */ gl({ commentTokens: { block: { open: "{/*", close: "*/}" } } })
}, H0 = /* @__PURE__ */ Ut.configure({ dialect: "ts" }, "typescript"), K0 = /* @__PURE__ */ Ut.configure({
  dialect: "jsx",
  props: [/* @__PURE__ */ Qc.add((r) => r.isTop ? [F0] : void 0)]
}), J0 = /* @__PURE__ */ Ut.configure({
  dialect: "jsx ts",
  props: [/* @__PURE__ */ Qc.add((r) => r.isTop ? [F0] : void 0)]
}, "typescript");
let e1 = (r) => ({ label: r, type: "keyword" });
const t1 = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(e1), bT = /* @__PURE__ */ t1.concat(/* @__PURE__ */ ["declare", "implements", "private", "protected", "public"].map(e1));
function Mh(r = {}) {
  let e = r.jsx ? r.typescript ? J0 : K0 : r.typescript ? H0 : Ut, t = r.typescript ? fT.concat(bT) : I0.concat(t1);
  return new cr(e, [
    Ut.data.of({
      autocomplete: Dc(N0, $l(t))
    }),
    Ut.data.of({
      autocomplete: gT
    }),
    r.jsx ? vT : []
  ]);
}
function wT(r) {
  for (; ; ) {
    if (r.name == "JSXOpenTag" || r.name == "JSXSelfClosingTag" || r.name == "JSXFragmentTag")
      return r;
    if (r.name == "JSXEscape" || !r.parent)
      return null;
    r = r.parent;
  }
}
function af(r, e, t = r.length) {
  for (let i = e == null ? void 0 : e.firstChild; i; i = i.nextSibling)
    if (i.name == "JSXIdentifier" || i.name == "JSXBuiltin" || i.name == "JSXNamespacedName" || i.name == "JSXMemberExpression")
      return r.sliceString(i.from, Math.min(i.to, t));
  return "";
}
const yT = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), vT = /* @__PURE__ */ Z.inputHandler.of((r, e, t, i, n) => {
  if ((yT ? r.composing : r.compositionStarted) || r.state.readOnly || e != t || i != ">" && i != "/" || !Ut.isActiveAt(r.state, e, -1))
    return !1;
  let s = n(), { state: o } = s, l = o.changeByRange((a) => {
    var h;
    let { head: c } = a, u = te(o).resolveInner(c - 1, -1), d;
    if (u.name == "JSXStartTag" && (u = u.parent), !(o.doc.sliceString(c - 1, c) != i || u.name == "JSXAttributeValue" && u.to > c)) {
      if (i == ">" && u.name == "JSXFragmentTag")
        return { range: a, changes: { from: c, insert: "</>" } };
      if (i == "/" && u.name == "JSXStartCloseTag") {
        let p = u.parent, f = p.parent;
        if (f && p.from == c - 2 && ((d = af(o.doc, f.firstChild, c)) || ((h = f.firstChild) === null || h === void 0 ? void 0 : h.name) == "JSXFragmentTag")) {
          let m = `${d}>`;
          return { range: S.cursor(c + m.length, -1), changes: { from: c, insert: m } };
        }
      } else if (i == ">") {
        let p = wT(u);
        if (p && !/^\/?>|^<\//.test(o.doc.sliceString(c, c + 2)) && (d = af(o.doc, p, c)))
          return { range: a, changes: { from: c, insert: `</${d}>` } };
      }
    }
    return { range: a };
  });
  return l.changes.empty ? !1 : (r.dispatch([
    s,
    o.update(l, { userEvent: "input.complete", scrollIntoView: !0 })
  ]), !0);
}), yn = ["_blank", "_self", "_top", "_parent"], xa = ["ascii", "utf-8", "utf-16", "latin1", "latin1"], Sa = ["get", "post", "put", "delete"], ka = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], Ke = ["true", "false"], A = {}, xT = {
  a: {
    attrs: {
      href: null,
      ping: null,
      type: null,
      media: null,
      target: yn,
      hreflang: null
    }
  },
  abbr: A,
  address: A,
  area: {
    attrs: {
      alt: null,
      coords: null,
      href: null,
      target: null,
      ping: null,
      media: null,
      hreflang: null,
      type: null,
      shape: ["default", "rect", "circle", "poly"]
    }
  },
  article: A,
  aside: A,
  audio: {
    attrs: {
      src: null,
      mediagroup: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["none", "metadata", "auto"],
      autoplay: ["autoplay"],
      loop: ["loop"],
      controls: ["controls"]
    }
  },
  b: A,
  base: { attrs: { href: null, target: yn } },
  bdi: A,
  bdo: A,
  blockquote: { attrs: { cite: null } },
  body: A,
  br: A,
  button: {
    attrs: {
      form: null,
      formaction: null,
      name: null,
      value: null,
      autofocus: ["autofocus"],
      disabled: ["autofocus"],
      formenctype: ka,
      formmethod: Sa,
      formnovalidate: ["novalidate"],
      formtarget: yn,
      type: ["submit", "reset", "button"]
    }
  },
  canvas: { attrs: { width: null, height: null } },
  caption: A,
  center: A,
  cite: A,
  code: A,
  col: { attrs: { span: null } },
  colgroup: { attrs: { span: null } },
  command: {
    attrs: {
      type: ["command", "checkbox", "radio"],
      label: null,
      icon: null,
      radiogroup: null,
      command: null,
      title: null,
      disabled: ["disabled"],
      checked: ["checked"]
    }
  },
  data: { attrs: { value: null } },
  datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
  datalist: { attrs: { data: null } },
  dd: A,
  del: { attrs: { cite: null, datetime: null } },
  details: { attrs: { open: ["open"] } },
  dfn: A,
  div: A,
  dl: A,
  dt: A,
  em: A,
  embed: { attrs: { src: null, type: null, width: null, height: null } },
  eventsource: { attrs: { src: null } },
  fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
  figcaption: A,
  figure: A,
  footer: A,
  form: {
    attrs: {
      action: null,
      name: null,
      "accept-charset": xa,
      autocomplete: ["on", "off"],
      enctype: ka,
      method: Sa,
      novalidate: ["novalidate"],
      target: yn
    }
  },
  h1: A,
  h2: A,
  h3: A,
  h4: A,
  h5: A,
  h6: A,
  head: {
    children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
  },
  header: A,
  hgroup: A,
  hr: A,
  html: {
    attrs: { manifest: null }
  },
  i: A,
  iframe: {
    attrs: {
      src: null,
      srcdoc: null,
      name: null,
      width: null,
      height: null,
      sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
      seamless: ["seamless"]
    }
  },
  img: {
    attrs: {
      alt: null,
      src: null,
      ismap: null,
      usemap: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"]
    }
  },
  input: {
    attrs: {
      alt: null,
      dirname: null,
      form: null,
      formaction: null,
      height: null,
      list: null,
      max: null,
      maxlength: null,
      min: null,
      name: null,
      pattern: null,
      placeholder: null,
      size: null,
      src: null,
      step: null,
      value: null,
      width: null,
      accept: ["audio/*", "video/*", "image/*"],
      autocomplete: ["on", "off"],
      autofocus: ["autofocus"],
      checked: ["checked"],
      disabled: ["disabled"],
      formenctype: ka,
      formmethod: Sa,
      formnovalidate: ["novalidate"],
      formtarget: yn,
      multiple: ["multiple"],
      readonly: ["readonly"],
      required: ["required"],
      type: [
        "hidden",
        "text",
        "search",
        "tel",
        "url",
        "email",
        "password",
        "datetime",
        "date",
        "month",
        "week",
        "time",
        "datetime-local",
        "number",
        "range",
        "color",
        "checkbox",
        "radio",
        "file",
        "submit",
        "image",
        "reset",
        "button"
      ]
    }
  },
  ins: { attrs: { cite: null, datetime: null } },
  kbd: A,
  keygen: {
    attrs: {
      challenge: null,
      form: null,
      name: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      keytype: ["RSA"]
    }
  },
  label: { attrs: { for: null, form: null } },
  legend: A,
  li: { attrs: { value: null } },
  link: {
    attrs: {
      href: null,
      type: null,
      hreflang: null,
      media: null,
      sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
    }
  },
  map: { attrs: { name: null } },
  mark: A,
  menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
  meta: {
    attrs: {
      content: null,
      charset: xa,
      name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
      "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
    }
  },
  meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
  nav: A,
  noscript: A,
  object: {
    attrs: {
      data: null,
      type: null,
      name: null,
      usemap: null,
      form: null,
      width: null,
      height: null,
      typemustmatch: ["typemustmatch"]
    }
  },
  ol: {
    attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
    children: ["li", "script", "template", "ul", "ol"]
  },
  optgroup: { attrs: { disabled: ["disabled"], label: null } },
  option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
  output: { attrs: { for: null, form: null, name: null } },
  p: A,
  param: { attrs: { name: null, value: null } },
  pre: A,
  progress: { attrs: { value: null, max: null } },
  q: { attrs: { cite: null } },
  rp: A,
  rt: A,
  ruby: A,
  samp: A,
  script: {
    attrs: {
      type: ["text/javascript"],
      src: null,
      async: ["async"],
      defer: ["defer"],
      charset: xa
    }
  },
  section: A,
  select: {
    attrs: {
      form: null,
      name: null,
      size: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      multiple: ["multiple"]
    }
  },
  slot: { attrs: { name: null } },
  small: A,
  source: { attrs: { src: null, type: null, media: null } },
  span: A,
  strong: A,
  style: {
    attrs: {
      type: ["text/css"],
      media: null,
      scoped: null
    }
  },
  sub: A,
  summary: A,
  sup: A,
  table: A,
  tbody: A,
  td: { attrs: { colspan: null, rowspan: null, headers: null } },
  template: A,
  textarea: {
    attrs: {
      dirname: null,
      form: null,
      maxlength: null,
      name: null,
      placeholder: null,
      rows: null,
      cols: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      readonly: ["readonly"],
      required: ["required"],
      wrap: ["soft", "hard"]
    }
  },
  tfoot: A,
  th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
  thead: A,
  time: { attrs: { datetime: null } },
  title: A,
  tr: A,
  track: {
    attrs: {
      src: null,
      label: null,
      default: null,
      kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
      srclang: null
    }
  },
  ul: { children: ["li", "script", "template", "ul", "ol"] },
  var: A,
  video: {
    attrs: {
      src: null,
      poster: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["auto", "metadata", "none"],
      autoplay: ["autoplay"],
      mediagroup: ["movie"],
      muted: ["muted"],
      controls: ["controls"]
    }
  },
  wbr: A
}, r1 = {
  accesskey: null,
  class: null,
  contenteditable: Ke,
  contextmenu: null,
  dir: ["ltr", "rtl", "auto"],
  draggable: ["true", "false", "auto"],
  dropzone: ["copy", "move", "link", "string:", "file:"],
  hidden: ["hidden"],
  id: null,
  inert: ["inert"],
  itemid: null,
  itemprop: null,
  itemref: null,
  itemscope: ["itemscope"],
  itemtype: null,
  lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
  spellcheck: Ke,
  autocorrect: Ke,
  autocapitalize: Ke,
  style: null,
  tabindex: null,
  title: null,
  translate: ["yes", "no"],
  rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
  role: /* @__PURE__ */ "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
  "aria-activedescendant": null,
  "aria-atomic": Ke,
  "aria-autocomplete": ["inline", "list", "both", "none"],
  "aria-busy": Ke,
  "aria-checked": ["true", "false", "mixed", "undefined"],
  "aria-controls": null,
  "aria-describedby": null,
  "aria-disabled": Ke,
  "aria-dropeffect": null,
  "aria-expanded": ["true", "false", "undefined"],
  "aria-flowto": null,
  "aria-grabbed": ["true", "false", "undefined"],
  "aria-haspopup": Ke,
  "aria-hidden": Ke,
  "aria-invalid": ["true", "false", "grammar", "spelling"],
  "aria-label": null,
  "aria-labelledby": null,
  "aria-level": null,
  "aria-live": ["off", "polite", "assertive"],
  "aria-multiline": Ke,
  "aria-multiselectable": Ke,
  "aria-owns": null,
  "aria-posinset": null,
  "aria-pressed": ["true", "false", "mixed", "undefined"],
  "aria-readonly": Ke,
  "aria-relevant": null,
  "aria-required": Ke,
  "aria-selected": ["true", "false", "undefined"],
  "aria-setsize": null,
  "aria-sort": ["ascending", "descending", "none", "other"],
  "aria-valuemax": null,
  "aria-valuemin": null,
  "aria-valuenow": null,
  "aria-valuetext": null
}, i1 = /* @__PURE__ */ "beforeunload copy cut dragstart dragover dragleave dragenter dragend drag paste focus blur change click load mousedown mouseenter mouseleave mouseup keydown keyup resize scroll unload".split(" ").map((r) => "on" + r);
for (let r of i1)
  r1[r] = null;
class hs {
  constructor(e, t) {
    this.tags = Object.assign(Object.assign({}, xT), e), this.globalAttrs = Object.assign(Object.assign({}, r1), t), this.allTags = Object.keys(this.tags), this.globalAttrNames = Object.keys(this.globalAttrs);
  }
}
hs.default = /* @__PURE__ */ new hs();
function Ni(r, e, t = r.length) {
  if (!e)
    return "";
  let i = e.firstChild, n = i && i.getChild("TagName");
  return n ? r.sliceString(n.from, Math.min(n.to, t)) : "";
}
function Fi(r, e = !1) {
  for (; r; r = r.parent)
    if (r.name == "Element")
      if (e)
        e = !1;
      else
        return r;
  return null;
}
function n1(r, e, t) {
  let i = t.tags[Ni(r, Fi(e))];
  return (i == null ? void 0 : i.children) || t.allTags;
}
function tu(r, e) {
  let t = [];
  for (let i = Fi(e); i && !i.type.isTop; i = Fi(i.parent)) {
    let n = Ni(r, i);
    if (n && i.lastChild.name == "CloseTag")
      break;
    n && t.indexOf(n) < 0 && (e.name == "EndTag" || e.from >= i.firstChild.to) && t.push(n);
  }
  return t;
}
const s1 = /^[:\-\.\w\u00b7-\uffff]*$/;
function hf(r, e, t, i, n) {
  let s = /\s*>/.test(r.sliceDoc(n, n + 5)) ? "" : ">", o = Fi(t, !0);
  return {
    from: i,
    to: n,
    options: n1(r.doc, o, e).map((l) => ({ label: l, type: "type" })).concat(tu(r.doc, t).map((l, a) => ({
      label: "/" + l,
      apply: "/" + l + s,
      type: "type",
      boost: 99 - a
    }))),
    validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
  };
}
function cf(r, e, t, i) {
  let n = /\s*>/.test(r.sliceDoc(i, i + 5)) ? "" : ">";
  return {
    from: t,
    to: i,
    options: tu(r.doc, e).map((s, o) => ({ label: s, apply: s + n, type: "type", boost: 99 - o })),
    validFor: s1
  };
}
function ST(r, e, t, i) {
  let n = [], s = 0;
  for (let o of n1(r.doc, t, e))
    n.push({ label: "<" + o, type: "type" });
  for (let o of tu(r.doc, t))
    n.push({ label: "</" + o + ">", type: "type", boost: 99 - s++ });
  return { from: i, to: i, options: n, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function kT(r, e, t, i, n) {
  let s = Fi(t), o = s ? e.tags[Ni(r.doc, s)] : null, l = o && o.attrs ? Object.keys(o.attrs) : [], a = o && o.globalAttrs === !1 ? l : l.length ? l.concat(e.globalAttrNames) : e.globalAttrNames;
  return {
    from: i,
    to: n,
    options: a.map((h) => ({ label: h, type: "property" })),
    validFor: s1
  };
}
function $T(r, e, t, i, n) {
  var s;
  let o = (s = t.parent) === null || s === void 0 ? void 0 : s.getChild("AttributeName"), l = [], a;
  if (o) {
    let h = r.sliceDoc(o.from, o.to), c = e.globalAttrs[h];
    if (!c) {
      let u = Fi(t), d = u ? e.tags[Ni(r.doc, u)] : null;
      c = (d == null ? void 0 : d.attrs) && d.attrs[h];
    }
    if (c) {
      let u = r.sliceDoc(i, n).toLowerCase(), d = '"', p = '"';
      /^['"]/.test(u) ? (a = u[0] == '"' ? /^[^"]*$/ : /^[^']*$/, d = "", p = r.sliceDoc(n, n + 1) == u[0] ? "" : u[0], u = u.slice(1), i++) : a = /^[^\s<>='"]*$/;
      for (let f of c)
        l.push({ label: f, apply: d + f + p, type: "constant" });
    }
  }
  return { from: i, to: n, options: l, validFor: a };
}
function o1(r, e) {
  let { state: t, pos: i } = e, n = te(t).resolveInner(i, -1), s = n.resolve(i);
  for (let o = i, l; s == n && (l = n.childBefore(o)); ) {
    let a = l.lastChild;
    if (!a || !a.type.isError || a.from < a.to)
      break;
    s = n = l, o = a.from;
  }
  return n.name == "TagName" ? n.parent && /CloseTag$/.test(n.parent.name) ? cf(t, n, n.from, i) : hf(t, r, n, n.from, i) : n.name == "StartTag" ? hf(t, r, n, i, i) : n.name == "StartCloseTag" || n.name == "IncompleteCloseTag" ? cf(t, n, i, i) : n.name == "OpenTag" || n.name == "SelfClosingTag" || n.name == "AttributeName" ? kT(t, r, n, n.name == "AttributeName" ? n.from : i, i) : n.name == "Is" || n.name == "AttributeValue" || n.name == "UnquotedAttributeValue" ? $T(t, r, n, n.name == "Is" ? i : n.from, i) : e.explicit && (s.name == "Element" || s.name == "Text" || s.name == "Document") ? ST(t, r, n, i) : null;
}
function QT(r) {
  return o1(hs.default, r);
}
function PT(r) {
  let { extraTags: e, extraGlobalAttributes: t } = r, i = t || e ? new hs(e, t) : hs.default;
  return (n) => o1(i, n);
}
const TT = /* @__PURE__ */ Ut.parser.configure({ top: "SingleExpression" }), l1 = [
  {
    tag: "script",
    attrs: (r) => r.type == "text/typescript" || r.lang == "ts",
    parser: H0.parser
  },
  {
    tag: "script",
    attrs: (r) => r.type == "text/babel" || r.type == "text/jsx",
    parser: K0.parser
  },
  {
    tag: "script",
    attrs: (r) => r.type == "text/typescript-jsx",
    parser: J0.parser
  },
  {
    tag: "script",
    attrs(r) {
      return /^(importmap|speculationrules|application\/(.+\+)?json)$/i.test(r.type);
    },
    parser: TT
  },
  {
    tag: "script",
    attrs(r) {
      return !r.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(r.type);
    },
    parser: Ut.parser
  },
  {
    tag: "style",
    attrs(r) {
      return (!r.lang || r.lang == "css") && (!r.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(r.type));
    },
    parser: tl.parser
  }
], a1 = /* @__PURE__ */ [
  {
    name: "style",
    parser: /* @__PURE__ */ tl.parser.configure({ top: "Styles" })
  }
].concat(/* @__PURE__ */ i1.map((r) => ({ name: r, parser: Ut.parser }))), h1 = /* @__PURE__ */ Nt.define({
  name: "html",
  parser: /* @__PURE__ */ j2.configure({
    props: [
      /* @__PURE__ */ Br.add({
        Element(r) {
          let e = /^(\s*)(<\/)?/.exec(r.textAfter);
          return r.node.to <= r.pos + e[0].length ? r.continue() : r.lineIndent(r.node.from) + (e[2] ? 0 : r.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(r) {
          return r.column(r.node.from) + r.unit;
        },
        Document(r) {
          if (r.pos + /\s*/.exec(r.textAfter)[0].length < r.node.to)
            return r.continue();
          let e = null, t;
          for (let i = r.node; ; ) {
            let n = i.lastChild;
            if (!n || n.name != "Element" || n.to != i.to)
              break;
            e = i = n;
          }
          return e && !((t = e.lastChild) && (t.name == "CloseTag" || t.name == "SelfClosingTag")) ? r.lineIndent(e.from) + r.unit : null;
        }
      }),
      /* @__PURE__ */ fr.add({
        Element(r) {
          let e = r.firstChild, t = r.lastChild;
          return !e || e.name != "OpenTag" ? null : { from: e.to, to: t.name == "CloseTag" ? t.from : r.to };
        }
      }),
      /* @__PURE__ */ hg.add({
        "OpenTag CloseTag": (r) => r.getChild("TagName")
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/\w+\W$/,
    wordChars: "-._"
  }
}), xo = /* @__PURE__ */ h1.configure({
  wrap: /* @__PURE__ */ B0(l1, a1)
});
function c1(r = {}) {
  let e = "", t;
  r.matchClosingTags === !1 && (e = "noMatch"), r.selfClosingTags === !0 && (e = (e ? e + " " : "") + "selfClosing"), (r.nestedLanguages && r.nestedLanguages.length || r.nestedAttributes && r.nestedAttributes.length) && (t = B0((r.nestedLanguages || []).concat(l1), (r.nestedAttributes || []).concat(a1)));
  let i = t ? h1.configure({ wrap: t, dialect: e }) : e ? xo.configure({ dialect: e }) : xo;
  return new cr(i, [
    xo.data.of({ autocomplete: PT(r) }),
    r.autoCloseTags !== !1 ? CT : [],
    Mh().support,
    R0().support
  ]);
}
const uf = /* @__PURE__ */ new Set(/* @__PURE__ */ "area base br col command embed frame hr img input keygen link meta param source track wbr menuitem".split(" ")), CT = /* @__PURE__ */ Z.inputHandler.of((r, e, t, i, n) => {
  if (r.composing || r.state.readOnly || e != t || i != ">" && i != "/" || !xo.isActiveAt(r.state, e, -1))
    return !1;
  let s = n(), { state: o } = s, l = o.changeByRange((a) => {
    var h, c, u;
    let d = o.doc.sliceString(a.from - 1, a.to) == i, { head: p } = a, f = te(o).resolveInner(p - 1, -1), m;
    if ((f.name == "TagName" || f.name == "StartTag") && (f = f.parent), d && i == ">" && f.name == "OpenTag") {
      if (((c = (h = f.parent) === null || h === void 0 ? void 0 : h.lastChild) === null || c === void 0 ? void 0 : c.name) != "CloseTag" && (m = Ni(o.doc, f.parent, p)) && !uf.has(m)) {
        let g = p + (o.doc.sliceString(p, p + 1) === ">" ? 1 : 0), b = `</${m}>`;
        return { range: a, changes: { from: p, to: g, insert: b } };
      }
    } else if (d && i == "/" && f.name == "IncompleteCloseTag") {
      let g = f.parent;
      if (f.from == p - 2 && ((u = g.lastChild) === null || u === void 0 ? void 0 : u.name) != "CloseTag" && (m = Ni(o.doc, g, p)) && !uf.has(m)) {
        let b = p + (o.doc.sliceString(p, p + 1) === ">" ? 1 : 0), v = `${m}>`;
        return {
          range: S.cursor(p + v.length, -1),
          changes: { from: p, to: b, insert: v }
        };
      }
    }
    return { range: a };
  });
  return l.changes.empty ? !1 : (r.dispatch([
    s,
    o.update(l, {
      userEvent: "input.complete",
      scrollIntoView: !0
    })
  ]), !0);
}), XT = Jt({
  String: O.string,
  Number: O.number,
  "True False": O.bool,
  PropertyName: O.propertyName,
  Null: O.null,
  ",": O.separator,
  "[ ]": O.squareBracket,
  "{ }": O.brace
}), ZT = Ft.deserialize({
  version: 14,
  states: "$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#CjOOQO'#Cp'#CpQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CrOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59U,59UO!iQPO,59UOVQPO,59QOqQPO'#CkO!nQPO,59^OOQO1G.k1G.kOVQPO'#ClO!vQPO,59aOOQO1G.p1G.pOOQO1G.l1G.lOOQO,59V,59VOOQO-E6i-E6iOOQO,59W,59WOOQO-E6j-E6j",
  stateData: "#O~OcOS~OQSORSOSSOTSOWQO]ROePO~OVXOeUO~O[[O~PVOg^O~Oh_OVfX~OVaO~OhbO[iX~O[dO~Oh_OVfa~OhbO[ia~O",
  goto: "!kjPPPPPPkPPkqwPPk{!RPPP!XP!ePP!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
  nodeNames: "⚠ JsonText True False Null Number String } { Object Property PropertyName ] [ Array",
  maxTerm: 25,
  nodeProps: [
    ["isolate", -2, 6, 11, ""],
    ["openedBy", 7, "{", 12, "["],
    ["closedBy", 8, "}", 13, "]"]
  ],
  propSources: [XT],
  skippedNodes: [0],
  repeatNodeCount: 2,
  tokenData: "(|~RaXY!WYZ!W]^!Wpq!Wrs!]|}$u}!O$z!Q!R%T!R![&c![!]&t!}#O&y#P#Q'O#Y#Z'T#b#c'r#h#i(Z#o#p(r#q#r(w~!]Oc~~!`Wpq!]qr!]rs!xs#O!]#O#P!}#P;'S!];'S;=`$o<%lO!]~!}Oe~~#QXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#m~#pR!Q![#y!c!i#y#T#Z#y~#|R!Q![$V!c!i$V#T#Z$V~$YR!Q![$c!c!i$c#T#Z$c~$fR!Q![!]!c!i!]#T#Z!]~$rP;=`<%l!]~$zOh~~$}Q!Q!R%T!R![&c~%YRT~!O!P%c!g!h%w#X#Y%w~%fP!Q![%i~%nRT~!Q![%i!g!h%w#X#Y%w~%zR{|&T}!O&T!Q![&Z~&WP!Q![&Z~&`PT~!Q![&Z~&hST~!O!P%c!Q![&c!g!h%w#X#Y%w~&yOg~~'OO]~~'TO[~~'WP#T#U'Z~'^P#`#a'a~'dP#g#h'g~'jP#X#Y'm~'rOR~~'uP#i#j'x~'{P#`#a(O~(RP#`#a(U~(ZOS~~(^P#f#g(a~(dP#i#j(g~(jP#X#Y(m~(rOQ~~(wOW~~(|OV~",
  tokenizers: [0],
  topRules: { JsonText: [0, 1] },
  tokenPrec: 0
}), _T = /* @__PURE__ */ Nt.define({
  name: "json",
  parser: /* @__PURE__ */ ZT.configure({
    props: [
      /* @__PURE__ */ Br.add({
        Object: /* @__PURE__ */ si({ except: /^\s*\}/ }),
        Array: /* @__PURE__ */ si({ except: /^\s*\]/ })
      }),
      /* @__PURE__ */ fr.add({
        "Object Array": wl
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["[", "{", '"'] },
    indentOnInput: /^\s*[\}\]]$/
  }
});
function RT() {
  return new cr(_T);
}
class nl {
  static create(e, t, i, n, s) {
    let o = n + (n << 8) + e + (t << 4) | 0;
    return new nl(e, t, i, o, s, [], []);
  }
  constructor(e, t, i, n, s, o, l) {
    this.type = e, this.value = t, this.from = i, this.hash = n, this.end = s, this.children = o, this.positions = l, this.hashProp = [[Y.contextHash, n]];
  }
  addChild(e, t) {
    e.prop(Y.contextHash) != this.hash && (e = new D(e.type, e.children, e.positions, e.length, this.hashProp)), this.children.push(e), this.positions.push(t);
  }
  toTree(e, t = this.end) {
    let i = this.children.length - 1;
    return i >= 0 && (t = Math.max(t, this.positions[i] + this.children[i].length + this.from)), new D(e.types[this.type], this.children, this.positions, t - this.from).balance({
      makeTree: (n, s, o) => new D(ye.none, n, s, o, this.hashProp)
    });
  }
}
var T;
(function(r) {
  r[r.Document = 1] = "Document", r[r.CodeBlock = 2] = "CodeBlock", r[r.FencedCode = 3] = "FencedCode", r[r.Blockquote = 4] = "Blockquote", r[r.HorizontalRule = 5] = "HorizontalRule", r[r.BulletList = 6] = "BulletList", r[r.OrderedList = 7] = "OrderedList", r[r.ListItem = 8] = "ListItem", r[r.ATXHeading1 = 9] = "ATXHeading1", r[r.ATXHeading2 = 10] = "ATXHeading2", r[r.ATXHeading3 = 11] = "ATXHeading3", r[r.ATXHeading4 = 12] = "ATXHeading4", r[r.ATXHeading5 = 13] = "ATXHeading5", r[r.ATXHeading6 = 14] = "ATXHeading6", r[r.SetextHeading1 = 15] = "SetextHeading1", r[r.SetextHeading2 = 16] = "SetextHeading2", r[r.HTMLBlock = 17] = "HTMLBlock", r[r.LinkReference = 18] = "LinkReference", r[r.Paragraph = 19] = "Paragraph", r[r.CommentBlock = 20] = "CommentBlock", r[r.ProcessingInstructionBlock = 21] = "ProcessingInstructionBlock", r[r.Escape = 22] = "Escape", r[r.Entity = 23] = "Entity", r[r.HardBreak = 24] = "HardBreak", r[r.Emphasis = 25] = "Emphasis", r[r.StrongEmphasis = 26] = "StrongEmphasis", r[r.Link = 27] = "Link", r[r.Image = 28] = "Image", r[r.InlineCode = 29] = "InlineCode", r[r.HTMLTag = 30] = "HTMLTag", r[r.Comment = 31] = "Comment", r[r.ProcessingInstruction = 32] = "ProcessingInstruction", r[r.Autolink = 33] = "Autolink", r[r.HeaderMark = 34] = "HeaderMark", r[r.QuoteMark = 35] = "QuoteMark", r[r.ListMark = 36] = "ListMark", r[r.LinkMark = 37] = "LinkMark", r[r.EmphasisMark = 38] = "EmphasisMark", r[r.CodeMark = 39] = "CodeMark", r[r.CodeText = 40] = "CodeText", r[r.CodeInfo = 41] = "CodeInfo", r[r.LinkTitle = 42] = "LinkTitle", r[r.LinkLabel = 43] = "LinkLabel", r[r.URL = 44] = "URL";
})(T || (T = {}));
class AT {
  /// @internal
  constructor(e, t) {
    this.start = e, this.content = t, this.marks = [], this.parsers = [];
  }
}
class ET {
  constructor() {
    this.text = "", this.baseIndent = 0, this.basePos = 0, this.depth = 0, this.markers = [], this.pos = 0, this.indent = 0, this.next = -1;
  }
  /// @internal
  forward() {
    this.basePos > this.pos && this.forwardInner();
  }
  /// @internal
  forwardInner() {
    let e = this.skipSpace(this.basePos);
    this.indent = this.countIndent(e, this.pos, this.indent), this.pos = e, this.next = e == this.text.length ? -1 : this.text.charCodeAt(e);
  }
  /// Skip whitespace after the given position, return the position of
  /// the next non-space character or the end of the line if there's
  /// only space after `from`.
  skipSpace(e) {
    return Wn(this.text, e);
  }
  /// @internal
  reset(e) {
    for (this.text = e, this.baseIndent = this.basePos = this.pos = this.indent = 0, this.forwardInner(), this.depth = 1; this.markers.length; )
      this.markers.pop();
  }
  /// Move the line's base position forward to the given position.
  /// This should only be called by composite [block
  /// parsers](#BlockParser.parse) or [markup skipping
  /// functions](#NodeSpec.composite).
  moveBase(e) {
    this.basePos = e, this.baseIndent = this.countIndent(e, this.pos, this.indent);
  }
  /// Move the line's base position forward to the given _column_.
  moveBaseColumn(e) {
    this.baseIndent = e, this.basePos = this.findColumn(e);
  }
  /// Store a composite-block-level marker. Should be called from
  /// [markup skipping functions](#NodeSpec.composite) when they
  /// consume any non-whitespace characters.
  addMarker(e) {
    this.markers.push(e);
  }
  /// Find the column position at `to`, optionally starting at a given
  /// position and column.
  countIndent(e, t = 0, i = 0) {
    for (let n = t; n < e; n++)
      i += this.text.charCodeAt(n) == 9 ? 4 - i % 4 : 1;
    return i;
  }
  /// Find the position corresponding to the given column.
  findColumn(e) {
    let t = 0;
    for (let i = 0; t < this.text.length && i < e; t++)
      i += this.text.charCodeAt(t) == 9 ? 4 - i % 4 : 1;
    return t;
  }
  /// @internal
  scrub() {
    if (!this.baseIndent)
      return this.text;
    let e = "";
    for (let t = 0; t < this.basePos; t++)
      e += " ";
    return e + this.text.slice(this.basePos);
  }
}
function df(r, e, t) {
  if (t.pos == t.text.length || r != e.block && t.indent >= e.stack[t.depth + 1].value + t.baseIndent)
    return !0;
  if (t.indent >= t.baseIndent + 4)
    return !1;
  let i = (r.type == T.OrderedList ? nu : iu)(t, e, !1);
  return i > 0 && (r.type != T.BulletList || ru(t, e, !1) < 0) && t.text.charCodeAt(t.pos + i - 1) == r.value;
}
const u1 = {
  [T.Blockquote](r, e, t) {
    return t.next != 62 ? !1 : (t.markers.push(N(T.QuoteMark, e.lineStart + t.pos, e.lineStart + t.pos + 1)), t.moveBase(t.pos + (kt(t.text.charCodeAt(t.pos + 1)) ? 2 : 1)), r.end = e.lineStart + t.text.length, !0);
  },
  [T.ListItem](r, e, t) {
    return t.indent < t.baseIndent + r.value && t.next > -1 ? !1 : (t.moveBaseColumn(t.baseIndent + r.value), !0);
  },
  [T.OrderedList]: df,
  [T.BulletList]: df,
  [T.Document]() {
    return !0;
  }
};
function kt(r) {
  return r == 32 || r == 9 || r == 10 || r == 13;
}
function Wn(r, e = 0) {
  for (; e < r.length && kt(r.charCodeAt(e)); )
    e++;
  return e;
}
function pf(r, e, t) {
  for (; e > t && kt(r.charCodeAt(e - 1)); )
    e--;
  return e;
}
function d1(r) {
  if (r.next != 96 && r.next != 126)
    return -1;
  let e = r.pos + 1;
  for (; e < r.text.length && r.text.charCodeAt(e) == r.next; )
    e++;
  if (e < r.pos + 3)
    return -1;
  if (r.next == 96) {
    for (let t = e; t < r.text.length; t++)
      if (r.text.charCodeAt(t) == 96)
        return -1;
  }
  return e;
}
function p1(r) {
  return r.next != 62 ? -1 : r.text.charCodeAt(r.pos + 1) == 32 ? 2 : 1;
}
function ru(r, e, t) {
  if (r.next != 42 && r.next != 45 && r.next != 95)
    return -1;
  let i = 1;
  for (let n = r.pos + 1; n < r.text.length; n++) {
    let s = r.text.charCodeAt(n);
    if (s == r.next)
      i++;
    else if (!kt(s))
      return -1;
  }
  return t && r.next == 45 && m1(r) > -1 && r.depth == e.stack.length || i < 3 ? -1 : 1;
}
function f1(r, e) {
  for (let t = r.stack.length - 1; t >= 0; t--)
    if (r.stack[t].type == e)
      return !0;
  return !1;
}
function iu(r, e, t) {
  return (r.next == 45 || r.next == 43 || r.next == 42) && (r.pos == r.text.length - 1 || kt(r.text.charCodeAt(r.pos + 1))) && (!t || f1(e, T.BulletList) || r.skipSpace(r.pos + 2) < r.text.length) ? 1 : -1;
}
function nu(r, e, t) {
  let i = r.pos, n = r.next;
  for (; n >= 48 && n <= 57; ) {
    i++;
    if (i == r.text.length)
      return -1;
    n = r.text.charCodeAt(i);
  }
  return i == r.pos || i > r.pos + 9 || n != 46 && n != 41 || i < r.text.length - 1 && !kt(r.text.charCodeAt(i + 1)) || t && !f1(e, T.OrderedList) && (r.skipSpace(i + 1) == r.text.length || i > r.pos + 1 || r.next != 49) ? -1 : i + 1 - r.pos;
}
function O1(r) {
  if (r.next != 35)
    return -1;
  let e = r.pos + 1;
  for (; e < r.text.length && r.text.charCodeAt(e) == 35; )
    e++;
  if (e < r.text.length && r.text.charCodeAt(e) != 32)
    return -1;
  let t = e - r.pos;
  return t > 6 ? -1 : t;
}
function m1(r) {
  if (r.next != 45 && r.next != 61 || r.indent >= r.baseIndent + 4)
    return -1;
  let e = r.pos + 1;
  for (; e < r.text.length && r.text.charCodeAt(e) == r.next; )
    e++;
  let t = e;
  for (; e < r.text.length && kt(r.text.charCodeAt(e)); )
    e++;
  return e == r.text.length ? t : -1;
}
const jh = /^[ \t]*$/, g1 = /-->/, b1 = /\?>/, Lh = [
  [/^<(?:script|pre|style)(?:\s|>|$)/i, /<\/(?:script|pre|style)>/i],
  [/^\s*<!--/, g1],
  [/^\s*<\?/, b1],
  [/^\s*<![A-Z]/, />/],
  [/^\s*<!\[CDATA\[/, /\]\]>/],
  [/^\s*<\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|\/?>|$)/i, jh],
  [/^\s*(?:<\/[a-z][\w-]*\s*>|<[a-z][\w-]*(\s+[a-z:_][\w-.]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*>)\s*$/i, jh]
];
function w1(r, e, t) {
  if (r.next != 60)
    return -1;
  let i = r.text.slice(r.pos);
  for (let n = 0, s = Lh.length - (t ? 1 : 0); n < s; n++)
    if (Lh[n][0].test(i))
      return n;
  return -1;
}
function ff(r, e) {
  let t = r.countIndent(e, r.pos, r.indent), i = r.countIndent(r.skipSpace(e), e, t);
  return i >= t + 5 ? t + 1 : i;
}
function Fr(r, e, t) {
  let i = r.length - 1;
  i >= 0 && r[i].to == e && r[i].type == T.CodeText ? r[i].to = t : r.push(N(T.CodeText, e, t));
}
const ro = {
  LinkReference: void 0,
  IndentedCode(r, e) {
    let t = e.baseIndent + 4;
    if (e.indent < t)
      return !1;
    let i = e.findColumn(t), n = r.lineStart + i, s = r.lineStart + e.text.length, o = [], l = [];
    for (Fr(o, n, s); r.nextLine() && e.depth >= r.stack.length; )
      if (e.pos == e.text.length) {
        Fr(l, r.lineStart - 1, r.lineStart);
        for (let a of e.markers)
          l.push(a);
      } else {
        if (e.indent < t)
          break;
        {
          if (l.length) {
            for (let h of l)
              h.type == T.CodeText ? Fr(o, h.from, h.to) : o.push(h);
            l = [];
          }
          Fr(o, r.lineStart - 1, r.lineStart);
          for (let h of e.markers)
            o.push(h);
          s = r.lineStart + e.text.length;
          let a = r.lineStart + e.findColumn(e.baseIndent + 4);
          a < s && Fr(o, a, s);
        }
      }
    return l.length && (l = l.filter((a) => a.type != T.CodeText), l.length && (e.markers = l.concat(e.markers))), r.addNode(r.buffer.writeElements(o, -n).finish(T.CodeBlock, s - n), n), !0;
  },
  FencedCode(r, e) {
    let t = d1(e);
    if (t < 0)
      return !1;
    let i = r.lineStart + e.pos, n = e.next, s = t - e.pos, o = e.skipSpace(t), l = pf(e.text, e.text.length, o), a = [N(T.CodeMark, i, i + s)];
    o < l && a.push(N(T.CodeInfo, r.lineStart + o, r.lineStart + l));
    for (let h = !0; r.nextLine() && e.depth >= r.stack.length; h = !1) {
      let c = e.pos;
      if (e.indent - e.baseIndent < 4)
        for (; c < e.text.length && e.text.charCodeAt(c) == n; )
          c++;
      if (c - e.pos >= s && e.skipSpace(c) == e.text.length) {
        for (let u of e.markers)
          a.push(u);
        a.push(N(T.CodeMark, r.lineStart + e.pos, r.lineStart + c)), r.nextLine();
        break;
      } else {
        h || Fr(a, r.lineStart - 1, r.lineStart);
        for (let p of e.markers)
          a.push(p);
        let u = r.lineStart + e.basePos, d = r.lineStart + e.text.length;
        u < d && Fr(a, u, d);
      }
    }
    return r.addNode(r.buffer.writeElements(a, -i).finish(T.FencedCode, r.prevLineEnd() - i), i), !0;
  },
  Blockquote(r, e) {
    let t = p1(e);
    return t < 0 ? !1 : (r.startContext(T.Blockquote, e.pos), r.addNode(T.QuoteMark, r.lineStart + e.pos, r.lineStart + e.pos + 1), e.moveBase(e.pos + t), null);
  },
  HorizontalRule(r, e) {
    if (ru(e, r, !1) < 0)
      return !1;
    let t = r.lineStart + e.pos;
    return r.nextLine(), r.addNode(T.HorizontalRule, t), !0;
  },
  BulletList(r, e) {
    let t = iu(e, r, !1);
    if (t < 0)
      return !1;
    r.block.type != T.BulletList && r.startContext(T.BulletList, e.basePos, e.next);
    let i = ff(e, e.pos + 1);
    return r.startContext(T.ListItem, e.basePos, i - e.baseIndent), r.addNode(T.ListMark, r.lineStart + e.pos, r.lineStart + e.pos + t), e.moveBaseColumn(i), null;
  },
  OrderedList(r, e) {
    let t = nu(e, r, !1);
    if (t < 0)
      return !1;
    r.block.type != T.OrderedList && r.startContext(T.OrderedList, e.basePos, e.text.charCodeAt(e.pos + t - 1));
    let i = ff(e, e.pos + t);
    return r.startContext(T.ListItem, e.basePos, i - e.baseIndent), r.addNode(T.ListMark, r.lineStart + e.pos, r.lineStart + e.pos + t), e.moveBaseColumn(i), null;
  },
  ATXHeading(r, e) {
    let t = O1(e);
    if (t < 0)
      return !1;
    let i = e.pos, n = r.lineStart + i, s = pf(e.text, e.text.length, i), o = s;
    for (; o > i && e.text.charCodeAt(o - 1) == e.next; )
      o--;
    (o == s || o == i || !kt(e.text.charCodeAt(o - 1))) && (o = e.text.length);
    let l = r.buffer.write(T.HeaderMark, 0, t).writeElements(r.parser.parseInline(e.text.slice(i + t + 1, o), n + t + 1), -n);
    o < e.text.length && l.write(T.HeaderMark, o - i, s - i);
    let a = l.finish(T.ATXHeading1 - 1 + t, e.text.length - i);
    return r.nextLine(), r.addNode(a, n), !0;
  },
  HTMLBlock(r, e) {
    let t = w1(e, r, !1);
    if (t < 0)
      return !1;
    let i = r.lineStart + e.pos, n = Lh[t][1], s = [], o = n != jh;
    for (; !n.test(e.text) && r.nextLine(); ) {
      if (e.depth < r.stack.length) {
        o = !1;
        break;
      }
      for (let h of e.markers)
        s.push(h);
    }
    o && r.nextLine();
    let l = n == g1 ? T.CommentBlock : n == b1 ? T.ProcessingInstructionBlock : T.HTMLBlock, a = r.prevLineEnd();
    return r.addNode(r.buffer.writeElements(s, -i).finish(l, a - i), i), !0;
  },
  SetextHeading: void 0
  // Specifies relative precedence for block-continue function
};
class qT {
  constructor(e) {
    this.stage = 0, this.elts = [], this.pos = 0, this.start = e.start, this.advance(e.content);
  }
  nextLine(e, t, i) {
    if (this.stage == -1)
      return !1;
    let n = i.content + `
` + t.scrub(), s = this.advance(n);
    return s > -1 && s < n.length ? this.complete(e, i, s) : !1;
  }
  finish(e, t) {
    return (this.stage == 2 || this.stage == 3) && Wn(t.content, this.pos) == t.content.length ? this.complete(e, t, t.content.length) : !1;
  }
  complete(e, t, i) {
    return e.addLeafElement(t, N(T.LinkReference, this.start, this.start + i, this.elts)), !0;
  }
  nextStage(e) {
    return e ? (this.pos = e.to - this.start, this.elts.push(e), this.stage++, !0) : (e === !1 && (this.stage = -1), !1);
  }
  advance(e) {
    for (; ; ) {
      if (this.stage == -1)
        return -1;
      if (this.stage == 0) {
        if (!this.nextStage(T1(e, this.pos, this.start, !0)))
          return -1;
        if (e.charCodeAt(this.pos) != 58)
          return this.stage = -1;
        this.elts.push(N(T.LinkMark, this.pos + this.start, this.pos + this.start + 1)), this.pos++;
      } else if (this.stage == 1) {
        if (!this.nextStage(Q1(e, Wn(e, this.pos), this.start)))
          return -1;
      } else if (this.stage == 2) {
        let t = Wn(e, this.pos), i = 0;
        if (t > this.pos) {
          let n = P1(e, t, this.start);
          if (n) {
            let s = $a(e, n.to - this.start);
            s > 0 && (this.nextStage(n), i = s);
          }
        }
        return i || (i = $a(e, this.pos)), i > 0 && i < e.length ? i : -1;
      } else
        return $a(e, this.pos);
    }
  }
}
function $a(r, e) {
  for (; e < r.length; e++) {
    let t = r.charCodeAt(e);
    if (t == 10)
      break;
    if (!kt(t))
      return -1;
  }
  return e;
}
class zT {
  nextLine(e, t, i) {
    let n = t.depth < e.stack.length ? -1 : m1(t), s = t.next;
    if (n < 0)
      return !1;
    let o = N(T.HeaderMark, e.lineStart + t.pos, e.lineStart + n);
    return e.nextLine(), e.addLeafElement(i, N(s == 61 ? T.SetextHeading1 : T.SetextHeading2, i.start, e.prevLineEnd(), [
      ...e.parser.parseInline(i.content, i.start),
      o
    ])), !0;
  }
  finish() {
    return !1;
  }
}
const YT = {
  LinkReference(r, e) {
    return e.content.charCodeAt(0) == 91 ? new qT(e) : null;
  },
  SetextHeading() {
    return new zT();
  }
}, WT = [
  (r, e) => O1(e) >= 0,
  (r, e) => d1(e) >= 0,
  (r, e) => p1(e) >= 0,
  (r, e) => iu(e, r, !0) >= 0,
  (r, e) => nu(e, r, !0) >= 0,
  (r, e) => ru(e, r, !0) >= 0,
  (r, e) => w1(e, r, !0) >= 0
], VT = { text: "", end: 0 };
class MT {
  /// @internal
  constructor(e, t, i, n) {
    this.parser = e, this.input = t, this.ranges = n, this.line = new ET(), this.atEnd = !1, this.reusePlaceholders = /* @__PURE__ */ new Map(), this.stoppedAt = null, this.rangeI = 0, this.to = n[n.length - 1].to, this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = n[0].from, this.block = nl.create(T.Document, 0, this.lineStart, 0, 0), this.stack = [this.block], this.fragments = i.length ? new DT(i, t) : null, this.readLine();
  }
  get parsedPos() {
    return this.absoluteLineStart;
  }
  advance() {
    if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)
      return this.finish();
    let { line: e } = this;
    for (; ; ) {
      for (let i = 0; ; ) {
        let n = e.depth < this.stack.length ? this.stack[this.stack.length - 1] : null;
        for (; i < e.markers.length && (!n || e.markers[i].from < n.end); ) {
          let s = e.markers[i++];
          this.addNode(s.type, s.from, s.to);
        }
        if (!n)
          break;
        this.finishContext();
      }
      if (e.pos < e.text.length)
        break;
      if (!this.nextLine())
        return this.finish();
    }
    if (this.fragments && this.reuseFragment(e.basePos))
      return null;
    e:
      for (; ; ) {
        for (let i of this.parser.blockParsers)
          if (i) {
            let n = i(this, e);
            if (n != !1) {
              if (n == !0)
                return null;
              e.forward();
              continue e;
            }
          }
        break;
      }
    let t = new AT(this.lineStart + e.pos, e.text.slice(e.pos));
    for (let i of this.parser.leafBlockParsers)
      if (i) {
        let n = i(this, t);
        n && t.parsers.push(n);
      }
    e:
      for (; this.nextLine() && e.pos != e.text.length; ) {
        if (e.indent < e.baseIndent + 4) {
          for (let i of this.parser.endLeafBlock)
            if (i(this, e, t))
              break e;
        }
        for (let i of t.parsers)
          if (i.nextLine(this, e, t))
            return null;
        t.content += `
` + e.scrub();
        for (let i of e.markers)
          t.marks.push(i);
      }
    return this.finishLeaf(t), null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  reuseFragment(e) {
    if (!this.fragments.moveTo(this.absoluteLineStart + e, this.absoluteLineStart) || !this.fragments.matches(this.block.hash))
      return !1;
    let t = this.fragments.takeNodes(this);
    return t ? (this.absoluteLineStart += t, this.lineStart = C1(this.absoluteLineStart, this.ranges), this.moveRangeI(), this.absoluteLineStart < this.to ? (this.lineStart++, this.absoluteLineStart++, this.readLine()) : (this.atEnd = !0, this.readLine()), !0) : !1;
  }
  /// The number of parent blocks surrounding the current block.
  get depth() {
    return this.stack.length;
  }
  /// Get the type of the parent block at the given depth. When no
  /// depth is passed, return the type of the innermost parent.
  parentType(e = this.depth - 1) {
    return this.parser.nodeSet.types[this.stack[e].type];
  }
  /// Move to the next input line. This should only be called by
  /// (non-composite) [block parsers](#BlockParser.parse) that consume
  /// the line directly, or leaf block parser
  /// [`nextLine`](#LeafBlockParser.nextLine) methods when they
  /// consume the current line (and return true).
  nextLine() {
    return this.lineStart += this.line.text.length, this.absoluteLineEnd >= this.to ? (this.absoluteLineStart = this.absoluteLineEnd, this.atEnd = !0, this.readLine(), !1) : (this.lineStart++, this.absoluteLineStart = this.absoluteLineEnd + 1, this.moveRangeI(), this.readLine(), !0);
  }
  moveRangeI() {
    for (; this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to; )
      this.rangeI++, this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);
  }
  /// @internal
  scanLine(e) {
    let t = VT;
    if (t.end = e, e >= this.to)
      t.text = "";
    else if (t.text = this.lineChunkAt(e), t.end += t.text.length, this.ranges.length > 1) {
      let i = this.absoluteLineStart, n = this.rangeI;
      for (; this.ranges[n].to < t.end; ) {
        n++;
        let s = this.ranges[n].from, o = this.lineChunkAt(s);
        t.end = s + o.length, t.text = t.text.slice(0, this.ranges[n - 1].to - i) + o, i = t.end - t.text.length;
      }
    }
    return t;
  }
  /// @internal
  readLine() {
    let { line: e } = this, { text: t, end: i } = this.scanLine(this.absoluteLineStart);
    for (this.absoluteLineEnd = i, e.reset(t); e.depth < this.stack.length; e.depth++) {
      let n = this.stack[e.depth], s = this.parser.skipContextMarkup[n.type];
      if (!s)
        throw new Error("Unhandled block context " + T[n.type]);
      if (!s(n, this, e))
        break;
      e.forward();
    }
  }
  lineChunkAt(e) {
    let t = this.input.chunk(e), i;
    if (this.input.lineChunks)
      i = t == `
` ? "" : t;
    else {
      let n = t.indexOf(`
`);
      i = n < 0 ? t : t.slice(0, n);
    }
    return e + i.length > this.to ? i.slice(0, this.to - e) : i;
  }
  /// The end position of the previous line.
  prevLineEnd() {
    return this.atEnd ? this.lineStart : this.lineStart - 1;
  }
  /// @internal
  startContext(e, t, i = 0) {
    this.block = nl.create(e, i, this.lineStart + t, this.block.hash, this.lineStart + this.line.text.length), this.stack.push(this.block);
  }
  /// Start a composite block. Should only be called from [block
  /// parser functions](#BlockParser.parse) that return null.
  startComposite(e, t, i = 0) {
    this.startContext(this.parser.getNodeType(e), t, i);
  }
  /// @internal
  addNode(e, t, i) {
    typeof e == "number" && (e = new D(this.parser.nodeSet.types[e], Hi, Hi, (i ?? this.prevLineEnd()) - t)), this.block.addChild(e, t - this.block.from);
  }
  /// Add a block element. Can be called by [block
  /// parsers](#BlockParser.parse).
  addElement(e) {
    this.block.addChild(e.toTree(this.parser.nodeSet), e.from - this.block.from);
  }
  /// Add a block element from a [leaf parser](#LeafBlockParser). This
  /// makes sure any extra composite block markup (such as blockquote
  /// markers) inside the block are also added to the syntax tree.
  addLeafElement(e, t) {
    this.addNode(this.buffer.writeElements(Dh(t.children, e.marks), -t.from).finish(t.type, t.to - t.from), t.from);
  }
  /// @internal
  finishContext() {
    let e = this.stack.pop(), t = this.stack[this.stack.length - 1];
    t.addChild(e.toTree(this.parser.nodeSet), e.from - t.from), this.block = t;
  }
  finish() {
    for (; this.stack.length > 1; )
      this.finishContext();
    return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));
  }
  addGaps(e) {
    return this.ranges.length > 1 ? y1(this.ranges, 0, e.topNode, this.ranges[0].from, this.reusePlaceholders) : e;
  }
  /// @internal
  finishLeaf(e) {
    for (let i of e.parsers)
      if (i.finish(this, e))
        return;
    let t = Dh(this.parser.parseInline(e.content, e.start), e.marks);
    this.addNode(this.buffer.writeElements(t, -e.start).finish(T.Paragraph, e.content.length), e.start);
  }
  elt(e, t, i, n) {
    return typeof e == "string" ? N(this.parser.getNodeType(e), t, i, n) : new S1(e, t);
  }
  /// @internal
  get buffer() {
    return new x1(this.parser.nodeSet);
  }
}
function y1(r, e, t, i, n) {
  let s = r[e].to, o = [], l = [], a = t.from + i;
  function h(c, u) {
    for (; u ? c >= s : c > s; ) {
      let d = r[e + 1].from - s;
      i += d, c += d, e++, s = r[e].to;
    }
  }
  for (let c = t.firstChild; c; c = c.nextSibling) {
    h(c.from + i, !0);
    let u = c.from + i, d, p = n.get(c.tree);
    p ? d = p : c.to + i > s ? (d = y1(r, e, c, i, n), h(c.to + i, !1)) : d = c.toTree(), o.push(d), l.push(u - a);
  }
  return h(t.to + i, !1), new D(t.type, o, l, t.to + i - a, t.tree ? t.tree.propValues : void 0);
}
class Cl extends ml {
  /// @internal
  constructor(e, t, i, n, s, o, l, a, h) {
    super(), this.nodeSet = e, this.blockParsers = t, this.leafBlockParsers = i, this.blockNames = n, this.endLeafBlock = s, this.skipContextMarkup = o, this.inlineParsers = l, this.inlineNames = a, this.wrappers = h, this.nodeTypes = /* @__PURE__ */ Object.create(null);
    for (let c of e.types)
      this.nodeTypes[c.name] = c.id;
  }
  createParse(e, t, i) {
    let n = new MT(this, e, t, i);
    for (let s of this.wrappers)
      n = s(n, e, t, i);
    return n;
  }
  /// Reconfigure the parser.
  configure(e) {
    let t = Bh(e);
    if (!t)
      return this;
    let { nodeSet: i, skipContextMarkup: n } = this, s = this.blockParsers.slice(), o = this.leafBlockParsers.slice(), l = this.blockNames.slice(), a = this.inlineParsers.slice(), h = this.inlineNames.slice(), c = this.endLeafBlock.slice(), u = this.wrappers;
    if (vn(t.defineNodes)) {
      n = Object.assign({}, n);
      let d = i.types.slice(), p;
      for (let f of t.defineNodes) {
        let { name: m, block: g, composite: b, style: v } = typeof f == "string" ? { name: f } : f;
        if (d.some((x) => x.name == m))
          continue;
        b && (n[d.length] = (x, Q, P) => b(Q, P, x.value));
        let k = d.length, $ = b ? ["Block", "BlockContext"] : g ? k >= T.ATXHeading1 && k <= T.SetextHeading2 ? ["Block", "LeafBlock", "Heading"] : ["Block", "LeafBlock"] : void 0;
        d.push(ye.define({
          id: k,
          name: m,
          props: $ && [[Y.group, $]]
        })), v && (p || (p = {}), Array.isArray(v) || v instanceof $t ? p[m] = v : Object.assign(p, v));
      }
      i = new rn(d), p && (i = i.extend(Jt(p)));
    }
    if (vn(t.props) && (i = i.extend(...t.props)), vn(t.remove))
      for (let d of t.remove) {
        let p = this.blockNames.indexOf(d), f = this.inlineNames.indexOf(d);
        p > -1 && (s[p] = o[p] = void 0), f > -1 && (a[f] = void 0);
      }
    if (vn(t.parseBlock))
      for (let d of t.parseBlock) {
        let p = l.indexOf(d.name);
        if (p > -1)
          s[p] = d.parse, o[p] = d.leaf;
        else {
          let f = d.before ? io(l, d.before) : d.after ? io(l, d.after) + 1 : l.length - 1;
          s.splice(f, 0, d.parse), o.splice(f, 0, d.leaf), l.splice(f, 0, d.name);
        }
        d.endLeaf && c.push(d.endLeaf);
      }
    if (vn(t.parseInline))
      for (let d of t.parseInline) {
        let p = h.indexOf(d.name);
        if (p > -1)
          a[p] = d.parse;
        else {
          let f = d.before ? io(h, d.before) : d.after ? io(h, d.after) + 1 : h.length - 1;
          a.splice(f, 0, d.parse), h.splice(f, 0, d.name);
        }
      }
    return t.wrap && (u = u.concat(t.wrap)), new Cl(i, s, o, l, c, n, a, h, u);
  }
  /// @internal
  getNodeType(e) {
    let t = this.nodeTypes[e];
    if (t == null)
      throw new RangeError(`Unknown node type '${e}'`);
    return t;
  }
  /// Parse the given piece of inline text at the given offset,
  /// returning an array of [`Element`](#Element) objects representing
  /// the inline content.
  parseInline(e, t) {
    let i = new LT(this, e, t);
    e:
      for (let n = t; n < i.end; ) {
        let s = i.char(n);
        for (let o of this.inlineParsers)
          if (o) {
            let l = o(i, s, n);
            if (l >= 0) {
              n = l;
              continue e;
            }
          }
        n++;
      }
    return i.resolveMarkers(0);
  }
}
function vn(r) {
  return r != null && r.length > 0;
}
function Bh(r) {
  if (!Array.isArray(r))
    return r;
  if (r.length == 0)
    return null;
  let e = Bh(r[0]);
  if (r.length == 1)
    return e;
  let t = Bh(r.slice(1));
  if (!t || !e)
    return e || t;
  let i = (o, l) => (o || Hi).concat(l || Hi), n = e.wrap, s = t.wrap;
  return {
    props: i(e.props, t.props),
    defineNodes: i(e.defineNodes, t.defineNodes),
    parseBlock: i(e.parseBlock, t.parseBlock),
    parseInline: i(e.parseInline, t.parseInline),
    remove: i(e.remove, t.remove),
    wrap: n ? s ? (o, l, a, h) => n(s(o, l, a, h), l, a, h) : n : s
  };
}
function io(r, e) {
  let t = r.indexOf(e);
  if (t < 0)
    throw new RangeError(`Position specified relative to unknown parser ${e}`);
  return t;
}
let v1 = [ye.none];
for (let r = 1, e; e = T[r]; r++)
  v1[r] = ye.define({
    id: r,
    name: e,
    props: r >= T.Escape ? [] : [[Y.group, r in u1 ? ["Block", "BlockContext"] : ["Block", "LeafBlock"]]],
    top: e == "Document"
  });
const Hi = [];
class x1 {
  constructor(e) {
    this.nodeSet = e, this.content = [], this.nodes = [];
  }
  write(e, t, i, n = 0) {
    return this.content.push(e, t, i, 4 + n * 4), this;
  }
  writeElements(e, t = 0) {
    for (let i of e)
      i.writeTo(this, t);
    return this;
  }
  finish(e, t) {
    return D.build({
      buffer: this.content,
      nodeSet: this.nodeSet,
      reused: this.nodes,
      topID: e,
      length: t
    });
  }
}
let cs = class {
  /// @internal
  constructor(e, t, i, n = Hi) {
    this.type = e, this.from = t, this.to = i, this.children = n;
  }
  /// @internal
  writeTo(e, t) {
    let i = e.content.length;
    e.writeElements(this.children, t), e.content.push(this.type, this.from + t, this.to + t, e.content.length + 4 - i);
  }
  /// @internal
  toTree(e) {
    return new x1(e).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);
  }
};
class S1 {
  constructor(e, t) {
    this.tree = e, this.from = t;
  }
  get to() {
    return this.from + this.tree.length;
  }
  get type() {
    return this.tree.type.id;
  }
  get children() {
    return Hi;
  }
  writeTo(e, t) {
    e.nodes.push(this.tree), e.content.push(e.nodes.length - 1, this.from + t, this.to + t, -1);
  }
  toTree() {
    return this.tree;
  }
}
function N(r, e, t, i) {
  return new cs(r, e, t, i);
}
const k1 = { resolve: "Emphasis", mark: "EmphasisMark" }, $1 = { resolve: "Emphasis", mark: "EmphasisMark" }, xn = {}, Of = {};
class Qt {
  constructor(e, t, i, n) {
    this.type = e, this.from = t, this.to = i, this.side = n;
  }
}
const mf = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
let us = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\u2010-\u2027]/;
try {
  us = new RegExp("[\\p{Pc}|\\p{Pd}|\\p{Pe}|\\p{Pf}|\\p{Pi}|\\p{Po}|\\p{Ps}]", "u");
} catch {
}
const Qa = {
  Escape(r, e, t) {
    if (e != 92 || t == r.end - 1)
      return -1;
    let i = r.char(t + 1);
    for (let n = 0; n < mf.length; n++)
      if (mf.charCodeAt(n) == i)
        return r.append(N(T.Escape, t, t + 2));
    return -1;
  },
  Entity(r, e, t) {
    if (e != 38)
      return -1;
    let i = /^(?:#\d+|#x[a-f\d]+|\w+);/i.exec(r.slice(t + 1, t + 31));
    return i ? r.append(N(T.Entity, t, t + 1 + i[0].length)) : -1;
  },
  InlineCode(r, e, t) {
    if (e != 96 || t && r.char(t - 1) == 96)
      return -1;
    let i = t + 1;
    for (; i < r.end && r.char(i) == 96; )
      i++;
    let n = i - t, s = 0;
    for (; i < r.end; i++)
      if (r.char(i) == 96) {
        if (s++, s == n && r.char(i + 1) != 96)
          return r.append(N(T.InlineCode, t, i + 1, [
            N(T.CodeMark, t, t + n),
            N(T.CodeMark, i + 1 - n, i + 1)
          ]));
      } else
        s = 0;
    return -1;
  },
  HTMLTag(r, e, t) {
    if (e != 60 || t == r.end - 1)
      return -1;
    let i = r.slice(t + 1, r.end), n = /^(?:[a-z][-\w+.]+:[^\s>]+|[a-z\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?(?:\.[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?)*)>/i.exec(i);
    if (n)
      return r.append(N(T.Autolink, t, t + 1 + n[0].length, [
        N(T.LinkMark, t, t + 1),
        // url[0] includes the closing bracket, so exclude it from this slice
        N(T.URL, t + 1, t + n[0].length),
        N(T.LinkMark, t + n[0].length, t + 1 + n[0].length)
      ]));
    let s = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(i);
    if (s)
      return r.append(N(T.Comment, t, t + 1 + s[0].length));
    let o = /^\?[^]*?\?>/.exec(i);
    if (o)
      return r.append(N(T.ProcessingInstruction, t, t + 1 + o[0].length));
    let l = /^(?:![A-Z][^]*?>|!\[CDATA\[[^]*?\]\]>|\/\s*[a-zA-Z][\w-]*\s*>|\s*[a-zA-Z][\w-]*(\s+[a-zA-Z:_][\w-.:]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*(\/\s*)?>)/.exec(i);
    return l ? r.append(N(T.HTMLTag, t, t + 1 + l[0].length)) : -1;
  },
  Emphasis(r, e, t) {
    if (e != 95 && e != 42)
      return -1;
    let i = t + 1;
    for (; r.char(i) == e; )
      i++;
    let n = r.slice(t - 1, t), s = r.slice(i, i + 1), o = us.test(n), l = us.test(s), a = /\s|^$/.test(n), h = /\s|^$/.test(s), c = !h && (!l || a || o), u = !a && (!o || h || l), d = c && (e == 42 || !u || o), p = u && (e == 42 || !c || l);
    return r.append(new Qt(e == 95 ? k1 : $1, t, i, (d ? 1 : 0) | (p ? 2 : 0)));
  },
  HardBreak(r, e, t) {
    if (e == 92 && r.char(t + 1) == 10)
      return r.append(N(T.HardBreak, t, t + 2));
    if (e == 32) {
      let i = t + 1;
      for (; r.char(i) == 32; )
        i++;
      if (r.char(i) == 10 && i >= t + 2)
        return r.append(N(T.HardBreak, t, i + 1));
    }
    return -1;
  },
  Link(r, e, t) {
    return e == 91 ? r.append(new Qt(
      xn,
      t,
      t + 1,
      1
      /* Mark.Open */
    )) : -1;
  },
  Image(r, e, t) {
    return e == 33 && r.char(t + 1) == 91 ? r.append(new Qt(
      Of,
      t,
      t + 2,
      1
      /* Mark.Open */
    )) : -1;
  },
  LinkEnd(r, e, t) {
    if (e != 93)
      return -1;
    for (let i = r.parts.length - 1; i >= 0; i--) {
      let n = r.parts[i];
      if (n instanceof Qt && (n.type == xn || n.type == Of)) {
        if (!n.side || r.skipSpace(n.to) == t && !/[(\[]/.test(r.slice(t + 1, t + 2)))
          return r.parts[i] = null, -1;
        let s = r.takeContent(i), o = r.parts[i] = jT(r, s, n.type == xn ? T.Link : T.Image, n.from, t + 1);
        if (n.type == xn)
          for (let l = 0; l < i; l++) {
            let a = r.parts[l];
            a instanceof Qt && a.type == xn && (a.side = 0);
          }
        return o.to;
      }
    }
    return -1;
  }
};
function jT(r, e, t, i, n) {
  let { text: s } = r, o = r.char(n), l = n;
  if (e.unshift(N(T.LinkMark, i, i + (t == T.Image ? 2 : 1))), e.push(N(T.LinkMark, n - 1, n)), o == 40) {
    let a = r.skipSpace(n + 1), h = Q1(s, a - r.offset, r.offset), c;
    h && (a = r.skipSpace(h.to), a != h.to && (c = P1(s, a - r.offset, r.offset), c && (a = r.skipSpace(c.to)))), r.char(a) == 41 && (e.push(N(T.LinkMark, n, n + 1)), l = a + 1, h && e.push(h), c && e.push(c), e.push(N(T.LinkMark, a, l)));
  } else if (o == 91) {
    let a = T1(s, n - r.offset, r.offset, !1);
    a && (e.push(a), l = a.to);
  }
  return N(t, i, l, e);
}
function Q1(r, e, t) {
  if (r.charCodeAt(e) == 60) {
    for (let n = e + 1; n < r.length; n++) {
      let s = r.charCodeAt(n);
      if (s == 62)
        return N(T.URL, e + t, n + 1 + t);
      if (s == 60 || s == 10)
        return !1;
    }
    return null;
  } else {
    let n = 0, s = e;
    for (let o = !1; s < r.length; s++) {
      let l = r.charCodeAt(s);
      if (kt(l))
        break;
      if (o)
        o = !1;
      else if (l == 40)
        n++;
      else if (l == 41) {
        if (!n)
          break;
        n--;
      } else
        l == 92 && (o = !0);
    }
    return s > e ? N(T.URL, e + t, s + t) : s == r.length ? null : !1;
  }
}
function P1(r, e, t) {
  let i = r.charCodeAt(e);
  if (i != 39 && i != 34 && i != 40)
    return !1;
  let n = i == 40 ? 41 : i;
  for (let s = e + 1, o = !1; s < r.length; s++) {
    let l = r.charCodeAt(s);
    if (o)
      o = !1;
    else {
      if (l == n)
        return N(T.LinkTitle, e + t, s + 1 + t);
      l == 92 && (o = !0);
    }
  }
  return null;
}
function T1(r, e, t, i) {
  for (let n = !1, s = e + 1, o = Math.min(r.length, s + 999); s < o; s++) {
    let l = r.charCodeAt(s);
    if (n)
      n = !1;
    else {
      if (l == 93)
        return i ? !1 : N(T.LinkLabel, e + t, s + 1 + t);
      if (i && !kt(l) && (i = !1), l == 91)
        return !1;
      l == 92 && (n = !0);
    }
  }
  return null;
}
class LT {
  /// @internal
  constructor(e, t, i) {
    this.parser = e, this.text = t, this.offset = i, this.parts = [];
  }
  /// Get the character code at the given (document-relative)
  /// position.
  char(e) {
    return e >= this.end ? -1 : this.text.charCodeAt(e - this.offset);
  }
  /// The position of the end of this inline section.
  get end() {
    return this.offset + this.text.length;
  }
  /// Get a substring of this inline section. Again uses
  /// document-relative positions.
  slice(e, t) {
    return this.text.slice(e - this.offset, t - this.offset);
  }
  /// @internal
  append(e) {
    return this.parts.push(e), e.to;
  }
  /// Add a [delimiter](#DelimiterType) at this given position. `open`
  /// and `close` indicate whether this delimiter is opening, closing,
  /// or both. Returns the end of the delimiter, for convenient
  /// returning from [parse functions](#InlineParser.parse).
  addDelimiter(e, t, i, n, s) {
    return this.append(new Qt(e, t, i, (n ? 1 : 0) | (s ? 2 : 0)));
  }
  /// Add an inline element. Returns the end of the element.
  addElement(e) {
    return this.append(e);
  }
  /// Resolve markers between this.parts.length and from, wrapping matched markers in the
  /// appropriate node and updating the content of this.parts. @internal
  resolveMarkers(e) {
    for (let i = e; i < this.parts.length; i++) {
      let n = this.parts[i];
      if (!(n instanceof Qt && n.type.resolve && n.side & 2))
        continue;
      let s = n.type == k1 || n.type == $1, o = n.to - n.from, l, a = i - 1;
      for (; a >= e; a--) {
        let m = this.parts[a];
        if (m instanceof Qt && m.side & 1 && m.type == n.type && // Ignore emphasis delimiters where the character count doesn't match
        !(s && (n.side & 1 || m.side & 2) && (m.to - m.from + o) % 3 == 0 && ((m.to - m.from) % 3 || o % 3))) {
          l = m;
          break;
        }
      }
      if (!l)
        continue;
      let h = n.type.resolve, c = [], u = l.from, d = n.to;
      if (s) {
        let m = Math.min(2, l.to - l.from, o);
        u = l.to - m, d = n.from + m, h = m == 1 ? "Emphasis" : "StrongEmphasis";
      }
      l.type.mark && c.push(this.elt(l.type.mark, u, l.to));
      for (let m = a + 1; m < i; m++)
        this.parts[m] instanceof cs && c.push(this.parts[m]), this.parts[m] = null;
      n.type.mark && c.push(this.elt(n.type.mark, n.from, d));
      let p = this.elt(h, u, d, c);
      this.parts[a] = s && l.from != u ? new Qt(l.type, l.from, u, l.side) : null, (this.parts[i] = s && n.to != d ? new Qt(n.type, d, n.to, n.side) : null) ? this.parts.splice(i, 0, p) : this.parts[i] = p;
    }
    let t = [];
    for (let i = e; i < this.parts.length; i++) {
      let n = this.parts[i];
      n instanceof cs && t.push(n);
    }
    return t;
  }
  /// Find an opening delimiter of the given type. Returns `null` if
  /// no delimiter is found, or an index that can be passed to
  /// [`takeContent`](#InlineContext.takeContent) otherwise.
  findOpeningDelimiter(e) {
    for (let t = this.parts.length - 1; t >= 0; t--) {
      let i = this.parts[t];
      if (i instanceof Qt && i.type == e)
        return t;
    }
    return null;
  }
  /// Remove all inline elements and delimiters starting from the
  /// given index (which you should get from
  /// [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),
  /// resolve delimiters inside of them, and return them as an array
  /// of elements.
  takeContent(e) {
    let t = this.resolveMarkers(e);
    return this.parts.length = e, t;
  }
  /// Skip space after the given (document) position, returning either
  /// the position of the next non-space character or the end of the
  /// section.
  skipSpace(e) {
    return Wn(this.text, e - this.offset) + this.offset;
  }
  elt(e, t, i, n) {
    return typeof e == "string" ? N(this.parser.getNodeType(e), t, i, n) : new S1(e, t);
  }
}
function Dh(r, e) {
  if (!e.length)
    return r;
  if (!r.length)
    return e;
  let t = r.slice(), i = 0;
  for (let n of e) {
    for (; i < t.length && t[i].to < n.to; )
      i++;
    if (i < t.length && t[i].from < n.from) {
      let s = t[i];
      s instanceof cs && (t[i] = new cs(s.type, s.from, s.to, Dh(s.children, [n])));
    } else
      t.splice(i++, 0, n);
  }
  return t;
}
const BT = [T.CodeBlock, T.ListItem, T.OrderedList, T.BulletList];
class DT {
  constructor(e, t) {
    this.fragments = e, this.input = t, this.i = 0, this.fragment = null, this.fragmentEnd = -1, this.cursor = null, e.length && (this.fragment = e[this.i++]);
  }
  nextFragment() {
    this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null, this.cursor = null, this.fragmentEnd = -1;
  }
  moveTo(e, t) {
    for (; this.fragment && this.fragment.to <= e; )
      this.nextFragment();
    if (!this.fragment || this.fragment.from > (e ? e - 1 : 0))
      return !1;
    if (this.fragmentEnd < 0) {
      let s = this.fragment.to;
      for (; s > 0 && this.input.read(s - 1, s) != `
`; )
        s--;
      this.fragmentEnd = s ? s - 1 : 0;
    }
    let i = this.cursor;
    i || (i = this.cursor = this.fragment.tree.cursor(), i.firstChild());
    let n = e + this.fragment.offset;
    for (; i.to <= n; )
      if (!i.parent())
        return !1;
    for (; ; ) {
      if (i.from >= n)
        return this.fragment.from <= t;
      if (!i.childAfter(n))
        return !1;
    }
  }
  matches(e) {
    let t = this.cursor.tree;
    return t && t.prop(Y.contextHash) == e;
  }
  takeNodes(e) {
    let t = this.cursor, i = this.fragment.offset, n = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0), s = e.absoluteLineStart, o = s, l = e.block.children.length, a = o, h = l;
    for (; ; ) {
      if (t.to - i > n) {
        if (t.type.isAnonymous && t.firstChild())
          continue;
        break;
      }
      let c = C1(t.from - i, e.ranges);
      if (t.to - i <= e.ranges[e.rangeI].to)
        e.addNode(t.tree, c);
      else {
        let u = new D(e.parser.nodeSet.types[T.Paragraph], [], [], 0, e.block.hashProp);
        e.reusePlaceholders.set(u, t.tree), e.addNode(u, c);
      }
      if (t.type.is("Block") && (BT.indexOf(t.type.id) < 0 ? (o = t.to - i, l = e.block.children.length) : (o = a, l = h, a = t.to - i, h = e.block.children.length)), !t.nextSibling())
        break;
    }
    for (; e.block.children.length > l; )
      e.block.children.pop(), e.block.positions.pop();
    return o - s;
  }
}
function C1(r, e) {
  let t = r;
  for (let i = 1; i < e.length; i++) {
    let n = e[i - 1].to, s = e[i].from;
    n < r && (t -= s - n);
  }
  return t;
}
const IT = Jt({
  "Blockquote/...": O.quote,
  HorizontalRule: O.contentSeparator,
  "ATXHeading1/... SetextHeading1/...": O.heading1,
  "ATXHeading2/... SetextHeading2/...": O.heading2,
  "ATXHeading3/...": O.heading3,
  "ATXHeading4/...": O.heading4,
  "ATXHeading5/...": O.heading5,
  "ATXHeading6/...": O.heading6,
  "Comment CommentBlock": O.comment,
  Escape: O.escape,
  Entity: O.character,
  "Emphasis/...": O.emphasis,
  "StrongEmphasis/...": O.strong,
  "Link/... Image/...": O.link,
  "OrderedList/... BulletList/...": O.list,
  "BlockQuote/...": O.quote,
  "InlineCode CodeText": O.monospace,
  "URL Autolink": O.url,
  "HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark": O.processingInstruction,
  "CodeInfo LinkLabel": O.labelName,
  LinkTitle: O.string,
  Paragraph: O.content
}), UT = new Cl(new rn(v1).extend(IT), Object.keys(ro).map((r) => ro[r]), Object.keys(ro).map((r) => YT[r]), Object.keys(ro), WT, u1, Object.keys(Qa).map((r) => Qa[r]), Object.keys(Qa), []);
function GT(r, e, t) {
  let i = [];
  for (let n = r.firstChild, s = e; ; n = n.nextSibling) {
    let o = n ? n.from : t;
    if (o > s && i.push({ from: s, to: o }), !n)
      break;
    s = n.to;
  }
  return i;
}
function NT(r) {
  let { codeParser: e, htmlParser: t } = r;
  return { wrap: Lm((n, s) => {
    let o = n.type.id;
    if (e && (o == T.CodeBlock || o == T.FencedCode)) {
      let l = "";
      if (o == T.FencedCode) {
        let h = n.node.getChild(T.CodeInfo);
        h && (l = s.read(h.from, h.to));
      }
      let a = e(l);
      if (a)
        return { parser: a, overlay: (h) => h.type.id == T.CodeText };
    } else if (t && (o == T.HTMLBlock || o == T.HTMLTag))
      return { parser: t, overlay: GT(n.node, n.from, n.to) };
    return null;
  }) };
}
const FT = { resolve: "Strikethrough", mark: "StrikethroughMark" }, HT = {
  defineNodes: [{
    name: "Strikethrough",
    style: { "Strikethrough/...": O.strikethrough }
  }, {
    name: "StrikethroughMark",
    style: O.processingInstruction
  }],
  parseInline: [{
    name: "Strikethrough",
    parse(r, e, t) {
      if (e != 126 || r.char(t + 1) != 126 || r.char(t + 2) == 126)
        return -1;
      let i = r.slice(t - 1, t), n = r.slice(t + 2, t + 3), s = /\s|^$/.test(i), o = /\s|^$/.test(n), l = us.test(i), a = us.test(n);
      return r.addDelimiter(FT, t, t + 2, !o && (!a || s || l), !s && (!l || o || a));
    },
    after: "Emphasis"
  }]
};
function Vn(r, e, t = 0, i, n = 0) {
  let s = 0, o = !0, l = -1, a = -1, h = !1, c = () => {
    i.push(r.elt("TableCell", n + l, n + a, r.parser.parseInline(e.slice(l, a), n + l)));
  };
  for (let u = t; u < e.length; u++) {
    let d = e.charCodeAt(u);
    d == 124 && !h ? ((!o || l > -1) && s++, o = !1, i && (l > -1 && c(), i.push(r.elt("TableDelimiter", u + n, u + n + 1))), l = a = -1) : (h || d != 32 && d != 9) && (l < 0 && (l = u), a = u + 1), h = !h && d == 92;
  }
  return l > -1 && (s++, i && c()), s;
}
function gf(r, e) {
  for (let t = e; t < r.length; t++) {
    let i = r.charCodeAt(t);
    if (i == 124)
      return !0;
    i == 92 && t++;
  }
  return !1;
}
const X1 = /^\|?(\s*:?-+:?\s*\|)+(\s*:?-+:?\s*)?$/;
class bf {
  constructor() {
    this.rows = null;
  }
  nextLine(e, t, i) {
    if (this.rows == null) {
      this.rows = !1;
      let n;
      if ((t.next == 45 || t.next == 58 || t.next == 124) && X1.test(n = t.text.slice(t.pos))) {
        let s = [];
        Vn(e, i.content, 0, s, i.start) == Vn(e, n, t.pos) && (this.rows = [
          e.elt("TableHeader", i.start, i.start + i.content.length, s),
          e.elt("TableDelimiter", e.lineStart + t.pos, e.lineStart + t.text.length)
        ]);
      }
    } else if (this.rows) {
      let n = [];
      Vn(e, t.text, t.pos, n, e.lineStart), this.rows.push(e.elt("TableRow", e.lineStart + t.pos, e.lineStart + t.text.length, n));
    }
    return !1;
  }
  finish(e, t) {
    return this.rows ? (e.addLeafElement(t, e.elt("Table", t.start, t.start + t.content.length, this.rows)), !0) : !1;
  }
}
const KT = {
  defineNodes: [
    { name: "Table", block: !0 },
    { name: "TableHeader", style: { "TableHeader/...": O.heading } },
    "TableRow",
    { name: "TableCell", style: O.content },
    { name: "TableDelimiter", style: O.processingInstruction }
  ],
  parseBlock: [{
    name: "Table",
    leaf(r, e) {
      return gf(e.content, 0) ? new bf() : null;
    },
    endLeaf(r, e, t) {
      if (t.parsers.some((n) => n instanceof bf) || !gf(e.text, e.basePos))
        return !1;
      let i = r.scanLine(r.absoluteLineEnd + 1).text;
      return X1.test(i) && Vn(r, e.text, e.basePos) == Vn(r, i, e.basePos);
    },
    before: "SetextHeading"
  }]
};
class JT {
  nextLine() {
    return !1;
  }
  finish(e, t) {
    return e.addLeafElement(t, e.elt("Task", t.start, t.start + t.content.length, [
      e.elt("TaskMarker", t.start, t.start + 3),
      ...e.parser.parseInline(t.content.slice(3), t.start + 3)
    ])), !0;
  }
}
const e5 = {
  defineNodes: [
    { name: "Task", block: !0, style: O.list },
    { name: "TaskMarker", style: O.atom }
  ],
  parseBlock: [{
    name: "TaskList",
    leaf(r, e) {
      return /^\[[ xX]\][ \t]/.test(e.content) && r.parentType().name == "ListItem" ? new JT() : null;
    },
    after: "SetextHeading"
  }]
}, wf = /(www\.)|(https?:\/\/)|([\w.+-]+@)|(mailto:|xmpp:)/gy, yf = /[\w-]+(\.[\w-]+)+(\/[^\s<]*)?/gy, t5 = /[\w-]+\.[\w-]+($|\/)/, vf = /[\w.+-]+@[\w-]+(\.[\w.-]+)+/gy, xf = /\/[a-zA-Z\d@.]+/gy;
function Sf(r, e, t, i) {
  let n = 0;
  for (let s = e; s < t; s++)
    r[s] == i && n++;
  return n;
}
function r5(r, e) {
  yf.lastIndex = e;
  let t = yf.exec(r);
  if (!t || t5.exec(t[0])[0].indexOf("_") > -1)
    return -1;
  let i = e + t[0].length;
  for (; ; ) {
    let n = r[i - 1], s;
    if (/[?!.,:*_~]/.test(n) || n == ")" && Sf(r, e, i, ")") > Sf(r, e, i, "("))
      i--;
    else if (n == ";" && (s = /&(?:#\d+|#x[a-f\d]+|\w+);$/.exec(r.slice(e, i))))
      i = e + s.index;
    else
      break;
  }
  return i;
}
function kf(r, e) {
  vf.lastIndex = e;
  let t = vf.exec(r);
  if (!t)
    return -1;
  let i = t[0][t[0].length - 1];
  return i == "_" || i == "-" ? -1 : e + t[0].length - (i == "." ? 1 : 0);
}
const i5 = {
  parseInline: [{
    name: "Autolink",
    parse(r, e, t) {
      let i = t - r.offset;
      wf.lastIndex = i;
      let n = wf.exec(r.text), s = -1;
      return !n || (n[1] || n[2] ? s = r5(r.text, i + n[0].length) : n[3] ? s = kf(r.text, i) : (s = kf(r.text, i + n[0].length), s > -1 && n[0] == "xmpp:" && (xf.lastIndex = s, n = xf.exec(r.text), n && (s = n.index + n[0].length))), s < 0) ? -1 : (r.addElement(r.elt("URL", t, s + r.offset)), s + r.offset);
    }
  }]
}, n5 = [KT, e5, HT, i5];
function Z1(r, e, t) {
  return (i, n, s) => {
    if (n != r || i.char(s + 1) == r)
      return -1;
    let o = [i.elt(t, s, s + 1)];
    for (let l = s + 1; l < i.end; l++) {
      let a = i.char(l);
      if (a == r)
        return i.addElement(i.elt(e, s, l + 1, o.concat(i.elt(t, l, l + 1))));
      if (a == 92 && o.push(i.elt("Escape", l, l++ + 2)), kt(a))
        break;
    }
    return -1;
  };
}
const s5 = {
  defineNodes: [
    { name: "Superscript", style: O.special(O.content) },
    { name: "SuperscriptMark", style: O.processingInstruction }
  ],
  parseInline: [{
    name: "Superscript",
    parse: Z1(94, "Superscript", "SuperscriptMark")
  }]
}, o5 = {
  defineNodes: [
    { name: "Subscript", style: O.special(O.content) },
    { name: "SubscriptMark", style: O.processingInstruction }
  ],
  parseInline: [{
    name: "Subscript",
    parse: Z1(126, "Subscript", "SubscriptMark")
  }]
}, l5 = {
  defineNodes: [{ name: "Emoji", style: O.character }],
  parseInline: [{
    name: "Emoji",
    parse(r, e, t) {
      let i;
      return e != 58 || !(i = /^[a-zA-Z_0-9]+:/.exec(r.slice(t + 1, r.end))) ? -1 : r.addElement(r.elt("Emoji", t, t + 1 + i[0].length));
    }
  }]
}, _1 = /* @__PURE__ */ gl({ commentTokens: { block: { open: "<!--", close: "-->" } } }), R1 = /* @__PURE__ */ new Y(), A1 = /* @__PURE__ */ UT.configure({
  props: [
    /* @__PURE__ */ fr.add((r) => !r.is("Block") || r.is("Document") || Ih(r) != null ? void 0 : (e, t) => ({ from: t.doc.lineAt(e.from).to, to: e.to })),
    /* @__PURE__ */ R1.add(Ih),
    /* @__PURE__ */ Br.add({
      Document: () => null
    }),
    /* @__PURE__ */ kr.add({
      Document: _1
    })
  ]
});
function Ih(r) {
  let e = /^(?:ATX|Setext)Heading(\d)$/.exec(r.name);
  return e ? +e[1] : void 0;
}
function a5(r, e) {
  let t = r;
  for (; ; ) {
    let i = t.nextSibling, n;
    if (!i || (n = Ih(i.type)) != null && n <= e)
      break;
    t = i;
  }
  return t.to;
}
const h5 = /* @__PURE__ */ Fm.of((r, e, t) => {
  for (let i = te(r).resolveInner(t, -1); i && !(i.from < e); i = i.parent) {
    let n = i.type.prop(R1);
    if (n == null)
      continue;
    let s = a5(i, n);
    if (s > t)
      return { from: t, to: s };
  }
  return null;
});
function su(r) {
  return new nt(_1, r, [h5], "markdown");
}
const c5 = /* @__PURE__ */ su(A1), u5 = /* @__PURE__ */ A1.configure([n5, o5, s5, l5, {
  props: [
    /* @__PURE__ */ fr.add({
      Table: (r, e) => ({ from: e.doc.lineAt(r.from).to, to: r.to })
    })
  ]
}]), E1 = /* @__PURE__ */ su(u5);
function d5(r, e) {
  return (t) => {
    if (t && r) {
      let i = null;
      if (t = /\S*/.exec(t)[0], typeof r == "function" ? i = r(t) : i = Yo.matchLanguageName(r, t, !0), i instanceof Yo)
        return i.support ? i.support.language.parser : pi.getSkippingParser(i.load());
      if (i)
        return i.parser;
    }
    return e ? e.parser : null;
  };
}
class no {
  constructor(e, t, i, n, s, o, l) {
    this.node = e, this.from = t, this.to = i, this.spaceBefore = n, this.spaceAfter = s, this.type = o, this.item = l;
  }
  blank(e, t = !0) {
    let i = this.spaceBefore + (this.node.name == "Blockquote" ? ">" : "");
    if (e != null) {
      for (; i.length < e; )
        i += " ";
      return i;
    } else {
      for (let n = this.to - this.from - i.length - this.spaceAfter.length; n > 0; n--)
        i += " ";
      return i + (t ? this.spaceAfter : "");
    }
  }
  marker(e, t) {
    let i = this.node.name == "OrderedList" ? String(+z1(this.item, e)[2] + t) : "";
    return this.spaceBefore + i + this.type + this.spaceAfter;
  }
}
function q1(r, e) {
  let t = [];
  for (let n = r; n && n.name != "Document"; n = n.parent)
    (n.name == "ListItem" || n.name == "Blockquote" || n.name == "FencedCode") && t.push(n);
  let i = [];
  for (let n = t.length - 1; n >= 0; n--) {
    let s = t[n], o, l = e.lineAt(s.from), a = s.from - l.from;
    if (s.name == "FencedCode")
      i.push(new no(s, a, a, "", "", "", null));
    else if (s.name == "Blockquote" && (o = /^ *>( ?)/.exec(l.text.slice(a))))
      i.push(new no(s, a, a + o[0].length, "", o[1], ">", null));
    else if (s.name == "ListItem" && s.parent.name == "OrderedList" && (o = /^( *)\d+([.)])( *)/.exec(l.text.slice(a)))) {
      let h = o[3], c = o[0].length;
      h.length >= 4 && (h = h.slice(0, h.length - 4), c -= 4), i.push(new no(s.parent, a, a + c, o[1], h, o[2], s));
    } else if (s.name == "ListItem" && s.parent.name == "BulletList" && (o = /^( *)([-+*])( {1,4}\[[ xX]\])?( +)/.exec(l.text.slice(a)))) {
      let h = o[4], c = o[0].length;
      h.length > 4 && (h = h.slice(0, h.length - 4), c -= 4);
      let u = o[2];
      o[3] && (u += o[3].replace(/[xX]/, " ")), i.push(new no(s.parent, a, a + c, o[1], h, u, s));
    }
  }
  return i;
}
function z1(r, e) {
  return /^(\s*)(\d+)(?=[.)])/.exec(e.sliceString(r.from, r.from + 10));
}
function Pa(r, e, t, i = 0) {
  for (let n = -1, s = r; ; ) {
    if (s.name == "ListItem") {
      let l = z1(s, e), a = +l[2];
      if (n >= 0) {
        if (a != n + 1)
          return;
        t.push({ from: s.from + l[1].length, to: s.from + l[0].length, insert: String(n + 2 + i) });
      }
      n = a;
    }
    let o = s.nextSibling;
    if (!o)
      break;
    s = o;
  }
}
function ou(r, e) {
  let t = /^[ \t]*/.exec(r)[0].length;
  if (!t || e.facet(fi) != "	")
    return r;
  let i = Tt(r, 4, t), n = "";
  for (let s = i; s > 0; )
    s >= 4 ? (n += "	", s -= 4) : (n += " ", s--);
  return n + r.slice(t);
}
const p5 = ({ state: r, dispatch: e }) => {
  let t = te(r), { doc: i } = r, n = null, s = r.changeByRange((o) => {
    if (!o.empty || !E1.isActiveAt(r, o.from))
      return n = { range: o };
    let l = o.from, a = i.lineAt(l), h = q1(t.resolveInner(l, -1), i);
    for (; h.length && h[h.length - 1].from > l - a.from; )
      h.pop();
    if (!h.length)
      return n = { range: o };
    let c = h[h.length - 1];
    if (c.to - c.spaceAfter.length > l - a.from)
      return n = { range: o };
    let u = l >= c.to - c.spaceAfter.length && !/\S/.test(a.text.slice(c.to));
    if (c.item && u) {
      let g = c.node.firstChild, b = c.node.getChild("ListItem", "ListItem");
      if (g.to >= l || b && b.to < l || a.from > 0 && !/[^\s>]/.test(i.lineAt(a.from - 1).text)) {
        let v = h.length > 1 ? h[h.length - 2] : null, k, $ = "";
        v && v.item ? (k = a.from + v.from, $ = v.marker(i, 1)) : k = a.from + (v ? v.to : 0);
        let x = [{ from: k, to: l, insert: $ }];
        return c.node.name == "OrderedList" && Pa(c.item, i, x, -2), v && v.node.name == "OrderedList" && Pa(v.item, i, x), { range: S.cursor(k + $.length), changes: x };
      } else {
        let v = Qf(h, r, a);
        return {
          range: S.cursor(l + v.length + 1),
          changes: { from: a.from, insert: v + r.lineBreak }
        };
      }
    }
    if (c.node.name == "Blockquote" && u && a.from) {
      let g = i.lineAt(a.from - 1), b = />\s*$/.exec(g.text);
      if (b && b.index == c.from) {
        let v = r.changes([
          { from: g.from + b.index, to: g.to },
          { from: a.from + c.from, to: a.to }
        ]);
        return { range: o.map(v), changes: v };
      }
    }
    let d = [];
    c.node.name == "OrderedList" && Pa(c.item, i, d);
    let p = c.item && c.item.from < a.from, f = "";
    if (!p || /^[\s\d.)\-+*>]*/.exec(a.text)[0].length >= c.to)
      for (let g = 0, b = h.length - 1; g <= b; g++)
        f += g == b && !p ? h[g].marker(i, 1) : h[g].blank(g < b ? Tt(a.text, 4, h[g + 1].from) - f.length : null);
    let m = l;
    for (; m > a.from && /\s/.test(a.text.charAt(m - a.from - 1)); )
      m--;
    return f = ou(f, r), f5(c.node, r.doc) && (f = Qf(h, r, a) + r.lineBreak + f), d.push({ from: m, to: l, insert: r.lineBreak + f }), { range: S.cursor(m + f.length + 1), changes: d };
  });
  return n ? !1 : (e(r.update(s, { scrollIntoView: !0, userEvent: "input" })), !0);
};
function $f(r) {
  return r.name == "QuoteMark" || r.name == "ListMark";
}
function f5(r, e) {
  if (r.name != "OrderedList" && r.name != "BulletList")
    return !1;
  let t = r.firstChild, i = r.getChild("ListItem", "ListItem");
  if (!i)
    return !1;
  let n = e.lineAt(t.to), s = e.lineAt(i.from), o = /^[\s>]*$/.test(n.text);
  return n.number + (o ? 0 : 1) < s.number;
}
function Qf(r, e, t) {
  let i = "";
  for (let n = 0, s = r.length - 2; n <= s; n++)
    i += r[n].blank(n < s ? Tt(t.text, 4, r[n + 1].from) - i.length : null, n < s);
  return ou(i, e);
}
function O5(r, e) {
  let t = r.resolveInner(e, -1), i = e;
  $f(t) && (i = t.from, t = t.parent);
  for (let n; n = t.childBefore(i); )
    if ($f(n))
      i = n.from;
    else if (n.name == "OrderedList" || n.name == "BulletList")
      t = n.lastChild, i = t.to;
    else
      break;
  return t;
}
const m5 = ({ state: r, dispatch: e }) => {
  let t = te(r), i = null, n = r.changeByRange((s) => {
    let o = s.from, { doc: l } = r;
    if (s.empty && E1.isActiveAt(r, s.from)) {
      let a = l.lineAt(o), h = q1(O5(t, o), l);
      if (h.length) {
        let c = h[h.length - 1], u = c.to - c.spaceAfter.length + (c.spaceAfter ? 1 : 0);
        if (o - a.from > u && !/\S/.test(a.text.slice(u, o - a.from)))
          return {
            range: S.cursor(a.from + u),
            changes: { from: a.from + u, to: o }
          };
        if (o - a.from == u && // Only apply this if we're on the line that has the
        // construct's syntax, or there's only indentation in the
        // target range
        (!c.item || a.from <= c.item.from || !/\S/.test(a.text.slice(0, c.to)))) {
          let d = a.from + c.from;
          if (c.item && c.node.from < c.item.from && /\S/.test(a.text.slice(c.from, c.to))) {
            let p = c.blank(Tt(a.text, 4, c.to) - Tt(a.text, 4, c.from));
            return d == a.from && (p = ou(p, r)), {
              range: S.cursor(d + p.length),
              changes: { from: d, to: a.from + c.to, insert: p }
            };
          }
          if (d < o)
            return { range: S.cursor(d), changes: { from: d, to: o } };
        }
      }
    }
    return i = { range: s };
  });
  return i ? !1 : (e(r.update(n, { scrollIntoView: !0, userEvent: "delete" })), !0);
}, g5 = [
  { key: "Enter", run: p5 },
  { key: "Backspace", run: m5 }
], Uh = /* @__PURE__ */ c1({ matchClosingTags: !1 });
function b5(r = {}) {
  let { codeLanguages: e, defaultCodeLanguage: t, addKeymap: i = !0, base: { parser: n } = c5, completeHTMLTags: s = !0 } = r;
  if (!(n instanceof Cl))
    throw new RangeError("Base parser provided to `markdown` should be a Markdown parser");
  let o = r.extensions ? [r.extensions] : [], l = [Uh.support], a;
  t instanceof cr ? (l.push(t.support), a = t.language) : t && (a = t);
  let h = e || a ? d5(e, a) : void 0;
  o.push(NT({ codeParser: h, htmlParser: Uh.language.parser })), i && l.push(Lr.high(tn.of(g5)));
  let c = su(n.configure(o));
  return s && l.push(c.data.of({ autocomplete: w5 })), new cr(c, l);
}
function w5(r) {
  let { state: e, pos: t } = r, i = /<[:\-\.\w\u00b7-\uffff]*$/.exec(e.sliceDoc(t - 25, t));
  if (!i)
    return null;
  let n = te(e).resolveInner(t, -1);
  for (; n && !n.type.isTop; ) {
    if (n.name == "CodeBlock" || n.name == "FencedCode" || n.name == "ProcessingInstructionBlock" || n.name == "CommentBlock" || n.name == "Link" || n.name == "Image")
      return null;
    n = n.parent;
  }
  return {
    from: t - i[0].length,
    to: t,
    options: y5(),
    validFor: /^<[:\-\.\w\u00b7-\uffff]*$/
  };
}
let Ta = null;
function y5() {
  if (Ta)
    return Ta;
  let r = QT(new Bc(U.create({ extensions: Uh }), 0, !0));
  return Ta = r ? r.options : [];
}
const v5 = 1, x5 = 2, S5 = -1, k5 = 10, $5 = 46, Q5 = 32, P5 = 9, T5 = new Ae((r) => {
  r.next === $5 && (r.advance(), r.next === S5 || r.next === k5 || r.next === Q5 || r.next == P5 ? r.acceptToken(x5) : r.acceptToken(v5));
}), C5 = { __proto__: null, discontiguous: 18, dynamic: 20, initialization: 22, meta_predicate: 24, module_transparent: 26, multifile: 28, public: 30, table: 32, thread_initialization: 34, thread_local: 36, volatile: 38, div: 104, mod: 106, rdiv: 108, rem: 110, xor: 112, as: 254, in: 256, in_set: 258, ins: 260, is: 262 }, X5 = Ft.deserialize({
  version: 14,
  states: "0bQ]QTOOO&{QTO'#CsO+rQTO'#DRO0fQTO'#DgOOQS'#Fw'#FwO]QTO'#EtO5VQUO'#EvO9sQPO'#EuO9xQTO'#EyO:PQTO'#E}OOQS'#Fv'#FvO:WQTO'#DkOOQS'#Fu'#FuO>kQUO'#FsOOQS'#Ft'#FtOOQS'#Fs'#FsOCsQUO'#FqOOQS'#Fr'#FrOOQS'#Fq'#FqOGdQUO'#FoOOQS'#Fp'#FpOOQS'#Fo'#FoOKOQUO'#FnOOQS'#Fn'#FnOOQS'#Fm'#FmONZQUO'#FkOOQS'#Fl'#FlO! hQUO'#FjOOQS'#Fk'#FkO!!rQUO'#FiOOQS'#Fj'#FjOOQS'#Fi'#FiO!#yQUO'#FgOOQS'#Fh'#FhO!$zQUO'#FfOOQS'#Fg'#FgOOQS'#Ff'#FfOOQS'#Fe'#FeO!%xQUO'#FdO!&pQTO'#FcOOQS'#Fc'#FcO!'eQTO'#FbOOQS'#Fb'#FbO!(SQTO'#FaOOQS'#Fa'#FaOOQS'#F`'#F`O!(nQTO'#F_O!)VQTO'#FWO!)VQTO'#FXOOQS'#F_'#F_Q]QTOOO&{QTO'#CcO!)|QTO'#FZOOQS,59_,59_OOQS,59m,59mOOQS,5:R,5:RO!*RQPO,5;`O!*WQTO,5;gO!*_QTO,5;aOOQS,5;e,5;eO!*fQPO,5;eOOQS,5;i,5;iO!*kQPO,5;iOOQS,5:V,5:VO!*pQTO,5:UO!*pQTO,5:TO0fQTO,5;jO0fQTO,59vO0fQTO,59uO0fQTO,59pO0fQTO,59oO0fQTO,59nO+rQTO,59kO+rQTO,59iO+rQTO,59gO+rQTO,59fO+rQTO,59dO+rQTO,59bO+rQTO,59aO&{QTO,5<OO&{QTO,59^O&{QTO,59]O&{QTO,59[O!)VQTO,58|OOQS,5;r,5;rOOQS,5;s,5;sOOQS-E9X-E9XOOQS,58},58}OOQS,5;u,5;uOOQS1G0z1G0zOOQS1G1R1G1RO!*wQPO1G1ROOQS1G0{1G0{O!*|QPO1G0{OOQS1G1P1G1POOQS1G1T1G1TOOQS1G/p1G/pO!+RQUO1G/oOOQS1G1U1G1UOOQS1G/b1G/bO!/cQUO1G/aOOQS1G/[1G/[OOQS1G/Z1G/ZOOQS1G/Y1G/YOOQS1G/V1G/VO!3PQUO1G/TO!4^QUO1G/ROOQS1G/Q1G/QOOQS1G/O1G/OO!5hQUO1G.|O!6iQUO1G.{OOQS1G1j1G1jOOQS1G.x1G.xOOQS1G.w1G.wOOQS1G.v1G.vOOQS1G.h1G.hOOQS7+&m7+&mOOQS7+&g7+&g",
  stateData: "!7d~O$QOSROSSOS~OPSOWSOX!TOY!TOZ!TO[!TO]!TO^!TO_!TO`!TOa!TOb!TOc!TOhPOkSOmSOpSOrQOtSOyROzRO{SO|SO!PSO!QSO!RSO!SSO!TSO![RO!`ZO!aSO!bSO!cSO!dSO!eSO!fSO!gSO!hSO!iSO!jSO!kSO!lSO!mSO!nSO!oSO!pSO!qSO!rSO!sSO!tSO!uSO!vSO!wSO!xSO!ySO!zSO!{SO!|SO!}SO#OSO#PSO#QSO#RSO#SSO#TSO#USO#VSO#WSO#XSO#YYO#ZYO#[YO#]YO#^YO#_YO#`YO#aYO#bYO#cYO#dYO#eYO#gTO#lWO#pXO#y!PO#|!QO~OPSOWSOhPOkSOmSOpSOrQOtSOyROzRO{SO|SO!PSO!QSO!RSO!SSO!TSO![RO!`ZO!aSO!bSO!cSO!dSO!eSO!fSO!gSO!hSO!iSO!jSO!kSO!lSO!mSO!nSO!oSO!pSO!qSO!rSO!sSO!tSO!uSO!vSO!wSO!xSO!ySO!zSO!{SO!|SO!}SO#OSO#PSO#QSO#RSO#SSO#TSO#USO#VSO#WSO#XSO#YYO#ZYO#[YO#]YO#^YO#_YO#`YO#aYO#bYO#cYO#dYO#eYO#gTO#lWO#pXO~OPSOWSOkSOmSOpSOrQOtSOyROzRO{SO|SO!PSO!QSO!RSO!SSO!TSO![RO!`ZO!aSO!bSO!cSO!dSO!eSO!fSO!gSO!hSO!iSO!jSO!kSO!lSO!mSO!nSO!oSO!pSO!qSO!rSO!sSO!tSO!uSO!vSO!wSO!xSO!ySO!zSO!{SO!|SO!}SO#OSO#PSO#QSO#RSO#SSO#TSO#USO#VSO#WSO#XSO#YYO#ZYO#[YO#]YO#^YO#_YO#`YO#aYO#bYO#cYO#dYO#eYO#gTO#lWO#pXO~OPSOWSOkSOmSOpSOtSOyROzRO{SO|SO!PSO!QSO!RSO!SSO!TSO![RO!`ZO!aSO!bSO!cSO!dSO!eSO!fSO!gSO!hSO!iSO!jSO!kSO!lSO!mSO!nSO!oSO!pSO!qSO!rSO!sSO!tSO!uSO!vSO!wSO!xSO!ySO!zSO!{SO!|SO!}SO#OSO#PSO#QSO#RSO#SSO#TSO#USO#VSO#WSO#XSO#YYO#ZYO#[YO#]YO#^YO#_YO#`YO#aYO#bYO#cYO#dYO#eYO#gTO#lWO#pXO~O#p!ZOP$jXQ$jXk$jXm$jXp$jXr$jXt$jXy$jXz$jX{$jX|$jX!P$jX!Q$jX!R$jX!S$jX!T$jX!U$jX!V$jX!W$jX!X$jX!Y$jX!b$jX!c$jX!d$jX!e$jX!f$jX!g$jX!h$jX!i$jX!j$jX!l$jX!m$jX!n$jX!o$jX!p$jX!q$jX!r$jX!s$jX!t$jX!u$jX!v$jX!w$jX!x$jX!y$jX!z$jX!{$jX!|$jX!}$jX#O$jX#P$jX#Q$jX#R$jX#S$jX#T$jX#U$jX#V$jX#W$jX#X$jX#g#jX#s$jX#t$jX#u$jX#v$jX#w$jX#x$jX#y$jX#f$jX#k$jX#n$jX~O#g![O~O#k!]O~P]O#n!_O~P]OPSOWSOkSOmSOpSOtSO{SO|SO!PSO!QSO!RSO!SSO!TSO!aSO!bSO!cSO!dSO!eSO!fSO!gSO!hSO!iSO!jSO!kSO!lSO!mSO!nSO!oSO!pSO!qSO!rSO!sSO!tSO!uSO!vSO!wSO!xSO!ySO!zSO!{SO!|SO!}SO#OSO#PSO#QSO#RSO#SSO#TSO#USO#VSO#WSO#XSO#YYO#ZYO#[YO#]YO#^YO#_YO#`YO#aYO#bYO#cYO#dYO#eYO#gTO#lWO#pXO~OP!bO!i!cO#W!dOQ$gXk$gXm$gXp$gXr$gXt$gXy$gXz$gX{$gX|$gX!P$gX!Q$gX!R$gX!S$gX!T$gX!U$gX!V$gX!W$gX!X$gX!Y$gX!b$gX!c$gX!d$gX!e$gX!f$gX!g$gX!h$gX!j$gX!l$gX!m$gX!n$gX!o$gX!p$gX!q$gX!r$gX!s$gX!t$gX!u$gX!v$gX!w$gX!x$gX!y$gX!z$gX!{$gX!|$gX!}$gX#O$gX#P$gX#Q$gX#R$gX#S$gX#T$gX#U$gX#V$gX#X$gX#s$gX#t$gX#u$gX#v$gX#w$gX#x$gX#y$gX#f$gX#k$gX#n$gX~O!P!eO!Q!eO!R!eO!S!eO!T!eO!U!eO!V!eO!W!eO!X!eO!Y!eO~O!n!fOQ$eXk$eXm$eXp$eXr$eXt$eXy$eXz$eX{$eX|$eX!b$eX!c$eX!d$eX!e$eX!f$eX!g$eX!h$eX!j$eX!l$eX!m$eX!o$eX!p$eX!q$eX!r$eX!s$eX!t$eX!u$eX!v$eX!w$eX!x$eX!y$eX!z$eX!{$eX!|$eX!}$eX#O$eX#P$eX#Q$eX#R$eX#S$eX#T$eX#U$eX#V$eX#X$eX#s$eX#t$eX#u$eX#v$eX#w$eX#x$eX#y$eX#f$eX#k$eX#n$eX~PCROy!gOz!gO{!gO|!gO!o!hOQ$cXk$cXm$cXp$cXr$cXt$cX!b$cX!c$cX!d$cX!e$cX!f$cX!g$cX!h$cX!j$cX!l$cX!m$cX!p$cX!q$cX!r$cX!s$cX!t$cX!u$cX!v$cX!w$cX!x$cX!y$cX!z$cX!{$cX!|$cX!}$cX#O$cX#P$cX#Q$cX#R$cX#S$cX#T$cX#U$cX#V$cX#X$cX#s$cX#t$cX#u$cX#v$cX#w$cX#x$cX#y$cX#f$cX#k$cX#n$cX~O!b!iO!c!iO!d!iO!f!iO!g!iO!h!iO!p!iO!s!iO!t!iO!u!iO!v!iO!w!iO!x!iO!z!iO!{!iO!|!iO!}!iO#O!iO#P!iO#Q!iO#R!iO#S!iO#T!iO#U!iO#V!iO#s!iO#t!iO#u!iO#v!iO#w!iOQ$bXk$bXm$bXp$bXr$bXt$bX!e$bX!j$bX!l$bX!m$bX!q$bX!r$bX!y$bX#X$bX#x$bX#y$bX#f$bX#k$bX#n$bX~Ot!jOQ$_Xk$_Xm$_Xp$_Xr$_X!e$_X!j$_X!l$_X!m$_X!q$_X!r$_X!y$_X#X$_X#x$_X#y$_X#f$_X#k$_X#n$_X~Or!kOQ$^Xk$^Xm$^Xp$^X!e$^X!j$^X!l$^X!m$^X!q$^X!r$^X!y$^X#X$^X#x$^X#y$^X#f$^X#k$^X#n$^X~Op!lO!e!mOQ$]Xk$]Xm$]X!j$]X!l$]X!m$]X!q$]X!r$]X!y$]X#X$]X#x$]X#y$]X#f$]X#k$]X#n$]X~Om!nOQ$ZXk$ZX!j$ZX!l$ZX!m$ZX!q$ZX!r$ZX!y$ZX#X$ZX#x$ZX#y$ZX#f$ZX#k$ZX#n$ZX~Ok!oO!q!pOQ$YX!j$YX!l$YX!m$YX!r$YX!y$YX#X$YX#x$YX#y$YX#f$YX#k$YX#n$YX~O#x!qOQ$WX!j$WX!l$WX!m$WX!r$WX!y$WX#X$WX#y$WX#f$WX#k$WX#n$WX~O!j!rO!m!rOQ$VX!l$VX!r$VX!y$VX#X$VX#y$VX#f$VX#k$VX#n$VX~O!r!sOQ$UX!l$UX!y$UX#X$UX#y$UX#f$UX#k$UX#n$UX~O#X!tOQ$TX!l$TX!y$TX#y$TX#f$TX#k$TX#n$TX~O!l!uO!y!uO#y!uOQ$RX#f$RX#k$RX#n$RX~OX!TOY!TOZ!TO[!TO]!TO^!TO_!TO`!TOa!TOb!TOc!TO~P&{OQ!zO~O#f!{O~O#n!|O~P]O#f#OO~P]O#k#QO~O#n#RO~O!`ZO~P:WO#n#hO~O#f#iO~OP!bOQ!]ik!]im!]ip!]ir!]it!]iy!]iz!]i{!]i|!]i!P!]i!Q!]i!R!]i!S!]i!T!]i!U!]i!V!]i!W!]i!X!]i!Y!]i!b!]i!c!]i!d!]i!e!]i!f!]i!g!]i!h!]i!j!]i!l!]i!m!]i!n!]i!o!]i!p!]i!q!]i!r!]i!s!]i!t!]i!u!]i!v!]i!w!]i!x!]i!y!]i!z!]i!{!]i!|!]i!}!]i#O!]i#P!]i#Q!]i#R!]i#S!]i#T!]i#U!]i#V!]i#X!]i#s!]i#t!]i#u!]i#v!]i#w!]i#x!]i#y!]i#f!]i#k!]i#n!]i~OQ}ik}im}ip}ir}it}iy}iz}i{}i|}i!b}i!c}i!d}i!e}i!f}i!g}i!h}i!j}i!l}i!m}i!o}i!p}i!q}i!r}i!s}i!t}i!u}i!v}i!w}i!x}i!y}i!z}i!{}i!|}i!}}i#O}i#P}i#Q}i#R}i#S}i#T}i#U}i#V}i#X}i#s}i#t}i#u}i#v}i#w}i#x}i#y}i#f}i#k}i#n}i~PCROt!jOQqikqimqipqirqi!eqi!jqi!lqi!mqi!qqi!rqi!yqi#Xqi#xqi#yqi#fqi#kqi#nqi~Or!kOQoikoimoipoi!eoi!joi!loi!moi!qoi!roi!yoi#Xoi#xoi#yoi#foi#koi#noi~Om!nOQjikji!jji!lji!mji!qji!rji!yji#Xji#xji#yji#fji#kji#nji~Ok!oOQii!jii!lii!mii!rii!yii#Xii#xii#yii#fii#kii#nii~O",
  goto: ">f$lPPPPPP$m$vPPPPPPPPPPPP%S%b%q&RP&e&wP'[P'p(WP(nP)VP)o*Z*u+cPPPP,P,nPPPPPPPPPP-^P-^.P.sPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP/h/h0^PP/hP/hP/h-^PPPPPPP$m$mP1SPPP1Y1m2P2c2t3W3k&R4P4f4|5h6O6i7T)o7s8e9R9r:d;]<R<x=p_!ROTWX!S!Z![e}OTWX!P!Q!S!Z![!ui|OTWX!P!Q!S!T!Z![!t!ukzOTWX!P!Q!S!T!Z![!s!t!umxOTWX!P!Q!S!T!Z![!r!s!t!uquOPTWX!P!Q!S!T!Z![!q!r!s!t!uqtOPTWX!P!Q!S!T!Z![!q!r!s!t!ussOPTWX!P!Q!S!T!Z![!p!q!r!s!t!uuqOPTWX!P!Q!S!T!Z![!o!p!q!r!s!t!uyoOPTWX!P!Q!S!T!Z![!m!n!o!p!q!r!s!t!uynOPTWX!P!Q!S!T!Z![!m!n!o!p!q!r!s!t!u{lOPTWX!P!Q!S!T!Z![!l!m!n!o!p!q!r!s!t!u}jOPTWX!P!Q!S!T!Z![!k!l!m!n!o!p!q!r!s!t!u!RhOPQTWX!P!Q!S!T!Z![!j!k!l!m!n!o!p!q!r!s!t!u!RgOPQTWX!P!Q!S!T!Z![!j!k!l!m!n!o!p!q!r!s!t!u!VeOPQTWX!P!Q!S!T!Z![!h!i!j!k!l!m!n!o!p!q!r!s!t!u!VdOPQTWX!P!Q!S!T!Z![!h!i!j!k!l!m!n!o!p!q!r!s!t!u!XbOPQTWX!P!Q!S!T!Z![!g!h!i!j!k!l!m!n!o!p!q!r!s!t!u!ZaOPQTWX!P!Q!S!T!Z![!f!g!h!i!j!k!l!m!n!o!p!q!r!s!t!u!a_OPQRTWX!P!Q!S!T!Z![!d!e!f!g!h!i!j!k!l!m!n!o!p!q!r!s!t!u!c^OPQRTWX!P!Q!S!T!Z![!c!d!e!f!g!h!i!j!k!l!m!n!o!p!q!r!s!t!u!e[OPQRTWX!P!Q!S!T!Z![!b!c!d!e!f!g!h!i!j!k!l!m!n!o!p!q!r!s!t!u!gYOPQRTWXZ!P!Q!S!T!Z![!b!c!d!e!f!g!h!i!j!k!l!m!n!o!p!q!r!s!t!u!gVOPQRTWXZ!P!Q!S!T!Z![!b!c!d!e!f!g!h!i!j!k!l!m!n!o!p!q!r!s!t!uQ!SOR!x!SS!UO!SQ!YTQ!^WQ!`XQ!}!ZR#P![^!OOTWX!S!Z![Q!v!PQ!w!QR#g!ud}OTWX!P!Q!S!Z![!uQ!y!TR#f!th{OTWX!P!Q!S!T!Z![!t!uR#e!sjyOTWX!P!Q!S!T!Z![!s!t!uR#d!rlwOTWX!P!Q!S!T!Z![!r!s!t!uR#c!qnvOTWX!P!Q!S!T!Z![!q!r!s!t!uR!VPprOPTWX!P!Q!S!T!Z![!q!r!s!t!uR#b!prpOPTWX!P!Q!S!T!Z![!p!q!r!s!t!uR#a!otqOPTWX!P!Q!S!T!Z![!o!p!q!r!s!t!uQ#_!mR#`!nymOPTWX!P!Q!S!T!Z![!m!n!o!p!q!r!s!t!uxkOPTWX!P!Q!S!T!Z![!m!n!o!p!q!r!s!t!uR#^!lziOPTWX!P!Q!S!T!Z![!l!m!n!o!p!q!r!s!t!uR#]!k|jOPTWX!P!Q!S!T!Z![!k!l!m!n!o!p!q!r!s!t!uQ!WQR#[!j!QfOPQTWX!P!Q!S!T!Z![!j!k!l!m!n!o!p!q!r!s!t!uQ#Y!hR#Z!i!VcOPQTWX!P!Q!S!T!Z![!h!i!j!k!l!m!n!o!p!q!r!s!t!u!UdOPQTWX!P!Q!S!T!Z![!h!i!j!k!l!m!n!o!p!q!r!s!t!uR#X!g!W`OPQTWX!P!Q!S!T!Z![!g!h!i!j!k!l!m!n!o!p!q!r!s!t!uR#W!f!YaOPQTWX!P!Q!S!T!Z![!f!g!h!i!j!k!l!m!n!o!p!q!r!s!t!uQ!XRQ#U!dR#V!e!`]OPQRTWX!P!Q!S!T!Z![!d!e!f!g!h!i!j!k!l!m!n!o!p!q!r!s!t!uR#T!c!b^OPQRTWX!P!Q!S!T!Z![!c!d!e!f!g!h!i!j!k!l!m!n!o!p!q!r!s!t!uR#S!b!d[OPQRTWX!P!Q!S!T!Z![!b!c!d!e!f!g!h!i!j!k!l!m!n!o!p!q!r!s!t!uR!aZ!gUOPQRTWXZ!P!Q!S!T!Z![!b!c!d!e!f!g!h!i!j!k!l!m!n!o!p!q!r!s!t!u",
  nodeNames: "⚠ Dot FullStop LineComment BlockComment Program Rule UnaryOperation Atom discontiguous dynamic initialization meta_predicate module_transparent multifile public table thread_initialization thread_local volatile BinaryOperation BinaryOperation BinaryOperation UnaryOperation \\+ BinaryOperation BinaryOperation #<==> BinaryOperation #<== BinaryOperation BinaryOperation #\\/ BinaryOperation #\\ BinaryOperation #/\\ UnaryOperation BinaryOperation BinaryOperation BinaryOperation + - /\\ \\/ BinaryOperation BinaryOperation * / // << >> div mod rdiv rem xor UnaryOperation \\ BinaryOperation BinaryOperation UnaryOperation $ QuotedAtom #< #= #=< #==> #> #>= #\\= ** *-> , --> -> .. : :< := ; < = =.. =:= =< == => =@= =\\= > >:< >= @< @=< @> @>= \\= \\== \\=@= ^ | Variable String String2 String3 BackQuoteString Number Float HexNumber OctalNumber BinaryNumber Rational ! ) ( Parentheses Application Functor ] [ List } Dict { CodeBlock BinaryOperation as in in_set ins is Comma :- Command Query ?-",
  maxTerm: 165,
  nodeProps: [
    ["openedBy", 114, "(", 119, "[", 122, "{"],
    ["closedBy", 115, ")", 120, "]", 124, "}"]
  ],
  skippedNodes: [0, 3, 4],
  repeatNodeCount: 1,
  tokenData: "9c~RvXY#iYZ#i]^#ipq#iqr#zrs$Pst$ntu'Xuv'^wx'ixy(Wyz(]z{(b{|(}|})S}!O)Z!O!P)v!P!Q*R!Q!R+`!R![/v![!]1h!]!^2V!^!_2[!_!`2i!`!a4b!a!b5V!b!c5b!c!}6]!}#O6n#O#P6s#P#Q7x#Q#R7}#R#S6]#S#T8S#T#o8q#o#p9S#p#q9X#q#r9^~#nS$Q~XY#iYZ#i]^#ipq#i~$PO#e~~$STOr$Prs$cs#O$P#O#P$h#P~$P~$hO#Z~~$kPO~$P~$qT!P!Q%Q!^!_%]!_!`%x!`!a&e#O#P&r~%TP#O#P%W~%]Ot~~%bP!b~!_!`%e~%hP!_!`%k~%pPm~!`!a%s~%xOk~~%}Q!c~!^!_&T!_!`&Y~&YO!d~~&]P!`!a&`~&eO!e~~&jP!f~!_!`&m~&rO!g~~&wQr~!P!Q&}!_!`'S~'SOp~~'XO!h~~'^O!`~~'cQR~OY'^Z~'^~'lTOw'iwx'{x#O'i#O#P(Q#P~'i~(QO!a~~(TPO~'i~(]O#g~~(bO#f~~(gQ!P~z{(m}!O(r~(rO!i~~(uP!`!a(x~(}O!j~~)SOy~R)ZO!kP#xQ~)`Qz~}!O)f!`!a)q~)iP!`!a)l~)qO!l~~)vO!m~~)yP!O!P)|~*RO!n~~*WR!Q~z{*a!P!Q+U#O#P+Z~*dROz*az{*m{~*a~*pTOz*az{*m{!P*a!P!Q+P!Q~*a~+UOS~~+ZO!R~~+`O{~~+eY#_~pq,Twx,z!O!P-V!Q![.P#R#S,T#U#V.h#X#Y-h#c#d.|#f#g,f#l#m/[~,YS#_~pq,T!Q![,T#R#S,T#f#g,f~,iP!Q![,l~,qR#d~pq,l!Q![,l#R#S,l~,}PO~-Q~-VO#]~~-YP!Q![-]~-bQ#`~!Q![-]#X#Y-h~-kQ}!O-q!Q![-w~-tP!Q![-w~-|P#`~!Q![-w~.UU#_~pq,T!O!P-V!Q![.P#R#S,T#X#Y-h#f#g,f~.kQ!Q!R.q!R!S.q~.vQ#c~!Q!R.q!R!S.q~/PP!Q!Y/S~/XP#b~!Q!Y/S~/_R!Q![/h!c!}/h#T#o/h~/mR#a~!Q![/h!c!}/h#T#o/h~/{V#_~pq,Twx0b!O!P-V!Q![0|#R#S,T#X#Y-h#f#g,f~0eR!Q![0n!c!}0n#T#o0n~0sR#[~!Q![0n!c!}0n#T#o0n~1RV#_~pq,Twx0b!O!P-V!Q![.P#R#S,T#X#Y-h#f#g,f~1mR!o~}!O1v!^!_1{!_!`2Q~1{O#y~~2QO!p~~2VO!q~~2[O!r~~2aP!s~!^!_2d~2iO!S~~2nV!t~!O!P3T![!]3`!^!_3k!_!`3p!`!a3u!b!c3z#O#P4V~3WP!O!P3Z~3`O!u~~3cP!_!`3f~3kO!v~~3pO!w~~3uO!x~~3zO!y~~3}P!_!`4Q~4VO!z~~4YP!_!`4]~4bO!{~~4gR!|~![!]4p!_!`4{!`!a5Q~4sP!^!_4v~4{O!}~~5QO#O~~5VO!T~~5YP}!O5]~5bO#|~~5eR!^!_5n!_!`5s!`!a6O~5sO#P~~5vP!^!_5y~6OO#Q~~6TP#R~!_!`6W~6]O#S~~6bS#Y~!Q![6]!c!}6]#R#S6]#T#o6]~6sO#l~~6xR![~{|7R!P!Q7W!_!`7]~7WOh~~7]O|~~7bQ#T~!_!`7h!b!c7m~7mO#U~~7pP!_!`7s~7xO#V~~7}O#k~~8SO#W~~8VTO#O8S#O#P8f#P#S8S#S#T8l#T~8S~8iPO~8S~8qO#^~~8vSW~!Q![8q!c!}8q#R#S8q#T#o8q~9XO#p~~9^O#X~~9cO#n~",
  tokenizers: [0, 1, T5],
  topRules: { Program: [0, 5] },
  specialized: [{ term: 8, get: (r) => C5[r] || -1 }],
  tokenPrec: 0
}), Z5 = Nt.define({
  parser: X5.configure({
    props: [
      Jt({
        "Comma FullStop": O.separator,
        "( )": O.paren,
        "[ ]": O.squareBracket,
        "{ }": O.bracket,
        '"!"': O.operator,
        // Line generated by helper.py:
        '"#/\\\\" "#\\\\/" "*" "**" "*->" "/" "//" "/\\\\" "\\\\/" #< #<== #<==> #= #=< #==> #> #>= #\\ #\\= $ + , - --> -> .. : :- :< := ; < << = =.. =:= =< == => =@= =\\= > >:< >= >> ?- @< @=< @> @>= Dot \\ \\+ \\= \\== \\=@= ^ as discontiguous div dynamic in in_set initialization ins is meta_predicate mod module_transparent multifile public rdiv rem table thread_initialization thread_local volatile xor |': O.operator,
        "Functor/Atom": O.function(O.variableName),
        Atom: O.constant(O.name),
        BackQuoteString: O.string,
        BinaryNumber: O.number,
        BlockComment: O.blockComment,
        Float: O.number,
        HexNumber: O.number,
        LineComment: O.lineComment,
        Number: O.number,
        OctalNumber: O.number,
        QuotedAtom: O.constant(O.name),
        Rational: O.number,
        String: O.string,
        String2: O.string,
        String3: O.string,
        Variable: O.variableName
      })
    ]
  }),
  languageData: {
    commentTokens: { line: "%" }
  }
});
function _5() {
  return new cr(Z5);
}
const R5 = 1, Y1 = 206, W1 = 207, A5 = 208, Pf = 209, E5 = 210, q5 = 211, z5 = 212, Y5 = 2, W5 = 213, V5 = 214, M5 = 3, j5 = 215, L5 = 216, B5 = 4, D5 = 217, I5 = 218, U5 = 5, G5 = 219, N5 = 26, F5 = 27, H5 = 51, K5 = 52, J5 = 57, eC = 58, tC = 59, rC = 61, iC = 62, nC = 63, sC = 64, oC = 65, lC = 67, aC = 256, hC = 74, cC = 275, uC = 120, dC = 138, pC = 159, fC = 160, OC = 163, ds = 10, ps = 13, lu = 32, Xl = 9, au = 35, mC = 40, gC = 46, Tf = 123, V1 = 39, M1 = 34, bC = 92, wC = /* @__PURE__ */ new Set([
  F5,
  H5,
  K5,
  cC,
  lC,
  dC,
  eC,
  tC,
  aC,
  sC,
  oC,
  hC,
  iC,
  nC,
  pC,
  fC,
  OC,
  uC
]);
function Ca(r) {
  return r == ds || r == ps;
}
const yC = new Ae((r, e) => {
  let t;
  if (r.next < 0)
    r.acceptToken(q5);
  else if (e.context.depth < 0)
    Ca(r.next) && r.acceptToken(E5, 1);
  else if (((t = r.peek(-1)) < 0 || Ca(t)) && e.canShift(Pf)) {
    let i = 0;
    for (; r.next == lu || r.next == Xl; )
      r.advance(), i++;
    (r.next == ds || r.next == ps || r.next == au) && r.acceptToken(Pf, -i);
  } else
    Ca(r.next) && r.acceptToken(A5, 1);
}, { contextual: !0 }), vC = new Ae((r, e) => {
  let t = e.context.depth;
  if (t < 0)
    return;
  let i = r.peek(-1);
  if (i == ds || i == ps) {
    let n = 0, s = 0;
    for (; ; ) {
      if (r.next == lu)
        n++;
      else if (r.next == Xl)
        n += 8 - n % 8;
      else
        break;
      r.advance(), s++;
    }
    n != t && r.next != ds && r.next != ps && r.next != au && (n < t ? r.acceptToken(W1, -s) : r.acceptToken(Y1));
  }
});
function Gh(r, e) {
  this.parent = r, this.depth = e, this.hash = (r ? r.hash + r.hash << 8 : 0) + e + (e << 4);
}
const xC = new Gh(null, 0);
function SC(r) {
  let e = 0;
  for (let t = 0; t < r.length; t++)
    e += r.charCodeAt(t) == Xl ? 8 - e % 8 : 1;
  return e;
}
const kC = new Kc({
  start: xC,
  reduce(r, e) {
    return r.depth < 0 && wC.has(e) ? r.parent : r;
  },
  shift(r, e, t, i) {
    return e == Y1 ? new Gh(r, SC(i.read(i.pos, t.pos))) : e == W1 ? r.parent : e == N5 || e == J5 || e == rC ? new Gh(r, -1) : r;
  },
  hash(r) {
    return r.hash;
  }
}), $C = new Ae((r) => {
  for (let e = 0; e < 5; e++) {
    if (r.next != "print".charCodeAt(e))
      return;
    r.advance();
  }
  if (!/\w/.test(String.fromCharCode(r.next)))
    for (let e = 0; ; e++) {
      let t = r.peek(e);
      if (!(t == lu || t == Xl)) {
        t != mC && t != gC && t != ds && t != ps && t != au && r.acceptToken(R5);
        return;
      }
    }
});
function Zl(r, e, t, i, n) {
  return new Ae((s) => {
    let o = s.pos;
    for (; !(s.next < 0); )
      if (s.next == Tf)
        if (s.peek(1) == Tf)
          s.advance(2);
        else {
          if (s.pos == o) {
            s.acceptToken(i, 1);
            return;
          }
          break;
        }
      else if (s.next == bC)
        s.advance(), s.next >= 0 && s.advance();
      else if (s.next == r && (e == 1 || s.peek(1) == r && s.peek(2) == r)) {
        if (s.pos == o) {
          s.acceptToken(n, e);
          return;
        }
        break;
      } else
        s.advance();
    s.pos > o && s.acceptToken(t);
  });
}
const QC = Zl(V1, 1, z5, Y5, W5), PC = Zl(M1, 1, V5, M5, j5), TC = Zl(V1, 3, L5, B5, D5), CC = Zl(M1, 3, I5, U5, G5), XC = Jt({
  'async "*" "**" FormatConversion FormatSpec': O.modifier,
  "for while if elif else try except finally return raise break continue with pass assert await yield match case": O.controlKeyword,
  "in not and or is del": O.operatorKeyword,
  "from def class global nonlocal lambda": O.definitionKeyword,
  import: O.moduleKeyword,
  "with as print": O.keyword,
  Boolean: O.bool,
  None: O.null,
  VariableName: O.variableName,
  "CallExpression/VariableName": O.function(O.variableName),
  "FunctionDefinition/VariableName": O.function(O.definition(O.variableName)),
  "ClassDefinition/VariableName": O.definition(O.className),
  PropertyName: O.propertyName,
  "CallExpression/MemberExpression/PropertyName": O.function(O.propertyName),
  Comment: O.lineComment,
  Number: O.number,
  String: O.string,
  FormatString: O.special(O.string),
  UpdateOp: O.updateOperator,
  "ArithOp!": O.arithmeticOperator,
  BitOp: O.bitwiseOperator,
  CompareOp: O.compareOperator,
  AssignOp: O.definitionOperator,
  Ellipsis: O.punctuation,
  At: O.meta,
  "( )": O.paren,
  "[ ]": O.squareBracket,
  "{ }": O.brace,
  ".": O.derefOperator,
  ", ;": O.separator
}), ZC = { __proto__: null, await: 48, or: 58, and: 60, in: 64, not: 66, is: 68, if: 74, else: 76, lambda: 80, yield: 98, from: 100, async: 106, for: 108, None: 178, True: 180, False: 180, del: 194, pass: 198, break: 202, continue: 206, return: 210, raise: 218, import: 222, as: 224, global: 228, nonlocal: 230, assert: 234, type: 239, elif: 252, while: 256, try: 262, except: 264, finally: 266, with: 270, def: 274, class: 284, match: 295, case: 301 }, _C = Ft.deserialize({
  version: 14,
  states: "#)WO`Q#yOOP$bOSOOO%kQ&nO'#HhOOQS'#Cq'#CqOOQS'#Cr'#CrO'ZQ#xO'#CpO(|Q&nO'#HgOOQS'#Hh'#HhOOQS'#DW'#DWOOQS'#Hg'#HgO)jQ#xO'#DaO)}Q#xO'#DhO*_Q#xO'#DlOOQS'#Dw'#DwO*rO,UO'#DwO*zO7[O'#DwO+SOWO'#DxO+_O`O'#DxO+jOpO'#DxO+uO!bO'#DxO-wQ&nO'#HXOOQS'#HX'#HXO'ZQ#xO'#HWO/ZQ&nO'#HWOOQS'#Ej'#EjO/rQ#xO'#EkOOQS'#HV'#HVO/|Q#xO'#HUOOQV'#HU'#HUO0XQ#xO'#FbOOQS'#Gj'#GjO0^Q#xO'#FaOOQV'#I_'#I_OOQV'#HT'#HTOOQV'#Fy'#FyQ`Q#yOOO'ZQ#xO'#CsO0lQ#xO'#DPO0sQ#xO'#DTO1RQ#xO'#HlO1cQ&nO'#E_O'ZQ#xO'#E`OOQS'#Eb'#EbOOQS'#Ed'#EdOOQS'#Ef'#EfO1wQ#xO'#EhO2_Q#xO'#ElO0XQ#xO'#EnO2rQ&nO'#EnO0XQ#xO'#EqO/rQ#xO'#EtO0XQ#xO'#EvO/rQ#xO'#E|O/rQ#xO'#FPO2}Q#xO'#FRO3UQ#xO'#FWO3aQ#xO'#FSO/rQ#xO'#FWO0XQ#xO'#FYO0XQ#xO'#F_O3fQ#xO'#FdP3mO#xO'#HSPOOO)CBv)CBvOOQS'#Cg'#CgOOQS'#Ch'#ChOOQS'#Ci'#CiOOQS'#Cj'#CjOOQS'#Ck'#CkOOQS'#Cl'#ClOOQS'#Cn'#CnO'ZQ#xO,59QO'ZQ#xO,59QO'ZQ#xO,59QO'ZQ#xO,59QO'ZQ#xO,59QO'ZQ#xO,59QO3xQ#xO'#DqOOQS,5:[,5:[O4]Q#xO'#HvOOQS,5:_,5:_O4jQMlO,5:_O4oQ&nO,59[O0lQ#xO,59dO0lQ#xO,59dO0lQ#xO,59dO7_Q#xO,59dO7dQ#xO,59dO7kQ#xO,59lO7rQ#xO'#HgO8xQ#xO'#HfOOQS'#Hf'#HfOOQS'#D^'#D^O9aQ#xO,59cO'ZQ#xO,59cO9oQ#xO,59cOOQS,59{,59{O9tQ#xO,5:TO'ZQ#xO,5:TOOQS,5:S,5:SO:SQ#xO,5:SO:XQ#xO,5:ZO'ZQ#xO,5:ZO'ZQ#xO,5:XOOQS,5:W,5:WO:jQ#xO,5:WO:oQ#xO,5:YOOOO'#GR'#GRO:tO,UO,5:cOOQS,5:c,5:cOOOO'#GS'#GSO:|O7[O,5:cO;UQ#xO'#DyOOOW'#GT'#GTO;fOWO,5:dOOQS,5:d,5:dO;UQ#xO'#EPOOO`'#GW'#GWO;qO`O,5:dO;UQ#xO'#EROOOp'#GX'#GXO;|OpO,5:dO;UQ#xO'#ETOOO!b'#GY'#GYO<XO!bO,5:dOOQS'#GZ'#GZO<dQ&nO,5:qO?UQ&nO,5=rO?oQ!LUO,5=rO@`Q&nO,5=rOOQS,5;V,5;VO@wQ#yO'#GdOBZQ#xO,5;fOOQV,5=p,5=pOBfQ&nO'#IYOB}Q#xO,5;|OOQS-E:h-E:hOOQV,5;{,5;{O3[Q#xO'#FYOOQV-E9w-E9wOCVQ&nO,59_OE^Q&nO,59kOEwQ#xO'#HiOFSQ#xO'#HiO0XQ#xO'#HiOF_Q#xO'#DVOFgQ#xO,59oOFlQ#xO'#HmO'ZQ#xO'#HmO/rQ#xO,5>WOOQS,5>W,5>WO/rQ#xO'#EZOOQS'#E['#E[OGZQ#xO'#G]OGkQ#xO,59OOGkQ#xO,59OO)pQ#xO,5:wOGyQ&nO'#HoOOQS,5:z,5:zOOQS,5;S,5;SOH^Q#xO,5;WOHoQ#xO,5;YOOQS'#G`'#G`OH}Q&nO,5;YOI]Q#xO,5;YOIbQ#xO'#I]OOQS,5;],5;]OIpQ#xO'#IXOOQS,5;`,5;`OJRQ#xO,5;bO3aQ#xO,5;hO3aQ#xO,5;kOJZQ&nO'#I`O'ZQ#xO'#I`OJeQ#xO,5;mO2}Q#xO,5;mO/rQ#xO,5;rO0XQ#xO,5;tOJjQ#yO'#E}OKvQ#{O,5;nO! [Q#xO'#IaO3aQ#xO,5;rO! gQ#xO,5;tO! oQ#xO,5;yO! zQ&nO,5<OO'ZQ#xO,5<OPOOO,5=n,5=nP!!ROSO,5=nP!!WO#xO,5=nO!${Q&nO1G.lO!%SQ&nO1G.lO!'sQ&nO1G.lO!'}Q&nO1G.lO!*hQ&nO1G.lO!*{Q&nO1G.lO!+`Q#xO'#HuO!+nQ&nO'#HXO/rQ#xO'#HuO!+xQ#xO'#HtOOQS,5:],5:]O!,QQ#xO,5:]O!,VQ#xO'#HwO!,bQ#xO'#HwO!,uQ#xO,5>bOOQS'#Du'#DuOOQS1G/y1G/yOOQS1G/O1G/OO!-uQ&nO1G/OO!-|Q&nO1G/OO0lQ#xO1G/OO!.iQ#xO1G/WOOQS'#D]'#D]O/rQ#xO,59vOOQS1G.}1G.}O!.pQ#xO1G/gO!/QQ#xO1G/gO!/YQ#xO1G/hO'ZQ#xO'#HnO!/_Q#xO'#HnO!/dQ&nO1G.}O!/tQ#xO,59kO!0zQ#xO,5>^O!1[Q#xO,5>^O!1dQ#xO1G/oO!1iQ&nO1G/oOOQS1G/n1G/nO!1yQ#xO,5>XO!2pQ#xO,5>XO/rQ#xO1G/sO!3_Q#xO1G/uO!3dQ&nO1G/uO!3tQ&nO1G/sOOQS1G/r1G/rOOQS1G/t1G/tOOOO-E:P-E:POOQS1G/}1G/}OOOO-E:Q-E:QO!4UQ#xO'#IRO/rQ#xO'#IRO!4gQ#xO,5:eOOOW-E:R-E:ROOQS1G0O1G0OO!4uQ#xO,5:kOOO`-E:U-E:UO!5TQ#xO,5:mOOOp-E:V-E:VO!5cQ#xO,5:oOOO!b-E:W-E:WOOQS-E:X-E:XO!5qQ!LUO1G3^O!6bQ&nO1G3^O'ZQ#xO,5<vOOQS,5<v,5<vOOQS-E:Y-E:YOOQS,5=O,5=OOOQS-E:b-E:bOOQV1G1Q1G1QO0XQ#xO'#G_O!6yQ&nO,5>tOOQS1G1h1G1hO!7bQ#xO1G1hOOQS'#DX'#DXO/rQ#xO,5>TOOQS,5>T,5>TO!7gQ#xO'#FzO!7rQ#xO,59qO!7zQ#xO1G/ZO!8UQ&nO,5>XOOQS1G3r1G3rOOQS,5:u,5:uO!8uQ#xO'#HWOOQS,5<w,5<wOOQS-E:Z-E:ZO!9WQ#xO1G.jOOQS1G0c1G0cO!9fQ#xO,5>ZO!9vQ#xO,5>ZO/rQ#xO1G0rO/rQ#xO1G0rO0XQ#xO1G0tOOQS-E:^-E:^O!:XQ#xO1G0tO!:dQ#xO1G0tO!:iQ#xO,5>wO!:wQ#xO,5>wO!;VQ#xO,5>sO!;mQ#xO,5>sO!<OQ#xO'#ExO/rQ#xO1G0|O!<ZQ#xO1G0|O!<`Q#{O1G1SO!?qQ#{O1G1VO!CPQ#xO,5>zO!CZQ#xO,5>zO!CcQ&nO,5>zO/rQ#xO1G1XO!CmQ#xO1G1XO3aQ#xO1G1^O! gQ#xO1G1`OOQV,5;i,5;iO!CrQ#zO,5;iO!CwQ#{O1G1YO!G]Q#xO'#GgO3aQ#xO1G1YO3aQ#xO1G1YO!GmQ#xO,5>{O!GzQ#xO,5>{O0XQ#xO,5>{OOQV1G1^1G1^O!HSQ#xO'#F[O!HeQMlO1G1`O!HmQ#xO1G1`OOQV1G1e1G1eO3aQ#xO1G1eO!HrQ#xO1G1eO!HzQ#xO'#FfOOQV1G1j1G1jO! zQ&nO1G1jPOOO1G3Y1G3YP!IPOSO1G3YOOQS,5>a,5>aOOQS'#Dr'#DrO/rQ#xO,5>aO!IUQ#xO,5>`O!IiQ#xO,5>`OOQS1G/w1G/wO!IqQ#xO,5>cO!JRQ#xO,5>cO!JZQ#xO,5>cO!JnQ#xO,5>cO!KOQ#xO,5>cOOQS1G3|1G3|OOQS7+$j7+$jO!7zQ#xO7+$rO!LqQ#xO1G/OO!LxQ#xO1G/OOOQS1G/b1G/bOOQS,5<h,5<hO'ZQ#xO,5<hOOQS7+%R7+%RO!MPQ#xO7+%ROOQS-E9z-E9zOOQS7+%S7+%SO!MaQ#xO,5>YO'ZQ#xO,5>YOOQS7+$i7+$iO!MfQ#xO7+%RO!MnQ#xO7+%SO!MsQ#xO1G3xOOQS7+%Z7+%ZO!NTQ#xO1G3xO!N]Q#xO7+%ZOOQS,5<g,5<gO'ZQ#xO,5<gO!NbQ#xO1G3sOOQS-E9y-E9yO# XQ#xO7+%_OOQS7+%a7+%aO# gQ#xO1G3sO#!UQ#xO7+%aO#!ZQ#xO1G3yO#!kQ#xO1G3yO#!sQ#xO7+%_O#!xQ#xO,5>mO##cQ#xO,5>mO##cQ#xO,5>mOOQS'#Dz'#DzO##tO$ISO'#D|O#$PO#tO'#ISOOOW1G0P1G0PO#$UQ#xO1G0PO#$^Q#xO1G0POOQS'#EQ'#EQOOO`1G0V1G0VO#$iQ#xO1G0VO#$qQ#xO1G0VOOQS'#ES'#ESOOOp1G0X1G0XO#$|Q#xO1G0XO#%UQ#xO1G0XOOQS'#EU'#EUOOO!b1G0Z1G0ZO#%aQ#xO1G0ZO#%iQ#xO1G0ZO#%tQ!LUO7+(xO#&eQ&nO1G2bP#'OQ#xO'#G[OOQS,5<y,5<yOOQS-E:]-E:]OOQS7+'S7+'SOOQS1G3o1G3oOOQS,5<f,5<fOOQS-E9x-E9xOOQS7+$u7+$uO#']Q#xO,5=rO#'vQ#xO,5=rO#(XQ&nO,5<iO#(lQ#xO1G3uOOQS-E9{-E9{OOQS7+&^7+&^O#(|Q#xO7+&^OOQS7+&`7+&`O#)[Q#xO'#I[O0XQ#xO'#IZO#)pQ#xO7+&`OOQS,5<|,5<|O#){Q#xO1G4cOOQS-E:`-E:`OOQS,5<x,5<xO#*ZQ#xO1G4_OOQS-E:[-E:[O0XQ#xO'#EyO#*qQ#xO'#EyO#*|Q#xO'#I^O#+UQ#xO,5;dOOQS7+&h7+&hO/rQ#xO7+&hO#+ZQ#{O7+&nO!G`Q#xO'#GeO3aQ#xO7+&nO3aQ#xO7+&qO#.lQ&nO,5=QO'ZQ#xO,5=QO#.vQ#xO1G4fOOQS-E:d-E:dO#/QQ#xO1G4fO3aQ#xO7+&sO/rQ#xO7+&sOOQV7+&x7+&xO!HeQMlO7+&zO!HmQ#xO7+&zO`Q#yO1G1TOOQV-E:e-E:eO3aQ#xO7+&tO3aQ#xO7+&tOOQV,5=R,5=RO#/YQ#xO,5=RO!G`Q#xO,5=ROOQV7+&t7+&tO#/eQ#{O7+&tO#2sQ#xO,5=SO#3OQ#xO1G4gOOQS-E:f-E:fO#3]Q#xO1G4gO#3eQ#xO'#IcO#3sQ#xO'#IcO0XQ#xO'#IcOOQS'#Ic'#IcO#4OQ#xO'#IbOOQS,5;v,5;vO#4WQ#xO,5;vO/rQ#xO'#F^OOQV7+&z7+&zO3aQ#xO7+&zOOQV7+'P7+'PO3aQ#xO7+'PO#4]Q#zO,5<QOOQV7+'U7+'UPOOO7+(t7+(tO#4bQ#xO1G3{OOQS,5<k,5<kO#4pQ#xO1G3zOOQS-E9}-E9}O#5TQ#xO,5<lO#5`Q#xO,5<lO#5sQ#xO1G3}OOQS-E:O-E:OO#6TQ#xO1G3}O#6]Q#xO1G3}O#6mQ#xO1G3}O#6TQ#xO1G3}OOQS<<H^<<H^O#6xQ&nO1G2SOOQS<<Hm<<HmP#7VQ#xO'#F|O7kQ#xO1G3tO#7dQ#xO1G3tO#7iQ#xO<<HmOOQS<<Hn<<HnO#7yQ#xO7+)dOOQS<<Hu<<HuO#8ZQ&nO1G2RP#8zQ#xO'#F{O#9XQ#xO7+)eO#9iQ#xO7+)eO#9qQ#xO<<HyO#9vQ#xO7+)_OOQS<<H{<<H{O#:mQ#xO,5<jO'ZQ#xO,5<jOOQS-E9|-E9|OOQS<<Hy<<HyOOQS,5<p,5<pO/rQ#xO,5<pO#:rQ#xO1G4XOOQS-E:S-E:SO#;]Q#xO1G4XO;UQ#xO'#D}OOOO'#GV'#GVO#;nO$ISO,5:hOOO#l,5>n,5>nOOOW7+%k7+%kO#;yQ#xO7+%kOOO`7+%q7+%qO#<RQ#xO7+%qOOOp7+%s7+%sO#<ZQ#xO7+%sOOO!b7+%u7+%uO#<cQ#xO7+%uO#<kQ#xO1G3^O#=UQ#xO1G3^P'ZQ#xO'#F}O/rQ#xO<<IxO#=gQ#xO,5>vO#=xQ#xO,5>vO0XQ#xO,5>vO#>ZQ#xO,5>uOOQS<<Iz<<IzP0XQ#xO'#GbP/rQ#xO'#G^OOQS,5;e,5;eO#>`Q#xO,5>xO#>nQ#xO,5>xOOQS1G1O1G1OOOQS<<JS<<JSOOQV-E:c-E:cO3aQ#xO<<JYOOQV,5=P,5=PO3aQ#xO,5=POOQV<<JY<<JYOOQV<<J]<<J]O#>vQ&nO1G2lP#?QQ#xO'#GfO#?XQ#xO7+*QO#?cQ#{O<<J_O3aQ#xO<<J_OOQV<<Jf<<JfO3aQ#xO<<JfO!HeQMlO<<JfO#BqQ#{O7+&oOOQV<<J`<<J`O#B{Q#{O<<J`OOQV1G2m1G2mO0XQ#xO1G2mO#FZQ#xO1G2mO3aQ#xO<<J`O0XQ#xO1G2nP/rQ#xO'#GhO#FfQ#xO7+*RO#FsQ#xO7+*ROOQS'#F]'#F]O/rQ#xO,5>}O#F{Q#xO,5>}OOQS,5>},5>}O#GWQ#xO,5>|O#GiQ#xO,5>|OOQS1G1b1G1bOOQS,5;x,5;xOOQV<<Jk<<JkO#GqQ#xO1G1lOOQS7+)g7+)gP#GvQ#xO'#GPO#HWQ#xO1G2WO#HkQ#xO1G2WO#H{Q#xO1G2WP#IWQ#xO'#GQO#IeQ#xO7+)iO#IuQ#xO7+)iO#IuQ#xO7+)iO#I}Q#xO7+)iO#J_Q#xO7+)`O7kQ#xO7+)`OOQSAN>XAN>XO#JxQ#xO<<MPOOQSAN>eAN>eO/rQ#xO1G2UO#KYQ&nO1G2UP#KdQ#xO'#GOOOQS1G2[1G2[P#KqQ#xO'#GUO#LOQ#xO7+)sO#LiQ#xO,5:iOOOO-E:T-E:TOOOW<<IV<<IVOOO`<<I]<<I]OOOp<<I_<<I_OOO!b<<Ia<<IaO#LwQ#xO7+(xOOQSAN?dAN?dO#MbQ#xO,5<{O#MvQ#xO1G4bOOQS-E:_-E:_O#NXQ#xO1G4bOOQS1G4a1G4aOOQS,5<},5<}O#NjQ#xO1G4dOOQS-E:a-E:aOOQVAN?tAN?tOOQV1G2k1G2kO3aQ#xOAN?yO#NxQ#{OAN?yOOQVAN@QAN@QO3aQ#xOAN@QOOQV<<JZ<<JZO3aQ#xOAN?zO3aQ#xO7+(XOOQV7+(X7+(XO0XQ#xO7+(XOOQVAN?zAN?zOOQS7+(Y7+(YO$$WQ#xO<<MmOOQS1G4i1G4iO/rQ#xO1G4iOOQS,5=T,5=TO$$eQ#xO1G4hOOQS-E:g-E:gOOQU'#Gk'#GkO$$vQ#zO7+'WO$%RQ#xO'#FgO$%yQ#xO7+'rO$&ZQ#xO7+'rOOQS7+'r7+'rO$&fQ#xO<<MTO$&vQ#xO<<MTO$&vQ#xO<<MTO$'OQ#xO'#HpOOQS<<Lz<<LzO$'YQ#xO<<LzOOQS7+'p7+'pOOQS'#EO'#EOOOOO1G0T1G0TO$'sQ#xO1G0TO$'{Q#xO1G0TO0XQ#xO1G2gP0XQ#xO'#GaO$(WQ#xO7+)|O$(iQ#xO7+)|P!<OQ#xO'#GcOOQVG25eG25eO3aQ#xOG25eOOQVG25lG25lOOQVG25fG25fOOQV<<Ks<<KsO3aQ#xO<<KsOOQS7+*T7+*TP$(zQ#xO'#GiOOQU-E:i-E:iOOQV<<Jr<<JrO$)nQ&nO'#FiOOQS'#Fk'#FkO$*OQ#xO'#FjO$*pQ#xO'#FjOOQS'#Fj'#FjO$*uQ#xO'#IeO$%RQ#xO'#FqO$%RQ#xO'#FqO$+^Q#xO'#FrO$%RQ#xO'#FsO$+eQ#xO'#IfOOQS'#If'#IfO$,SQ#xO,5<ROOQS<<K^<<K^O$,[Q#xO<<K^O$,lQ#xOANBoO$,|Q#xOANBoO$-UQ#xO'#HqOOQS'#Hq'#HqO0sQ#xO'#DeO$-oQ#xO,5>[OOQSANBfANBfOOOO7+%o7+%oO$.WQ#xO7+%oOOQS7+(R7+(RO$.`Q#xO<<MhOOQVLD+PLD+POOQVANA_ANA_O4jQMlO'#GmO$.qQ&nO,5<[O$%RQ#xO'#FuOOQS,5<`,5<`OOQS'#Fl'#FlO$/cQ#xO,5<UO$/hQ#xO,5<UOOQS'#Fo'#FoO$%RQ#xO'#GlO$0YQ#xO,5<YO$0tQ#xO,5?PO$1UQ#xO,5?PO0XQ#xO,5<XO$1gQ#xO,5<]O$1lQ#xO,5<]O$%RQ#xO'#IgO$1qQ#xO'#IgO$1vQ#xO,5<^OOQS,5<_,5<_O'ZQ#xO'#FxOOQU1G1m1G1mO3aQ#xO1G1mOOQSAN@xAN@xO$1{Q#xOG28ZO$2]Q#xO,5:POOQS1G3v1G3vOOOO<<IZ<<IZOOQS,5=X,5=XOOQS-E:k-E:kO$2bQ&nO'#FiO$2iQ#xO'#IhO$2wQ#xO'#IhO$3PQ#xO,5<aOOQS1G1p1G1pO$3UQ#xO1G1pO$3ZQ#xO,5=WOOQS-E:j-E:jO$3uQ#xO,5=[O$4^Q#xO1G4kOOQS-E:n-E:nOOQS1G1s1G1sOOQS1G1w1G1wO$4nQ#xO,5?RO$%RQ#xO,5?ROOQS1G1x1G1xO$4|Q&nO,5<dOOQU7+'X7+'XO$'OQ#xO1G/kO$%RQ#xO,5<bO$5TQ#xO,5?SO$5[Q#xO,5?SOOQS1G1{1G1{OOQS7+'[7+'[P$%RQ#xO'#GpO$5dQ#xO1G4mO$5nQ#xO1G4mO$5vQ#xO1G4mOOQS7+%V7+%VO$6UQ#xO1G1|O$6dQ&nO'#FiO$6kQ#xO,5=ZOOQS,5=Z,5=ZO$6yQ#xO1G4nOOQS-E:m-E:mO$%RQ#xO,5=YO$7QQ#xO,5=YO$7VQ#xO7+*XOOQS-E:l-E:lO$7aQ#xO7+*XO$%RQ#xO,5<cP$%RQ#xO'#GoO$7iQ#xO1G2tO$%RQ#xO1G2tP$7wQ#xO'#GnO$8OQ#xO<<MsO$8YQ#xO1G1}O$8hQ#xO7+(`O7kQ#xO'#DPO7kQ#xO,59dO7kQ#xO,59dO7kQ#xO,59dO$8vQ&nO,5=rO7kQ#xO1G/OO/rQ#xO1G/ZO/rQ#xO7+$rP$9ZQ#xO'#G[O'ZQ#xO'#HWO$9hQ#xO,59dO$9mQ#xO,59dO$9tQ#xO,59oO$9yQ#xO1G/WO0sQ#xO'#DTO7kQ#xO,59l",
  stateData: "$:[~O%uOS%jOSUOS%iPQ~OPiOXfOhtOjYOquOu!UOxvO!RwO!S!QO!V!XO!W!WO!ZZO!_[O!jeO!zeO!{eO!|eO#TyO#VzO#X{O#Z|O#]}O#a!OO#c!PO#f!RO#g!RO#i!SO#k!TO#t!VO#w!YO#{!ZO#}![O$S!]O$VmO$X!^O&RRO&SRO&WSO&XWO&m]O&n^O&q_O&t`O&xaO&ybO&zcO~O%i!_O~OX!fOa!fOc!gOj!nO!Z!pO!h!rO%|!aO%}!bO&O!cO&P!dO&Q!dO&R!eO&S!eO&T!fO&U!fO&V!fO~Om&[Xn&[Xo&[Xp&[Xq&[Xr&[Xu&[X|&[X}&[X#Q&[X#o&[X%h&[X%k&[X&^&[Xi&[X!V&[X!W&[X&_&[X!Y&[X!^&[X!S&[X#d&[Xv&[X!o&[X~P$gOhtOjYO!ZZO!_[O!jeO!zeO!{eO!|eO&RRO&SRO&WSO&XWO&m]O&n^O&q_O&t`O&xaO&ybO&zcO~O|&ZX}&ZX#o&ZX%h&ZX%k&ZX&^&ZX~Om!uOn!vOo!tOp!tOq!wOr!xOu!yO#Q&ZX~P(hOX#POi#ROq1`Ox1nO!RwO~P'ZOX#TOq1`Ox1nO!Y#UO~P'ZOX#XOc#YOq1`Ox1nO!^#ZO~P'ZO&o#^O&p#`O~O&r#aO&s#`O~OQ#cO%l#dO%m#fO~OR#gO%n#hO%o#fO~OS#jO%p#kO%q#fO~OT#mO%r#nO%s#fO~OX%{Xa%{Xc%{Xj%{Xm%{Xn%{Xo%{Xp%{Xq%{Xr%{Xu%{X|%{X!Z%{X!h%{X%|%{X%}%{X&O%{X&P%{X&Q%{X&R%{X&S%{X&T%{X&U%{X&V%{Xi%{X!V%{X!W%{X~O&m]O&n^O&q_O&t`O&xaO&ybO&zcO}%{X#Q%{X#o%{X%h%{X%k%{X&^%{X&_%{X!Y%{X!^%{X!S%{X#d%{Xv%{X!o%{X~P,QO|#sO}%zX#Q%zX#o%zX%h%zX%k%zX&^%zX~Oq1`Ox1nO~P'ZO#o#vO%h#xO%k#xO~O&XWO~O!V#}O#}![O$S!]O$VmO~OquO~P'ZOX$SOc$TO&XWO}yP~OX$XOq1`Ox1nO!S$YO~P'ZO}$[O#Q$aO&^$]O#o#RX%h#RX%k#RX~OX$XOq1`Ox1nO#o#[X%h#[X%k#[X~P'ZOq1`Ox1nO#o#`X%h#`X%k#`X~P'ZO!h$gO!z$gO&XWO~OX$rO~P'ZO!W$tO#{$uO#}$vO~O}$wO~OX%OO~P'ZOU%QO%h%PO%u%RO~OX%[Oc%[Oi%^Oq1`Ox1nO~P'ZOq1`Ox1nO}%aO~P'ZO&l%cO~Oc!gOj!nO!Z!pO!h!rOXdaadamdandaodapdaqdardauda|da}da#Qda#oda%hda%kda%|da%}da&Oda&Pda&Qda&Rda&Sda&Tda&Uda&Vda&^daida!Vda!Wda&_da!Yda!^da!Sda#ddavda!oda~Op%hO~Oq%hO~P'ZOq1`O~P'ZOm1bOn1cOo1aOp1aOq1jOr1kOu1oOi&ZX!V&ZX!W&ZX&_&ZX!Y&ZX!^&ZX!S&ZX#d&ZX!o&ZX~P(hO&_%jOi&YX|&YX!V&YX!W&YX!Y&YX}&YX~Oi%lO|%mO!V%qO!W%pO~Oi%lO~O|%tO!V%qO!W%pO!Y&fX~O!Y%xO~O|%yO}%{O!V%qO!W%pO!^&aX~O!^&PO~O!^&QO~O&o#^O&p&SO~O&r#aO&s&SO~OX&VOq1`Ox1nO!RwO~P'ZOQ#cO%l#dO%m&YO~OR#gO%n#hO%o&YO~OS#jO%p#kO%q&YO~OT#mO%r#nO%s&YO~OX!yaa!yac!yaj!yam!yan!yao!yap!yaq!yar!yau!ya|!ya}!ya!Z!ya!h!ya#Q!ya#o!ya%h!ya%k!ya%|!ya%}!ya&O!ya&P!ya&Q!ya&R!ya&S!ya&T!ya&U!ya&V!ya&^!yai!ya!V!ya!W!ya&_!ya!Y!ya!^!ya!S!ya#d!yav!ya!o!ya~P#yO|&bO}%za#Q%za#o%za%h%za%k%za&^%za~P$gOX&dOquOxvO}%za#Q%za#o%za%h%za%k%za&^%za~P'ZO|&bO}%za#Q%za#o%za%h%za%k%za&^%za~OPiOXfOquOxvO!RwO!S!QO#TyO#VzO#X{O#Z|O#]}O#a!OO#c!PO#f!RO#g!RO#i!SO#k!TO#o%WX%h%WX%k%WX~P'ZO#o#vO%h&iO%k&iO~O!h&jOj&|X%h&|X#d&|X#o&|X%k&|X#c&|X~Oj!nO%h&lO~Omgangaogapgaqgargauga|ga}ga#Qga#oga%hga%kga&^gaiga!Vga!Wga&_ga!Yga!^ga!Sga#dgavga!oga~P$gOusa|sa}sa#osa%hsa%ksa&^sa~Om!uOn!vOo!tOp!tOq!wOr!xO#Qsa~PDuO&^&nO|&]X}&]X~O&XWO|&]X}&]X~O|&qO}yX~O}&sO~O|%yO#o&aX%h&aX%k&aXi&aX}&aX!^&aX!o&aX&^&aX~OX1iOq1`Ox1nO!RwO~P'ZO&^$]O#oWa%hWa%kWa~O|&|O#o&cX%h&cX%k&cXp&cX~P$gO|'PO!S'OO#o#`a%h#`a%k#`a~O#d'QO#o#ba%h#ba%k#ba~O!h$gO!z$gO#c'SO&XWO~O#c'SO~O|'UO#o'PX%h'PX%k'PX~O|'WO#o&{X%h&{X%k&{X}&{X~O!Z'YO&^'ZO~O|'_Op'SX~P$gOp'bO~OPiOXfOquOxvO!RwO!S!QO#TyO#VzO#X{O#Z|O#]}O#a!OO#c!PO#f!RO#g!RO#i!SO#k!TO%h'gO~P'ZOv'kO#x'iO#y'jOP#vaX#vah#vaj#vaq#vau#vax#va!R#va!S#va!V#va!W#va!Z#va!_#va!j#va!z#va!{#va!|#va#T#va#V#va#X#va#Z#va#]#va#a#va#c#va#f#va#g#va#i#va#k#va#t#va#w#va#{#va#}#va$S#va$V#va$X#va%e#va&R#va&S#va&W#va&X#va&m#va&n#va&q#va&t#va&x#va&y#va&z#va%g#va%k#va~O|'lO#d'nO}'TX~Oj'pO!Z'YO~Oj!nO}$wO!Z'YO~O}'vO~P$gO%h'yO~OU'zO%h'yO~OX!fOa!fOc!gOj!nO!Z!pO!h!rO&O!cO&P!dO&Q!dO&R!eO&S!eO&T!fO&U!fO&V!fOmYinYioYipYiqYirYiuYi|Yi}Yi#QYi#oYi%hYi%kYi%|Yi&^YiiYi!VYi!WYi&_Yi!YYi!^Yi!SYi#dYivYi!oYi~O%}!bO~P!!`O%}Yi~P!!`OX!fOa!fOc!gOj!nO!Z!pO!h!rO&R!eO&S!eO&T!fO&U!fO&V!fOmYinYioYipYiqYirYiuYi|Yi}Yi#QYi#oYi%hYi%kYi%|Yi%}Yi&OYi&^YiiYi!VYi!WYi&_Yi!YYi!^Yi!SYi#dYivYi!oYi~O&P!dO&Q!dO~P!%ZO&PYi&QYi~P!%ZOc!gOj!nO!Z!pO!h!rOmYinYioYipYiqYirYiuYi|Yi}Yi#QYi#oYi%hYi%kYi%|Yi%}Yi&OYi&PYi&QYi&RYi&SYi&^YiiYi!VYi!WYi&_Yi!YYi!^Yi!SYi#dYivYi!oYi~OX!fOa!fO&T!fO&U!fO&V!fO~P!(XOXYiaYi&TYi&UYi&VYi~P!(XO!V%qO!W%pOi&iX|&iX~O&^'|O&_'|O~P,QO|(OOi&hX~Oi(QO~O|(RO}(TO!Y&kX~Oq1`Ox1nO|(RO}(UO!Y&kX~P'ZO!Y(WO~Oo!tOp!tOq!wOr!xOmliuli|li}li#Qli#oli%hli%kli&^li~On!vO~P!,zOnli~P!,zOm1bOn1cOo1aOp1aOq1jOr1kO~Ov(YO~P!.TOX(_Oi(`Oq1`Ox1nO~P'ZOi(`O|(aO~Oi(cO~O!W(eO~Oi(fO|(aO!V%qO!W%pO~P$gOm1bOn1cOo1aOp1aOq1jOr1kOisa!Vsa!Wsa&_sa!Ysa!^sa!Ssa#dsavsa!osa~PDuOX(_Oq1`Ox1nO!Y&fa~P'ZO|(iO!Y&fa~O!Y(jO~O|(iO!V%qO!W%pO!Y&fa~P$gOX(nOq1`Ox1nO!^&aa#o&aa%h&aa%k&aai&aa}&aa!o&aa&^&aa~P'ZO|(oO!^&aa#o&aa%h&aa%k&aai&aa}&aa!o&aa&^&aa~O!^(rO~O|(oO!V%qO!W%pO!^&aa~P$gO|(uO!V%qO!W%pO!^&ga~P$gO|(xO}&uX!^&uX!o&uX&^&uX~O}(|O!^)OO!o)PO&^({O~O}(|O!^)SO!o)TO&^)RO~O}(|O!^)WO!o)XO&^)VO~O}(|O!^)[O!o)]O&^)ZO~OX&dOquOxvO}%zi#Q%zi#o%zi%h%zi%k%zi&^%zi~P'ZO|)_O}%zi#Q%zi#o%zi%h%zi%k%zi&^%zi~O!h&jOj&|a%h&|a#d&|a#o&|a%k&|a#c&|a~O%h)dO~OX$SOc$TO&XWO~O|&qO}ya~OquOxvO~P'ZO|(oO#o&aa%h&aa%k&aai&aa}&aa!^&aa!o&aa&^&aa~P$gO|)iO#o%zX%h%zX%k%zX&^%zX~O&^$]O#oWi%hWi%kWi~O#o&ca%h&ca%k&cap&ca~P'ZO|)lO#o&ca%h&ca%k&cap&ca~OX)pOj)rO&XWO~O#c)sO~O&XWO#o'Pa%h'Pa%k'Pa~O|)uO#o'Pa%h'Pa%k'Pa~Oq1`Ox1nO#o&{a%h&{a%k&{a}&{a~P'ZO|)xO#o&{a%h&{a%k&{a}&{a~OX)zOc)zO&XWO~O&^*PO~Ov*SO#r*ROP#piX#pih#pij#piq#piu#pix#pi!R#pi!S#pi!V#pi!W#pi!Z#pi!_#pi!j#pi!z#pi!{#pi!|#pi#T#pi#V#pi#X#pi#Z#pi#]#pi#a#pi#c#pi#f#pi#g#pi#i#pi#k#pi#t#pi#w#pi#{#pi#}#pi$S#pi$V#pi$X#pi%e#pi&R#pi&S#pi&W#pi&X#pi&m#pi&n#pi&q#pi&t#pi&x#pi&y#pi&z#pi%g#pi%k#pi~Ov*TOP#siX#sih#sij#siq#siu#six#si!R#si!S#si!V#si!W#si!Z#si!_#si!j#si!z#si!{#si!|#si#T#si#V#si#X#si#Z#si#]#si#a#si#c#si#f#si#g#si#i#si#k#si#t#si#w#si#{#si#}#si$S#si$V#si$X#si%e#si&R#si&S#si&W#si&X#si&m#si&n#si&q#si&t#si&x#si&y#si&z#si%g#si%k#si~OX*VOp'Sa~P'ZO|*WOp'Sa~O|*WOp'Sa~P$gOp*[O~O%f*`O~Ov*cO#x'iO#y*bOP#viX#vih#vij#viq#viu#vix#vi!R#vi!S#vi!V#vi!W#vi!Z#vi!_#vi!j#vi!z#vi!{#vi!|#vi#T#vi#V#vi#X#vi#Z#vi#]#vi#a#vi#c#vi#f#vi#g#vi#i#vi#k#vi#t#vi#w#vi#{#vi#}#vi$S#vi$V#vi$X#vi%e#vi&R#vi&S#vi&W#vi&X#vi&m#vi&n#vi&q#vi&t#vi&x#vi&y#vi&z#vi%g#vi%k#vi~OX*fOq1`Ox1nO}$wO~P'ZOq1`Ox1nO}'Ta~P'ZO|*jO}'Ta~OX*nOc*oOi*rO&T*pO&XWO~O}$wO'W*tO~Oj'pO~Oj!nO}$wO~O%h*yO~O%h*{O~OX%[Oc%[Oq1`Ox1nOi&ha~P'ZO|+OOi&ha~Oq1`Ox1nO}+RO!Y&ka~P'ZO|+SO!Y&ka~Oq1`Ox1nO|+SO}+VO!Y&ka~P'ZOq1`Ox1nO|+SO!Y&ka~P'ZO|+SO}+VO!Y&ka~Oo1aOp1aOq1jOr1kOilimliuli|li!Vli!Wli&_li!Yli}li!^li#oli%hli%kli!Sli#dlivli!oli&^li~On1cO~P!KZOnli~P!KZOX(_Oi+[Oq1`Ox1nO~P'ZOp+^O~Oi+[O|+`O~Oi+aO~OX(_Oq1`Ox1nO!Y&fi~P'ZO|+bO!Y&fi~O!Y+cO~OX(nOq1`Ox1nO!^&ai#o&ai%h&ai%k&aii&ai}&ai!o&ai&^&ai~P'ZO|+fO!V%qO!W%pO!^&gi~O|+iO!^&ai#o&ai%h&ai%k&aii&ai}&ai!o&ai&^&ai~O!^+jO~Oc+lOq1`Ox1nO!^&gi~P'ZO|+fO!^&gi~O!^+nO~OX+pOq1`Ox1nO}&ua!^&ua!o&ua&^&ua~P'ZO|+qO}&ua!^&ua!o&ua&^&ua~O!_+tO&w+uO!^!pX~O!^+wO~O}(|O!^+xO~O}(|O!^+xO!o+yO~O}(|O!^+zO~O}(|O!^+zO!o+{O~O}(|O!^+|O~O}(|O!^+|O!o+}O~O}(|O!^,OO~O}(|O!^,OO!o,PO~OX&dOquOxvO}%zq#Q%zq#o%zq%h%zq%k%zq&^%zq~P'ZO|%Oi}%Oi#Q%Oi#o%Oi%h%Oi%k%Oi&^%Oi~P$gOX&dOquOxvO~P'ZOX&dOq1`Ox1nO#o%za%h%za%k%za&^%za~P'ZO|,QO#o%za%h%za%k%za&^%za~O|$qa#o$qa%h$qa%k$qap$qa~P$gO#o&ci%h&ci%k&cip&ci~P'ZO|,TO#o#`q%h#`q%k#`q~O|,UO#d,WO#o'OX%h'OX%k'OXi'OX~OX,YOj)rO&XWO~O&XWO#o'Pi%h'Pi%k'Pi~Oq1`Ox1nO#o&{i%h&{i%k&{i}&{i~P'ZO}$[O|#mX!Y#mX~O|,^O!Y'QX~O!Y,`O~Ov,cO#r*ROP#pqX#pqh#pqj#pqq#pqu#pqx#pq!R#pq!S#pq!V#pq!W#pq!Z#pq!_#pq!j#pq!z#pq!{#pq!|#pq#T#pq#V#pq#X#pq#Z#pq#]#pq#a#pq#c#pq#f#pq#g#pq#i#pq#k#pq#t#pq#w#pq#{#pq#}#pq$S#pq$V#pq$X#pq%e#pq&R#pq&S#pq&W#pq&X#pq&m#pq&n#pq&q#pq&t#pq&x#pq&y#pq&z#pq%g#pq%k#pq~Op%Ya|%Ya~P$gOX*VOp'Si~P'ZO|,jOp'Si~O|,tO}$wO#d,tO~O#y,vOP#vqX#vqh#vqj#vqq#vqu#vqx#vq!R#vq!S#vq!V#vq!W#vq!Z#vq!_#vq!j#vq!z#vq!{#vq!|#vq#T#vq#V#vq#X#vq#Z#vq#]#vq#a#vq#c#vq#f#vq#g#vq#i#vq#k#vq#t#vq#w#vq#{#vq#}#vq$S#vq$V#vq$X#vq%e#vq&R#vq&S#vq&W#vq&X#vq&m#vq&n#vq&q#vq&t#vq&x#vq&y#vq&z#vq%g#vq%k#vq~O#d,wO|%[a}%[a~Oq1`Ox1nO}'Ti~P'ZO|,yO}'Ti~O}$[O&^,{Oi'VX|'VX~O&XWOi'VX|'VX~O|-POi'UX~Oi-RO~O%f-UO~O!V%qO!W%pOi&ii|&ii~OX%[Oc%[Oq1`Ox1nOi&hi~P'ZO}-XO|$ta!Y$ta~Oq1`Ox1nO}-YO|$ta!Y$ta~P'ZOq1`Ox1nO}+RO!Y&ki~P'ZO|-]O!Y&ki~Oq1`Ox1nO|-]O!Y&ki~P'ZO|-]O}-`O!Y&ki~Oi$pi|$pi!Y$pi~P$gOX(_Oq1`Ox1nO~P'ZOp-bO~OX(_Oi-cOq1`Ox1nO~P'ZOX(_Oq1`Ox1nO!Y&fq~P'ZO|$oi!^$oi#o$oi%h$oi%k$oii$oi}$oi!o$oi&^$oi~P$gOX(nOq1`Ox1nO~P'ZOc+lOq1`Ox1nO!^&gq~P'ZO|-dO!^&gq~O!^-eO~OX(nOq1`Ox1nO!^&aq#o&aq%h&aq%k&aqi&aq}&aq!o&aq&^&aq~P'ZO}-fO~OX+pOq1`Ox1nO}&ui!^&ui!o&ui&^&ui~P'ZO|-kO}&ui!^&ui!o&ui&^&ui~O!_+tO&w+uO!^!pa~O}(|O!^-nO~O}(|O!^-oO~O}(|O!^-pO~O}(|O!^-qO~OX&dOq1`Ox1nO#o%zi%h%zi%k%zi&^%zi~P'ZO|-rO#o%zi%h%zi%k%zi&^%zi~O&XWO#o'Oa%h'Oa%k'Oai'Oa~O|-uO#o'Oa%h'Oa%k'Oai'Oa~Oi-xO~OX)zOc)zO&XWO!Y'Qa~O|-zO!Y'Qa~Op%Yi|%Yi~P$gOX*VO~P'ZOX*VOp'Sq~P'ZOv.OOP#uyX#uyh#uyj#uyq#uyu#uyx#uy!R#uy!S#uy!V#uy!W#uy!Z#uy!_#uy!j#uy!z#uy!{#uy!|#uy#T#uy#V#uy#X#uy#Z#uy#]#uy#a#uy#c#uy#f#uy#g#uy#i#uy#k#uy#t#uy#w#uy#{#uy#}#uy$S#uy$V#uy$X#uy%e#uy&R#uy&S#uy&W#uy&X#uy&m#uy&n#uy&q#uy&t#uy&x#uy&y#uy&z#uy%g#uy%k#uy~O%g.SO%k.SO~P`O#y.TOP#vyX#vyh#vyj#vyq#vyu#vyx#vy!R#vy!S#vy!V#vy!W#vy!Z#vy!_#vy!j#vy!z#vy!{#vy!|#vy#T#vy#V#vy#X#vy#Z#vy#]#vy#a#vy#c#vy#f#vy#g#vy#i#vy#k#vy#t#vy#w#vy#{#vy#}#vy$S#vy$V#vy$X#vy%e#vy&R#vy&S#vy&W#vy&X#vy&m#vy&n#vy&q#vy&t#vy&x#vy&y#vy&z#vy%g#vy%k#vy~O|.WO}$wO#d.WO~Oq1`Ox1nO}'Tq~P'ZO|.ZO}'Tq~O&^,{Oi'Va|'Va~OX*nOc*oO&T*pO&XWOi'Ua~O|._Oi'Ua~O$[.cO~OX%[Oc%[Oq1`Ox1nO~P'ZOq1`Ox1nO}.dO|$ti!Y$ti~P'ZOq1`Ox1nO|$ti!Y$ti~P'ZO}.dO|$ti!Y$ti~Oq1`Ox1nO}+RO~P'ZOq1`Ox1nO}+RO!Y&kq~P'ZO|.gO!Y&kq~Oq1`Ox1nO|.gO!Y&kq~P'ZOu.jO!V%qO!W%pOi&bq!Y&bq!^&bq|&bq~P!.TOc+lOq1`Ox1nO!^&gy~P'ZO|$ri!^$ri~P$gOc+lOq1`Ox1nO~P'ZOX+pOq1`Ox1nO~P'ZOX+pOq1`Ox1nO}&uq!^&uq!o&uq&^&uq~P'ZO}(|O!^.oO!o.pO&^.nO~OX&dOq1`Ox1nO#o%zq%h%zq%k%zq&^%zq~P'ZO#d.rO|%Ta#o%Ta%h%Ta%k%Tai%Ta~O&XWO#o'Oi%h'Oi%k'Oii'Oi~O|.tO#o'Oi%h'Oi%k'Oii'Oi~OX)zOc)zO&XWO!Y'Qi~Ov.xOP#u!RX#u!Rh#u!Rj#u!Rq#u!Ru#u!Rx#u!R!R#u!R!S#u!R!V#u!R!W#u!R!Z#u!R!_#u!R!j#u!R!z#u!R!{#u!R!|#u!R#T#u!R#V#u!R#X#u!R#Z#u!R#]#u!R#a#u!R#c#u!R#f#u!R#g#u!R#i#u!R#k#u!R#t#u!R#w#u!R#{#u!R#}#u!R$S#u!R$V#u!R$X#u!R%e#u!R&R#u!R&S#u!R&W#u!R&X#u!R&m#u!R&n#u!R&q#u!R&t#u!R&x#u!R&y#u!R&z#u!R%g#u!R%k#u!R~Oq1`Ox1nO}'Ty~P'ZOX*nOc*oO&T*pO&XWOi'Ui~O$[.cO%g/QO%k/QO~OX/[Oj/YO!Z/XO!_/ZO!j/TO!{/VO!|/VO&S/SO&XWO&m]O&n^O&q_O~Oq1`Ox1nO|$tq!Y$tq~P'ZO}/aO|$tq!Y$tq~Oq1`Ox1nO}+RO!Y&ky~P'ZO|/bO!Y&ky~Oq1`Ox/fO~P'ZOu.jO!V%qO!W%pOi&by!Y&by!^&by|&by~P!.TO}(|O!^/iO~O}(|O!^/iO!o/jO~O&XWO#o'Oq%h'Oq%k'Oqi'Oq~O|/lO#o'Oq%h'Oq%k'Oqi'Oq~OX*nOc*oO&T*pO&XWO~Oj/qO!h/oO|$]X#d$]X%|$]Xi$]X~Ou$]X}$]X!Y$]X!^$]X~P$)YO&R/sO&S/sOu$^X|$^X}$^X#d$^X%|$^X!Y$^Xi$^X!^$^X~O!j/uO~O|/yO#d/{O%|/vOu'XX}'XX!Y'XXi'XX~Oc0OO~P$%_Oj/qOu'YX|'YX}'YX#d'YX%|'YX!Y'YXi'YX!^'YX~Ou0SO}$wO~Oq1`Ox1nO|$ty!Y$ty~P'ZOq1`Ox1nO}+RO!Y&k!R~P'ZO|0WO!Y&k!R~Oi&eXu&eX!V&eX!W&eX!Y&eX!^&eX|&eX~P!.TOu.jO!V%qO!W%pOi&da!Y&da!^&da|&da~O}(|O!^0ZO~O&XWO#o'Oy%h'Oy%k'Oyi'Oy~O!h/oOj$dau$da|$da}$da#d$da%|$da!Y$dai$da!^$da~O!j0bO~O&R/sO&S/sOu$^a|$^a}$^a#d$^a%|$^a!Y$^ai$^a!^$^a~O%|/vOu$ba|$ba}$ba#d$ba!Y$bai$ba!^$ba~Ou'Xa}'Xa!Y'Xai'Xa~P$%RO|0gOu'Xa}'Xa!Y'Xai'Xa~O!Y0jO~Oi0jO~O}0lO~O!^0mO~Oq1`Ox1nO}+RO!Y&k!Z~P'ZO}0pO~O&^0qO~P$)YO|0rO#d/{O%|/vOi'[X~O|0rOi'[X~Oi0tO~O!j0uO~O#d/{Ou%`a|%`a}%`a%|%`a!Y%`ai%`a!^%`a~O#d/{O%|/vOu%da|%da}%da!Y%dai%da~Ou'Xi}'Xi!Y'Xii'Xi~P$%RO|0wO#d/{O%|/vO!^'Za~O}$la~P$gOi'[a~P$%RO|1POi'[a~Oc1RO!^'Zi~P$%_O|1TO!^'Zi~O|1TO#d/{O%|/vO!^'Zi~O#d/{O%|/vOi$ji|$ji~O&^1WO~P$)YO#d/{O%|/vOi%ca|%ca~Oi'[i~P$%RO}1ZO~Oc1RO!^'Zq~P$%_O|1]O!^'Zq~O#d/{O%|/vO|%bi!^%bi~Oc1RO~P$%_Oc1RO!^'Zy~P$%_O#d/{O%|/vOi$ki|$ki~O#d/{O%|/vO|%bq!^%bq~O|,QO#o%za%h%za%k%za&^%za~P$gOX&dOq1`Ox1nO~P'ZOp1eO~Oq1eO~P'ZO}1fO~Ov1gO~P!.TO&n&q&y&z&m&t&x&X&m~",
  goto: "!@f']PPPPPPPP'^P'f+R+k,U,p-]-yP.hP'f/X/X'fPPP'f2tPPPPPP2t5kPP5kP8O8X>kPP>n?`?cPP'f'fPP?{PP'f'fPP'f'f'f'f'f@P@y'fP@|PASE^H}IRPIUIlIpIsIwIzJOJRJV'fPPPJYJc'^P'^'^P'^P'^P'^P'^P'^'^'^P'^PP'^PP'^P'^PJiJuJ}PKUK[PKUPKUKUPPPKUPMjPMsM}NTMjPKUN^PKUPNeNkPNo! T! r!!]NoNo!!c!!pNoNoNoNo!#U!#[!#_!#d!#g!#q!#w!$T!$g!$m!$w!$}!%k!%q!%w!%}!&X!&_!&e!&k!&q!&w!'Z!'e!'k!'q!'w!(R!(X!(_!(e!(k!(u!({!)V!)]!)f!)l!){!*T!*_!*fPPPPPPPPPPPPPPPPP!*l!*o!*u!+O!+Y!+ePPPPPPPPPPPP!0[!1p!5s!9WPP!9`!9r!9{!:t!:k!:}!;T!;W!;Z!;^!;f!<VPPPPPPPPP!<Y!<iPPPP!=m!=y!>V!>]!>f!>i!>l!>r!>x!?O!?RP!?Z!?d!@`!@c]jOs#v$w*`,p(TeOTYZ[fistuwy}!O!S!U!V!W!Z!^!h!i!j!k!l!m!n!p!t!u!v!x!y#P#T#X#Y#c#g#j#m#s#v$X$Y$[$^$a$r$t$u$w%O%[%a%h%k%m%p%t%y%{&V&b&d&o&s&|'O'P'W'Z'_'b'i'l'}(O(R(T(U(Y(_(a(e(i(n(o(u(x)_)a)i)l)x*P*R*V*W*[*`*f*j*t+O+R+S+V+]+^+`+b+e+f+i+l+p+q+t,Q,S,T,[,i,j,p,x,y,|-W-X-Y-[-]-`-b-d-f-h-j-k-r.Z.].d.g.j/a/b0S0W0p1`1a1b1c1e1f1g1h1i1k1o}!hQ#r$P$b$q$}%r%w%}&O&t'a'x)`)k*U+Z+d,h-g0n1d!P!iQ#r$P$b$q$}%S%r%w%}&O&t'a'x)`)k*U+Z+d,h-g0n1d!R!jQ#r$P$b$q$}%S%T%r%w%}&O&t'a'x)`)k*U+Z+d,h-g0n1d!T!kQ#r$P$b$q$}%S%T%U%r%w%}&O&t'a'x)`)k*U+Z+d,h-g0n1d!V!lQ#r$P$b$q$}%S%T%U%V%r%w%}&O&t'a'x)`)k*U+Z+d,h-g0n1d!X!mQ#r$P$b$q$}%S%T%U%V%W%r%w%}&O&t'a'x)`)k*U+Z+d,h-g0n1d!]!mQ!s#r$P$b$q$}%S%T%U%V%W%X%r%w%}&O&t'a'x)`)k*U+Z+d,h-g0n1d(TTOTYZ[fistuwy}!O!S!U!V!W!Z!^!h!i!j!k!l!m!n!p!t!u!v!x!y#P#T#X#Y#c#g#j#m#s#v$X$Y$[$^$a$r$t$u$w%O%[%a%h%k%m%p%t%y%{&V&b&d&o&s&|'O'P'W'Z'_'b'i'l'}(O(R(T(U(Y(_(a(e(i(n(o(u(x)_)a)i)l)x*P*R*V*W*[*`*f*j*t+O+R+S+V+]+^+`+b+e+f+i+l+p+q+t,Q,S,T,[,i,j,p,x,y,|-W-X-Y-[-]-`-b-d-f-h-j-k-r.Z.].d.g.j/a/b0S0W0p1`1a1b1c1e1f1g1h1i1k1o&iVOYZ[isuw}!O!S!U!V!Z!n!p!t!u!v!x!y#c#g#j#m#s#v$Y$[$^$a$u$w%[%a%h%k%m%t%y%{&V&b&o&s'O'P'W'Z'b'i'l'}(O(R(T(U(Y(a(i(o(u(x)_)a)i)x*P*R*[*`*f*j*t+O+R+S+V+]+^+`+b+e+f+i+p+q+t,Q,T,[,p,x,y,|-W-X-Y-[-]-`-b-d-f-h-j-k-r.Z.].d.g.j/a/b0W0p1`1a1b1c1e1f1g1h1k1o%sXOYZ[isw}!O!S!U!V!Z!n!p#c#g#j#m#s#v$Y$[$^$a$u$w%[%a%k%m%t%y%{&V&b&o&s'O'P'W'Z'b'i'l'}(O(R(T(U(Y(a(i(o(u(x)_)a)i)x*P*R*[*`*f*j*t+O+R+S+V+]+`+b+e+f+i+p+q+t,Q,T,[,p,x,y,|-W-X-Y-[-]-`-d-f-h-j-k-r.Z.].d.g/a/b0W1f1g1hQ$VvQ0X/fR1l1n'zeOTYZ[fistuwy}!O!S!U!V!W!Z!^!h!i!j!k!l!m!p!t!u!v!x!y#P#T#X#Y#c#g#j#m#s#v$X$Y$[$^$a$r$t$u$w%O%[%a%h%k%m%p%t%y%{&V&b&d&o&s&|'O'P'W'Z'_'b'i'l'}(R(T(U(Y(_(a(e(i(n(o(u(x)_)a)i)l)x*P*R*V*W*[*`*f*j*t+R+S+V+]+^+`+b+e+f+i+l+p+q+t,Q,S,T,[,i,j,p,x,y,|-X-Y-[-]-`-b-d-f-h-j-k-r.Z.].d.g.j/a/b0S0W0p1`1a1b1c1e1f1g1h1i1k1oW#ym!P!Q$hW$Rv&q/f1nQ$j!RQ$n!TQ${![Q$|!]W%Z!n(O+O-WS&p$S$TQ'e$vQ)b&jQ)p'QU)q'S)r)sU)t'U)u,ZW){'Y,^-z.vQ*l'nW*m'p-P._/OQ,])zS-O*n*oY-t,U-u.s.t/lQ-w,WQ.U,tQ.Y,wQ.|.Wl/R.c/X/Y/[/w/y0O0g0l0q0v1R1W1ZQ/k.rQ0P/ZQ0^/qQ0i/{U0|0r1P1XX1S0w1T1[1]R&o$R!_!|YZ!U!V!p%a%m%t(R(T(U(a(i*R+R+S+V+]+`+b-X-Y-[-]-`.d.g/a/b0WR%k!{Q#QYQ&W#cQ&Z#gQ&]#jQ&_#mQ&x$^Q&{$aR-l+tT/e.j0p![!oQ!s#r$P$b$q$}%S%T%U%V%W%X%r%w%}&O&t'a'x)`)k*U+Z+d,h-g0n1dQ&m#zQ't$|R*x'uR'}%ZQ%d!rR0[/o(SdOTYZ[fistuwy}!O!S!U!V!W!Z!^!h!i!j!k!l!m!n!p!t!u!v!x!y#P#T#X#Y#c#g#j#m#s#v$X$Y$[$^$a$r$t$u$w%O%[%a%h%k%m%p%t%y%{&V&b&d&o&s&|'O'P'W'Z'_'b'i'l'}(O(R(T(U(Y(_(a(e(i(n(o(u(x)_)a)i)l)x*P*R*V*W*[*`*f*j*t+O+R+S+V+]+^+`+b+e+f+i+l+p+q+t,Q,S,T,[,i,j,p,x,y,|-W-X-Y-[-]-`-b-d-f-h-j-k-r.Z.].d.g.j/a/b0S0W0p1`1a1b1c1e1f1g1h1i1k1oS#pd#q!P/V.c/X/Y/Z/[/q/w/y0O0g0l0q0r0v0w1P1R1T1W1X1Z1[1](SdOTYZ[fistuwy}!O!S!U!V!W!Z!^!h!i!j!k!l!m!n!p!t!u!v!x!y#P#T#X#Y#c#g#j#m#s#v$X$Y$[$^$a$r$t$u$w%O%[%a%h%k%m%p%t%y%{&V&b&d&o&s&|'O'P'W'Z'_'b'i'l'}(O(R(T(U(Y(_(a(e(i(n(o(u(x)_)a)i)l)x*P*R*V*W*[*`*f*j*t+O+R+S+V+]+^+`+b+e+f+i+l+p+q+t,Q,S,T,[,i,j,p,x,y,|-W-X-Y-[-]-`-b-d-f-h-j-k-r.Z.].d.g.j/a/b0S0W0p1`1a1b1c1e1f1g1h1i1k1oT#pd#qT#d`#eR)Q&Wy(}&W&Z&]&_)P)Q)T)U)X)Y)])^+y+{+},P-l.p.q/jT+u(|+vR.q-lT#ha#iR)U&ZT#kb#lR)Y&]T#nc#oR)^&_Q$`xQ,]){R,}*mX$^x$_$`&zQ'[$nQ'r${Q'u$|R*_'eQ)|'YV-y,^-z.vZlOs$w*`,pXpOs*`,pQ$x!YQ']$oQ'^$pQ'o$zQ's$|Q*]'dQ*d'iQ*g'jQ*h'kQ*u'qS*w't'uQ,d*RQ,f*SQ,g*TQ,k*ZS,m*^*vQ,q*bQ,r*cS,s*e*fQ-T*xQ-|,cQ-},eQ.P,lS.Q,n,oQ.V,uQ.X,vQ.w.OQ.y.RQ.z.TQ.{.UQ/m.xQ/n.|Q0T/_R0o0UWpOs*`,pR#|oQ'q${S*^'e'rR,o*_Q,|*mR.],}Q*v'qQ,n*^R.R,oZnOos*`,pQ'w$}R*z'xT.a-U.bu/^.c/X/Y/[/q/w/y0O0g0l0q0r0v1P1R1W1X1Zt/^.c/X/Y/[/q/w/y0O0g0l0q0r0v1P1R1W1X1ZQ0P/ZX1S0w1T1[1]!P/U.c/X/Y/Z/[/q/w/y0O0g0l0q0r0v0w1P1R1T1W1X1Z1[1]Q/t/TR0c/ug/w/W/x0_0f0k0y0{0}1Y1^1_u/].c/X/Y/[/q/w/y0O0g0l0q0r0v1P1R1W1X1ZX/r/R/]0^0|R0`/qV1O0r1P1XR0U/_QsOS$Os,pR,p*`Q&r$UR)g&rS%z#W$WS(p%z(sT(s%}&tQ%n#OQ%u#SW(b%n%u(g(kQ(g%rR(k%wQ&}$bR)m&}Q(v&OQ+g(qT+m(v+gQ(P%]R+P(PS(S%`%aY+T(S+U-^.h/cU+U(T(U(VU-^+V+W+XS.h-_-`R/c.iQ#_^R&R#_Q#b_R&T#bQ#e`R&X#eQ(y&US+r(y+sR+s(zQ+v(|R-m+vQ#iaR&[#iQ#lbR&^#lQ#ocR&`#oQ#qdR&a#qQ#tgQ&c#rW&f#t&c)j,RQ)j&wR,R1dQ$_xS&y$_&zR&z$`Q'X$lR)y'XQ&k#yR)c&kQ$h!QR'R$hQ,V)qS-v,V.uR.u-wQ'V$jR)v'VQ,_)|R-{,_Q#wkR&h#wQ*Q']R,b*QQ'`$qS*X'`*YR*Y'aQ'h$xR*a'hQ'm$yS*k'm,zR,z*lQ-Q*qR.`-QWoOs*`,pR#{oQ.b-UR/P.bd/x/W0_0f0k0y0{0}1Y1^1_R0e/xU/p/R0^0|R0]/pQ0x0kS1U0x1VR1V0yS0s0_0`R1Q0sQ/z/WR0h/zR!`PXrOs*`,pWqOs*`,pR'f$wYkOs$w*`,pR&g#v[xOs#v$w*`,pR&x$^&hQOYZ[isuw}!O!S!U!V!Z!n!p!t!u!v!x!y#c#g#j#m#s#v$Y$[$^$a$u$w%[%a%h%k%m%t%y%{&V&b&o&s'O'P'W'Z'b'i'l'}(O(R(T(U(Y(a(i(o(u(x)_)a)i)x*P*R*[*`*f*j*t+O+R+S+V+]+^+`+b+e+f+i+p+q+t,Q,T,[,p,x,y,|-W-X-Y-[-]-`-b-d-f-h-j-k-r.Z.].d.g.j/a/b0W0p1`1a1b1c1e1f1g1h1k1oQ!sTQ#rfQ$PtU$by%p(eS$q!W$tQ$}!^Q%S!hQ%T!iQ%U!jQ%V!kQ%W!lQ%X!mQ%r#PQ%w#TQ%}#XQ&O#YQ&t$XQ'a$rQ'x%OQ)`&dU)k&|)l,SW*U'_*W,i,jQ+Z(_Q+d(nQ,h*VQ-g+lQ0n0SR1d1iQ#OYQ#SZQ$o!UQ$p!VQ%`!pQ(V%a^(^%m%t(a(i+]+`+b^+Q(R+S-[-].g/b0WQ+W(TQ+X(UQ,e*RQ-Z+RQ-_+VQ.e-XQ.f-YQ.i-`Q/`.dR0V/a[gOs#v$w*`,p!^!{YZ!U!V!p%a%m%t(R(T(U(a(i*R+R+S+V+]+`+b-X-Y-[-]-`.d.g/a/b0WQ#W[Q#uiS$Ww}Q$e!OW$l!S$a'b*[S$y!Z$uW%Y!n(O+O-WY&U#c#g#j#m+t`&e#s&b)_)a)i,Q-r1hQ&u$YQ&v$[Q&w$^Q'{%[Q(]%kW(m%y(o+e+iQ(q%{Q(z&VQ)e&oS)h&s1fQ)n'OQ)o'PU)w'W)x,[Q*O'ZQ*e'iY*i'l*j,x,y.ZQ*|'}S+Y(Y1gW+k(u+f-d-hW+o(x+q-j-kQ,a*PQ,u*fQ-S*tQ-i+pQ-s,TQ.[,|Q.m-fR.}.]hUOs#s#v$w&b&s(Y)_)a*`,p%Y!zYZ[iw}!O!S!U!V!Z!n!p#c#g#j#m$Y$[$^$a$u%[%a%k%m%t%y%{&V&o'O'P'W'Z'b'i'l'}(O(R(T(U(a(i(o(u(x)i)x*P*R*[*f*j*t+O+R+S+V+]+`+b+e+f+i+p+q+t,Q,T,[,x,y,|-W-X-Y-[-]-`-d-f-h-j-k-r.Z.].d.g/a/b0W1f1g1hQ$QuW%e!t!x1a1kQ%f!uQ%g!vQ%i!yQ%s1`S(X%h1eQ(Z1bQ([1cQ-a+^Q.l-bS/d.j0pR1m1oU$Uv/f1nR)f&q[hOs#v$w*`,pa!}Y#c#g#j#m$^$a+tQ#][Q$ZwR$d}Q%o#OQ%v#SQ%|#WQ'{%YQ(h%rQ(l%wQ(t%}Q(w&OQ+h(qQ-V*|Q.k-aQ/h.lR0Y/gQ$cyQ(d%pR+_(eQ/g.jR0z0pR#VZR#[[R%_!nQ%]!nV*}(O+O-W!]!qQ!s#r$P$b$q$}%S%T%U%V%W%X%r%w%}&O&t'a'x)`)k*U+Z+d,h-g0n1dR%b!pQ&W#cQ&Z#gQ&]#jQ&_#mR-l+tQ)O&WQ)S&ZQ)W&]Q)[&_S+x)P)QS+z)T)US+|)X)YS,O)])^Q-n+yQ-o+{Q-p+}Q-q,PQ.o-lS/i.p.qR0Z/jQ$m!SQ&{$aQ*Z'bR,l*[Q#zmQ$f!PQ$i!QR'T$hQ)p'SR,Y)sQ)p'SQ,X)rR,Y)sR$k!RR)}'YXqOs*`,pQ$s!WR'c$tQ$z!ZR'd$uR*s'pQ*q'pV.^-P._/OQ/_.cQ/|/XR/}/YU/W.c/X/YQ0R/[Q0_/qQ0d/wU0f/y0g0vQ0k0OQ0y0lQ0{0qU0}0r1P1XQ1Y1RQ1^1WR1_1ZR0Q/ZR0a/q",
  nodeNames: "⚠ print { { { { Comment Script AssignStatement * BinaryExpression BitOp BitOp BitOp BitOp ArithOp ArithOp @ ArithOp ** UnaryExpression ArithOp BitOp AwaitExpression await ) ( ParenthesizedExpression BinaryExpression or and CompareOp in not is UnaryExpression ConditionalExpression if else LambdaExpression lambda ParamList VariableName AssignOp , : NamedExpression AssignOp YieldExpression yield from TupleExpression ComprehensionExpression async for LambdaExpression ] [ ArrayExpression ArrayComprehensionExpression } { DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression CallExpression ArgList AssignOp MemberExpression . PropertyName Number String FormatString FormatReplacement FormatSelfDoc FormatConversion FormatSpec FormatReplacement FormatSelfDoc FormatReplacement FormatSelfDoc FormatReplacement FormatSelfDoc FormatReplacement FormatSelfDoc ContinuedString Ellipsis None Boolean TypeDef AssignOp UpdateStatement UpdateOp ExpressionStatement DeleteStatement del PassStatement pass BreakStatement break ContinueStatement continue ReturnStatement return YieldStatement PrintStatement RaiseStatement raise ImportStatement import as ScopeStatement global nonlocal AssertStatement assert TypeDefinition type TypeParamList TypeParam StatementGroup ; IfStatement Body elif WhileStatement while ForStatement TryStatement try except finally WithStatement with FunctionDefinition def ParamList AssignOp TypeDef ClassDefinition class DecoratedStatement Decorator At MatchStatement match MatchBody MatchClause case CapturePattern LiteralPattern ArithOp ArithOp AsPattern OrPattern LogicOp AttributePattern SequencePattern MappingPattern StarPattern ClassPattern PatternArgList KeywordPattern KeywordPattern Guard",
  maxTerm: 288,
  context: kC,
  nodeProps: [
    ["isolate", -8, 6, 73, 74, 75, 79, 81, 83, 85, ""],
    ["group", -15, 8, 93, 95, 96, 98, 100, 102, 104, 106, 107, 108, 110, 113, 116, 118, "Statement Statement", -22, 10, 20, 23, 27, 42, 51, 52, 58, 59, 62, 63, 64, 65, 66, 69, 72, 73, 74, 87, 88, 89, 90, "Expression", -10, 122, 124, 127, 129, 130, 134, 136, 141, 143, 146, "Statement", -9, 151, 152, 155, 156, 158, 159, 160, 161, 162, "Pattern"],
    ["openedBy", 25, "(", 56, "[", 60, "{"],
    ["closedBy", 26, ")", 57, "]", 61, "}"]
  ],
  propSources: [XC],
  skippedNodes: [0, 6],
  repeatNodeCount: 38,
  tokenData: "%-W#sR!`OX%TXY=|Y[%T[]=|]p%Tpq=|qr@_rsDOst!+|tu%Tuv!Nnvw#!|wx#$Wxy#:Uyz#;Yz{#<^{|#>x|}#@S}!O#AW!O!P#Ci!P!Q#N_!Q!R$!y!R![$&w![!]$1e!]!^$3s!^!_$4w!_!`$7c!`!a$8m!a!b%T!b!c$;U!c!d$<b!d!e$>W!e!h$<b!h!i$H[!i!t$<b!t!u%#r!u!w$<b!w!x$Fl!x!}$<b!}#O%%z#O#P?d#P#Q%'O#Q#R%(S#R#S$<b#S#T%T#T#U$<b#U#V$>W#V#Y$<b#Y#Z$H[#Z#f$<b#f#g%#r#g#i$<b#i#j$Fl#j#o$<b#o#p%)^#p#q%*S#q#r%+^#r#s%,S#s$g%T$g;'S$<b;'S;=`$>Q<%lO$<b!n%^]&w!b&oS&rWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!n&^]&w!b&oSOr%Trs'Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!n'^]&w!b&oSOr%Trs(Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!f(^Z&w!b&oSOw(Vwx)Px#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V!f)UZ&w!bOw(Vwx)wx#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V!f)|Z&w!bOw(Vwx*ox#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V!b*tT&w!bO#o*o#p#q*o#r;'S*o;'S;=`+T<%lO*o!b+WP;=`<%l*o!f+`W&w!bO#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`.d;=`<%l+x<%lO(VS+}V&oSOw+xwx,dx#O+x#O#P-c#P;'S+x;'S;=`.^<%lO+xS,gVOw+xwx,|x#O+x#O#P-c#P;'S+x;'S;=`.^<%lO+xS-PUOw+xx#O+x#O#P-c#P;'S+x;'S;=`.^<%lO+xS-fRO;'S+x;'S;=`-o;=`O+xS-tW&oSOw+xwx,dx#O+x#O#P-c#P;'S+x;'S;=`.^;=`<%l+x<%lO+xS.aP;=`<%l+x!f.iW&oSOw+xwx,dx#O+x#O#P-c#P;'S+x;'S;=`.^;=`<%l(V<%lO+x!f/UP;=`<%l(V!n/`]&w!b&rWOr%Trs&Vsw%Twx0Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!n0`]&w!b&rWOr%Trs&Vsw%Twx1Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!j1`Z&w!b&rWOr1Xrs2Rs#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X!j2WZ&w!bOr1Xrs2ys#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X!j3OZ&w!bOr1Xrs*os#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X!j3vW&w!bO#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`6z;=`<%l4`<%lO1XW4eV&rWOr4`rs4zs#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`W4}VOr4`rs5ds#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`W5gUOr4`s#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`W5|RO;'S4`;'S;=`6V;=`O4`W6[W&rWOr4`rs4zs#O4`#O#P5y#P;'S4`;'S;=`6t;=`<%l4`<%lO4`W6wP;=`<%l4`!j7PW&rWOr4`rs4zs#O4`#O#P5y#P;'S4`;'S;=`6t;=`<%l1X<%lO4`!j7lP;=`<%l1X!n7tW&w!bO#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=P;=`<%l8^<%lO%T[8eX&oS&rWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^[9VX&oSOr8^rs9rsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^[9wX&oSOr8^rs+xsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^[:iX&rWOr8^rs9Qsw8^wx;Ux#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^[;ZX&rWOr8^rs9Qsw8^wx4`x#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^[;yRO;'S8^;'S;=`<S;=`O8^[<ZY&oS&rWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y;=`<%l8^<%lO8^[<|P;=`<%l8^!n=WY&oS&rWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y;=`<%l%T<%lO8^!n=yP;=`<%l%T#s>Xc&w!b&oS&rW%u!TOX%TXY=|Y[%T[]=|]p%Tpq=|qr%Trs&Vsw%Twx/Xx#O%T#O#P?d#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#s?i[&w!bOY%TYZ=|Z]%T]^=|^#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=P;=`<%l8^<%lO%T!q@hd&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!_%T!_!`Av!`#O%T#O#P7o#P#T%T#T#UBz#U#f%T#f#gBz#g#hBz#h#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!qBR]oR&w!b&oS&rWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!qCV]!oR&w!b&oS&rWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#cDXa&w!b&oS&msOYE^YZ%TZ]E^]^%T^rE^rs!)|swE^wxGpx#OE^#O#P!!u#P#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!)v<%lOE^#cEia&w!b&oS&rW&msOYE^YZ%TZ]E^]^%T^rE^rsFnswE^wxGpx#OE^#O#P!!u#P#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!)v<%lOE^#cFw]&w!b&oS&msOr%Trs'Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#cGya&w!b&rW&msOYE^YZ%TZ]E^]^%T^rE^rsFnswE^wxIOx#OE^#O#P!!u#P#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!)v<%lOE^#cIXa&w!b&rW&msOYE^YZ%TZ]E^]^%T^rE^rsFnswE^wxJ^x#OE^#O#P!!u#P#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!)v<%lOE^#_Jg_&w!b&rW&msOYJ^YZ1XZ]J^]^1X^rJ^rsKfs#OJ^#O#PL`#P#oJ^#o#pL}#p#qJ^#q#rL}#r;'SJ^;'S;=`!!o<%lOJ^#_KmZ&w!b&msOr1Xrs2ys#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X#_LeW&w!bO#oJ^#o#pL}#p#qJ^#q#rL}#r;'SJ^;'S;=`! r;=`<%lL}<%lOJ^{MUZ&rW&msOYL}YZ4`Z]L}]^4`^rL}rsMws#OL}#O#PNc#P;'SL};'S;=`! l<%lOL}{M|V&msOr4`rs5ds#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`{NfRO;'SL};'S;=`No;=`OL}{Nv[&rW&msOYL}YZ4`Z]L}]^4`^rL}rsMws#OL}#O#PNc#P;'SL};'S;=`! l;=`<%lL}<%lOL}{! oP;=`<%lL}#_! y[&rW&msOYL}YZ4`Z]L}]^4`^rL}rsMws#OL}#O#PNc#P;'SL};'S;=`! l;=`<%lJ^<%lOL}#_!!rP;=`<%lJ^#c!!zW&w!bO#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!(q;=`<%l!#d<%lOE^!P!#m]&oS&rW&msOY!#dYZ8^Z]!#d]^8^^r!#drs!$fsw!#dwx!%Yx#O!#d#O#P!'Y#P;'S!#d;'S;=`!(k<%lO!#d!P!$mX&oS&msOr8^rs9rsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^!P!%a]&rW&msOY!#dYZ8^Z]!#d]^8^^r!#drs!$fsw!#dwx!&Yx#O!#d#O#P!'Y#P;'S!#d;'S;=`!(k<%lO!#d!P!&a]&rW&msOY!#dYZ8^Z]!#d]^8^^r!#drs!$fsw!#dwxL}x#O!#d#O#P!'Y#P;'S!#d;'S;=`!(k<%lO!#d!P!']RO;'S!#d;'S;=`!'f;=`O!#d!P!'o^&oS&rW&msOY!#dYZ8^Z]!#d]^8^^r!#drs!$fsw!#dwx!%Yx#O!#d#O#P!'Y#P;'S!#d;'S;=`!(k;=`<%l!#d<%lO!#d!P!(nP;=`<%l!#d#c!(z^&oS&rW&msOY!#dYZ8^Z]!#d]^8^^r!#drs!$fsw!#dwx!%Yx#O!#d#O#P!'Y#P;'S!#d;'S;=`!(k;=`<%lE^<%lO!#d#c!)yP;=`<%lE^#c!*V]&w!b&oS&msOr%Trs!+Osw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c!+ZZ&sW&w!b&oS&qsOw(Vwx)Px#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V#s!,XaU!T&w!b&oS&rWOY!+|YZ%TZ]!+|]^%T^r!+|rs!-^sw!+|wx!:hx#O!+|#O#P!FW#P#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Nh<%lO!+|#s!-gaU!T&w!b&oSOY!+|YZ%TZ]!+|]^%T^r!+|rs!.lsw!+|wx!:hx#O!+|#O#P!FW#P#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Nh<%lO!+|#s!.uaU!T&w!b&oSOY!+|YZ%TZ]!+|]^%T^r!+|rs!/zsw!+|wx!:hx#O!+|#O#P!FW#P#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Nh<%lO!+|#k!0T_U!T&w!b&oSOY!/zYZ(VZ]!/z]^(V^w!/zwx!1Sx#O!/z#O#P!4z#P#o!/z#o#p!5w#p#q!/z#q#r!5w#r;'S!/z;'S;=`!:b<%lO!/z#k!1Z_U!T&w!bOY!/zYZ(VZ]!/z]^(V^w!/zwx!2Yx#O!/z#O#P!4z#P#o!/z#o#p!5w#p#q!/z#q#r!5w#r;'S!/z;'S;=`!:b<%lO!/z#k!2a_U!T&w!bOY!/zYZ(VZ]!/z]^(V^w!/zwx!3`x#O!/z#O#P!4z#P#o!/z#o#p!5w#p#q!/z#q#r!5w#r;'S!/z;'S;=`!:b<%lO!/z#g!3gZU!T&w!bOY!3`YZ*oZ]!3`]^*o^#o!3`#o#p!4Y#p#q!3`#q#r!4Y#r;'S!3`;'S;=`!4t<%lO!3`!T!4_TU!TOY!4YZ]!4Y^;'S!4Y;'S;=`!4n<%lO!4Y!T!4qP;=`<%l!4Y#g!4wP;=`<%l!3`#k!5R[U!T&w!bOY!/zYZ(VZ]!/z]^(V^#o!/z#o#p!5w#p#q!/z#q#r!5w#r;'S!/z;'S;=`!9s;=`<%l+x<%lO!/z!X!6OZU!T&oSOY!5wYZ+xZ]!5w]^+x^w!5wwx!6qx#O!5w#O#P!8a#P;'S!5w;'S;=`!9m<%lO!5w!X!6vZU!TOY!5wYZ+xZ]!5w]^+x^w!5wwx!7ix#O!5w#O#P!8a#P;'S!5w;'S;=`!9m<%lO!5w!X!7nZU!TOY!5wYZ+xZ]!5w]^+x^w!5wwx!4Yx#O!5w#O#P!8a#P;'S!5w;'S;=`!9m<%lO!5w!X!8fWU!TOY!5wYZ+xZ]!5w]^+x^;'S!5w;'S;=`!9O;=`<%l+x<%lO!5w!X!9TW&oSOw+xwx,dx#O+x#O#P-c#P;'S+x;'S;=`.^;=`<%l!5w<%lO+x!X!9pP;=`<%l!5w#k!9xW&oSOw+xwx,dx#O+x#O#P-c#P;'S+x;'S;=`.^;=`<%l!/z<%lO+x#k!:eP;=`<%l!/z#s!:qaU!T&w!b&rWOY!+|YZ%TZ]!+|]^%T^r!+|rs!-^sw!+|wx!;vx#O!+|#O#P!FW#P#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Nh<%lO!+|#s!<PaU!T&w!b&rWOY!+|YZ%TZ]!+|]^%T^r!+|rs!-^sw!+|wx!=Ux#O!+|#O#P!FW#P#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Nh<%lO!+|#o!=__U!T&w!b&rWOY!=UYZ1XZ]!=U]^1X^r!=Urs!>^s#O!=U#O#P!@j#P#o!=U#o#p!Ag#p#q!=U#q#r!Ag#r;'S!=U;'S;=`!FQ<%lO!=U#o!>e_U!T&w!bOY!=UYZ1XZ]!=U]^1X^r!=Urs!?ds#O!=U#O#P!@j#P#o!=U#o#p!Ag#p#q!=U#q#r!Ag#r;'S!=U;'S;=`!FQ<%lO!=U#o!?k_U!T&w!bOY!=UYZ1XZ]!=U]^1X^r!=Urs!3`s#O!=U#O#P!@j#P#o!=U#o#p!Ag#p#q!=U#q#r!Ag#r;'S!=U;'S;=`!FQ<%lO!=U#o!@q[U!T&w!bOY!=UYZ1XZ]!=U]^1X^#o!=U#o#p!Ag#p#q!=U#q#r!Ag#r;'S!=U;'S;=`!Ec;=`<%l4`<%lO!=U!]!AnZU!T&rWOY!AgYZ4`Z]!Ag]^4`^r!Agrs!Bas#O!Ag#O#P!DP#P;'S!Ag;'S;=`!E]<%lO!Ag!]!BfZU!TOY!AgYZ4`Z]!Ag]^4`^r!Agrs!CXs#O!Ag#O#P!DP#P;'S!Ag;'S;=`!E]<%lO!Ag!]!C^ZU!TOY!AgYZ4`Z]!Ag]^4`^r!Agrs!4Ys#O!Ag#O#P!DP#P;'S!Ag;'S;=`!E]<%lO!Ag!]!DUWU!TOY!AgYZ4`Z]!Ag]^4`^;'S!Ag;'S;=`!Dn;=`<%l4`<%lO!Ag!]!DsW&rWOr4`rs4zs#O4`#O#P5y#P;'S4`;'S;=`6t;=`<%l!Ag<%lO4`!]!E`P;=`<%l!Ag#o!EhW&rWOr4`rs4zs#O4`#O#P5y#P;'S4`;'S;=`6t;=`<%l!=U<%lO4`#o!FTP;=`<%l!=U#s!F_[U!T&w!bOY!+|YZ%TZ]!+|]^%T^#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Mq;=`<%l8^<%lO!+|!a!G^]U!T&oS&rWOY!GTYZ8^Z]!GT]^8^^r!GTrs!HVsw!GTwx!JVx#O!GT#O#P!LV#P;'S!GT;'S;=`!Mk<%lO!GT!a!H^]U!T&oSOY!GTYZ8^Z]!GT]^8^^r!GTrs!IVsw!GTwx!JVx#O!GT#O#P!LV#P;'S!GT;'S;=`!Mk<%lO!GT!a!I^]U!T&oSOY!GTYZ8^Z]!GT]^8^^r!GTrs!5wsw!GTwx!JVx#O!GT#O#P!LV#P;'S!GT;'S;=`!Mk<%lO!GT!a!J^]U!T&rWOY!GTYZ8^Z]!GT]^8^^r!GTrs!HVsw!GTwx!KVx#O!GT#O#P!LV#P;'S!GT;'S;=`!Mk<%lO!GT!a!K^]U!T&rWOY!GTYZ8^Z]!GT]^8^^r!GTrs!HVsw!GTwx!Agx#O!GT#O#P!LV#P;'S!GT;'S;=`!Mk<%lO!GT!a!L[WU!TOY!GTYZ8^Z]!GT]^8^^;'S!GT;'S;=`!Lt;=`<%l8^<%lO!GT!a!L{Y&oS&rWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y;=`<%l!GT<%lO8^!a!MnP;=`<%l!GT#s!MxY&oS&rWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y;=`<%l!+|<%lO8^#s!NkP;=`<%l!+|#b!Ny_&UQ&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b#!T]#Qr&w!b&oS&rWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b##X_&OQ&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#$aa&w!b&rW&msOY#%fYZ%TZ]#%f]^%T^r#%frs#&vsw#%fwx#8Ux#O#%f#O#P#0}#P#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#8O<%lO#%f#c#%qa&w!b&oS&rW&msOY#%fYZ%TZ]#%f]^%T^r#%frs#&vsw#%fwx#/{x#O#%f#O#P#0}#P#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#8O<%lO#%f#c#'Pa&w!b&oS&msOY#%fYZ%TZ]#%f]^%T^r#%frs#(Usw#%fwx#/{x#O#%f#O#P#0}#P#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#8O<%lO#%f#c#(_a&w!b&oS&msOY#%fYZ%TZ]#%f]^%T^r#%frs#)dsw#%fwx#/{x#O#%f#O#P#0}#P#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#8O<%lO#%f#Z#)m_&w!b&oS&msOY#)dYZ(VZ]#)d]^(V^w#)dwx#*lx#O#)d#O#P#+f#P#o#)d#o#p#,T#p#q#)d#q#r#,T#r;'S#)d;'S;=`#/u<%lO#)d#Z#*sZ&w!b&msOw(Vwx)wx#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V#Z#+kW&w!bO#o#)d#o#p#,T#p#q#)d#q#r#,T#r;'S#)d;'S;=`#.x;=`<%l#,T<%lO#)dw#,[Z&oS&msOY#,TYZ+xZ]#,T]^+x^w#,Twx#,}x#O#,T#O#P#-i#P;'S#,T;'S;=`#.r<%lO#,Tw#-SV&msOw+xwx,|x#O+x#O#P-c#P;'S+x;'S;=`.^<%lO+xw#-lRO;'S#,T;'S;=`#-u;=`O#,Tw#-|[&oS&msOY#,TYZ+xZ]#,T]^+x^w#,Twx#,}x#O#,T#O#P#-i#P;'S#,T;'S;=`#.r;=`<%l#,T<%lO#,Tw#.uP;=`<%l#,T#Z#/P[&oS&msOY#,TYZ+xZ]#,T]^+x^w#,Twx#,}x#O#,T#O#P#-i#P;'S#,T;'S;=`#.r;=`<%l#)d<%lO#,T#Z#/xP;=`<%l#)d#c#0U]&w!b&rW&msOr%Trs&Vsw%Twx0Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#1SW&w!bO#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#6y;=`<%l#1l<%lO#%f!P#1u]&oS&rW&msOY#1lYZ8^Z]#1l]^8^^r#1lrs#2nsw#1lwx#4nx#O#1l#O#P#5b#P;'S#1l;'S;=`#6s<%lO#1l!P#2u]&oS&msOY#1lYZ8^Z]#1l]^8^^r#1lrs#3nsw#1lwx#4nx#O#1l#O#P#5b#P;'S#1l;'S;=`#6s<%lO#1l!P#3u]&oS&msOY#1lYZ8^Z]#1l]^8^^r#1lrs#,Tsw#1lwx#4nx#O#1l#O#P#5b#P;'S#1l;'S;=`#6s<%lO#1l!P#4uX&rW&msOr8^rs9Qsw8^wx;Ux#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^!P#5eRO;'S#1l;'S;=`#5n;=`O#1l!P#5w^&oS&rW&msOY#1lYZ8^Z]#1l]^8^^r#1lrs#2nsw#1lwx#4nx#O#1l#O#P#5b#P;'S#1l;'S;=`#6s;=`<%l#1l<%lO#1l!P#6vP;=`<%l#1l#c#7S^&oS&rW&msOY#1lYZ8^Z]#1l]^8^^r#1lrs#2nsw#1lwx#4nx#O#1l#O#P#5b#P;'S#1l;'S;=`#6s;=`<%l#%f<%lO#1l#c#8RP;=`<%l#%f#c#8_]&w!b&rW&msOr%Trs&Vsw%Twx#9Wx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#9cZ&pS&w!b&rW&nsOr1Xrs2Rs#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X#c#:a]js&w!b&oS&rWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!q#;e]iR&w!b&oS&rWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#<iaXs&w!b&oS&rWOr%Trs&Vsw%Twx/Xxz%Tz{#=n{!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#=y_cR&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#?T_&Rs&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!q#@_]|R&w!b&oS&rWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#s#Ac`&Ss&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`!a#Be!a#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#O#Bp]'W`&w!b&oS&rWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#Cta!hQ&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!O%T!O!P#Dy!P!Q%T!Q![#GV![#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#ES_&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!O%T!O!P#FR!P#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#F^]!zs&w!b&oS&rWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a#Gbi!jq&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!Q%T!Q![#GV![!g%T!g!h#IP!h!l%T!l!m#MZ!m#O%T#O#P7o#P#R%T#R#S#GV#S#X%T#X#Y#IP#Y#^%T#^#_#MZ#_#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a#IYc&w!b&oS&rWOr%Trs&Vsw%Twx/Xx{%T{|#Je|}%T}!O#Je!O!Q%T!Q![#Km![#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a#Jn_&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!Q%T!Q![#Km![#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a#Kxe!jq&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!Q%T!Q![#Km![!l%T!l!m#MZ!m#O%T#O#P7o#P#R%T#R#S#Km#S#^%T#^#_#MZ#_#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a#Mf]!jq&w!b&oS&rWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#Nja&TR&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!P%T!P!Q$ o!Q!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b$ z_&VQ&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$#Uw!jq&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!O%T!O!P$%o!P!Q%T!Q![$&w![!d%T!d!e$(w!e!g%T!g!h#IP!h!l%T!l!m#MZ!m!q%T!q!r$+m!r!z%T!z!{$.]!{#O%T#O#P7o#P#R%T#R#S$&w#S#U%T#U#V$(w#V#X%T#X#Y#IP#Y#^%T#^#_#MZ#_#c%T#c#d$+m#d#l%T#l#m$.]#m#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$%x_&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!Q%T!Q![#GV![#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$'Sk!jq&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!O%T!O!P$%o!P!Q%T!Q![$&w![!g%T!g!h#IP!h!l%T!l!m#MZ!m#O%T#O#P7o#P#R%T#R#S$&w#S#X%T#X#Y#IP#Y#^%T#^#_#MZ#_#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$)Qb&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!Q%T!Q!R$*Y!R!S$*Y!S#O%T#O#P7o#P#R%T#R#S$*Y#S#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$*eb!jq&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!Q%T!Q!R$*Y!R!S$*Y!S#O%T#O#P7o#P#R%T#R#S$*Y#S#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$+va&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!Q%T!Q!Y$,{!Y#O%T#O#P7o#P#R%T#R#S$,{#S#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$-Wa!jq&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!Q%T!Q!Y$,{!Y#O%T#O#P7o#P#R%T#R#S$,{#S#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$.fe&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!Q%T!Q![$/w![!c%T!c!i$/w!i#O%T#O#P7o#P#R%T#R#S$/w#S#T%T#T#Z$/w#Z#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$0Se!jq&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!Q%T!Q![$/w![!c%T!c!i$/w!i#O%T#O#P7o#P#R%T#R#S$/w#S#T%T#T#Z$/w#Z#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#s$1p_}!T&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!_%T!_!`$2o!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!q$2z]&_R&w!b&oS&rWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$4O]#os&w!b&oS&rWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$5SaoR&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!^%T!^!_$6X!_!`Av!`!aAv!a#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b$6d_&PQ&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$7n_&^s&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!_%T!_!`Av!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$8x`oR&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!_%T!_!`Av!`!a$9z!a#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b$:V_&QQ&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$;c_aQ$VP&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#s$<oe&w!b&oS&rW&l`&XsOr%Trs&Vsw%Twx/Xx!Q%T!Q![$<b![!c%T!c!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#s$>TP;=`<%l$<b#s$>ei&w!b&oS&rW&l`&XsOr%Trs$@Ssw%Twx$C`x!Q%T!Q![$<b![!c%T!c!t$<b!t!u$Fl!u!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#f$<b#f#g$Fl#g#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#c$@]a&w!b&oS&msOYE^YZ%TZ]E^]^%T^rE^rs$AbswE^wxGpx#OE^#O#P!!u#P#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!)v<%lOE^#c$Ak]&w!b&oS&msOr%Trs$Bdsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#Z$BmZ&w!b&oS&qsOw(Vwx)Px#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V#c$Cia&w!b&rW&msOY#%fYZ%TZ]#%f]^%T^r#%frs#&vsw#%fwx$Dnx#O#%f#O#P#0}#P#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#8O<%lO#%f#c$Dw]&w!b&rW&msOr%Trs&Vsw%Twx$Epx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#_$EyZ&w!b&rW&nsOr1Xrs2Rs#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X#s$Fye&w!b&oS&rW&l`&XsOr%Trs$@Ssw%Twx$C`x!Q%T!Q![$<b![!c%T!c!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#s$Hii&w!b&oS&rW&l`&XsOr%Trs$JWsw%Twx$MUx!Q%T!Q![$<b![!c%T!c!t$<b!t!u%!S!u!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#f$<b#f#g%!S#g#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#c$Ja]&w!b&oS&xsOr%Trs$KYsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$Ka]&w!b&oSOr%Trs$LYsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#Z$LcZ&w!b&oS&zsOw(Vwx)Px#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V#c$M_]&w!b&rW&tsOr%Trs&Vsw%Twx$NWx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$N_]&w!b&rWOr%Trs&Vsw%Twx% Wx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#_% aZ&w!b&rW&ysOr1Xrs2Rs#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X#s%!ae&w!b&oS&rW&l`&XsOr%Trs$JWsw%Twx$MUx!Q%T!Q![$<b![!c%T!c!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#s%$Pm&w!b&oS&rW&l`&XsOr%Trs$@Ssw%Twx$C`x!Q%T!Q![$<b![!c%T!c!h$<b!h!i%!S!i!t$<b!t!u$Fl!u!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#U$<b#U#V$Fl#V#Y$<b#Y#Z%!S#Z#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#c%&V]!Zs&w!b&oS&rWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!q%'Z]!YR&w!b&oS&rWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b%(__%}Q&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a%)gX!_#T&oS&rWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^#c%*__%|R&w!b&oS&rWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!q%+gX!^!e&oS&rWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^#a%,_]&Wq&w!b&oS&rWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T",
  tokenizers: [$C, vC, yC, QC, PC, TC, CC, 0, 1, 2, 3, 4, 5, 6],
  topRules: { Script: [0, 7] },
  specialized: [{ term: 239, get: (r) => ZC[r] || -1 }],
  tokenPrec: 7500
}), Cf = /* @__PURE__ */ new $c(), j1 = /* @__PURE__ */ new Set([
  "Script",
  "Body",
  "FunctionDefinition",
  "ClassDefinition",
  "LambdaExpression",
  "ForStatement",
  "MatchClause"
]);
function so(r) {
  return (e, t, i) => {
    if (i)
      return !1;
    let n = e.node.getChild("VariableName");
    return n && t(n, r), !0;
  };
}
const RC = {
  FunctionDefinition: /* @__PURE__ */ so("function"),
  ClassDefinition: /* @__PURE__ */ so("class"),
  ForStatement(r, e, t) {
    if (t) {
      for (let i = r.node.firstChild; i; i = i.nextSibling)
        if (i.name == "VariableName")
          e(i, "variable");
        else if (i.name == "in")
          break;
    }
  },
  ImportStatement(r, e) {
    var t, i;
    let { node: n } = r, s = ((t = n.firstChild) === null || t === void 0 ? void 0 : t.name) == "from";
    for (let o = n.getChild("import"); o; o = o.nextSibling)
      o.name == "VariableName" && ((i = o.nextSibling) === null || i === void 0 ? void 0 : i.name) != "as" && e(o, s ? "variable" : "namespace");
  },
  AssignStatement(r, e) {
    for (let t = r.node.firstChild; t; t = t.nextSibling)
      if (t.name == "VariableName")
        e(t, "variable");
      else if (t.name == ":" || t.name == "AssignOp")
        break;
  },
  ParamList(r, e) {
    for (let t = null, i = r.node.firstChild; i; i = i.nextSibling)
      i.name == "VariableName" && (!t || !/\*|AssignOp/.test(t.name)) && e(i, "variable"), t = i;
  },
  CapturePattern: /* @__PURE__ */ so("variable"),
  AsPattern: /* @__PURE__ */ so("variable"),
  __proto__: null
};
function L1(r, e) {
  let t = Cf.get(e);
  if (t)
    return t;
  let i = [], n = !0;
  function s(o, l) {
    let a = r.sliceString(o.from, o.to);
    i.push({ label: a, type: l });
  }
  return e.cursor(ne.IncludeAnonymous).iterate((o) => {
    if (o.name) {
      let l = RC[o.name];
      if (l && l(o, s, n) || !n && j1.has(o.name))
        return !1;
      n = !1;
    } else if (o.to - o.from > 8192) {
      for (let l of L1(r, o.node))
        i.push(l);
      return !1;
    }
  }), Cf.set(e, i), i;
}
const Xf = /^[\w\xa1-\uffff][\w\d\xa1-\uffff]*$/, B1 = ["String", "FormatString", "Comment", "PropertyName"];
function AC(r) {
  let e = te(r.state).resolveInner(r.pos, -1);
  if (B1.indexOf(e.name) > -1)
    return null;
  let t = e.name == "VariableName" || e.to - e.from < 20 && Xf.test(r.state.sliceDoc(e.from, e.to));
  if (!t && !r.explicit)
    return null;
  let i = [];
  for (let n = e; n; n = n.parent)
    j1.has(n.name) && (i = i.concat(L1(r.state.doc, n)));
  return {
    options: i,
    from: t ? e.from : r.pos,
    validFor: Xf
  };
}
const EC = /* @__PURE__ */ [
  "__annotations__",
  "__builtins__",
  "__debug__",
  "__doc__",
  "__import__",
  "__name__",
  "__loader__",
  "__package__",
  "__spec__",
  "False",
  "None",
  "True"
].map((r) => ({ label: r, type: "constant" })).concat(/* @__PURE__ */ [
  "ArithmeticError",
  "AssertionError",
  "AttributeError",
  "BaseException",
  "BlockingIOError",
  "BrokenPipeError",
  "BufferError",
  "BytesWarning",
  "ChildProcessError",
  "ConnectionAbortedError",
  "ConnectionError",
  "ConnectionRefusedError",
  "ConnectionResetError",
  "DeprecationWarning",
  "EOFError",
  "Ellipsis",
  "EncodingWarning",
  "EnvironmentError",
  "Exception",
  "FileExistsError",
  "FileNotFoundError",
  "FloatingPointError",
  "FutureWarning",
  "GeneratorExit",
  "IOError",
  "ImportError",
  "ImportWarning",
  "IndentationError",
  "IndexError",
  "InterruptedError",
  "IsADirectoryError",
  "KeyError",
  "KeyboardInterrupt",
  "LookupError",
  "MemoryError",
  "ModuleNotFoundError",
  "NameError",
  "NotADirectoryError",
  "NotImplemented",
  "NotImplementedError",
  "OSError",
  "OverflowError",
  "PendingDeprecationWarning",
  "PermissionError",
  "ProcessLookupError",
  "RecursionError",
  "ReferenceError",
  "ResourceWarning",
  "RuntimeError",
  "RuntimeWarning",
  "StopAsyncIteration",
  "StopIteration",
  "SyntaxError",
  "SyntaxWarning",
  "SystemError",
  "SystemExit",
  "TabError",
  "TimeoutError",
  "TypeError",
  "UnboundLocalError",
  "UnicodeDecodeError",
  "UnicodeEncodeError",
  "UnicodeError",
  "UnicodeTranslateError",
  "UnicodeWarning",
  "UserWarning",
  "ValueError",
  "Warning",
  "ZeroDivisionError"
].map((r) => ({ label: r, type: "type" }))).concat(/* @__PURE__ */ [
  "bool",
  "bytearray",
  "bytes",
  "classmethod",
  "complex",
  "float",
  "frozenset",
  "int",
  "list",
  "map",
  "memoryview",
  "object",
  "range",
  "set",
  "staticmethod",
  "str",
  "super",
  "tuple",
  "type"
].map((r) => ({ label: r, type: "class" }))).concat(/* @__PURE__ */ [
  "abs",
  "aiter",
  "all",
  "anext",
  "any",
  "ascii",
  "bin",
  "breakpoint",
  "callable",
  "chr",
  "compile",
  "delattr",
  "dict",
  "dir",
  "divmod",
  "enumerate",
  "eval",
  "exec",
  "exit",
  "filter",
  "format",
  "getattr",
  "globals",
  "hasattr",
  "hash",
  "help",
  "hex",
  "id",
  "input",
  "isinstance",
  "issubclass",
  "iter",
  "len",
  "license",
  "locals",
  "max",
  "min",
  "next",
  "oct",
  "open",
  "ord",
  "pow",
  "print",
  "property",
  "quit",
  "repr",
  "reversed",
  "round",
  "setattr",
  "slice",
  "sorted",
  "sum",
  "vars",
  "zip"
].map((r) => ({ label: r, type: "function" }))), qC = [
  /* @__PURE__ */ Oe("def ${name}(${params}):\n	${}", {
    label: "def",
    detail: "function",
    type: "keyword"
  }),
  /* @__PURE__ */ Oe("for ${name} in ${collection}:\n	${}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Oe("while ${}:\n	${}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Oe("try:\n	${}\nexcept ${error}:\n	${}", {
    label: "try",
    detail: "/ except block",
    type: "keyword"
  }),
  /* @__PURE__ */ Oe(`if \${}:
	
`, {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ Oe("if ${}:\n	${}\nelse:\n	${}", {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ Oe("class ${name}:\n	def __init__(self, ${params}):\n			${}", {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Oe("import ${module}", {
    label: "import",
    detail: "statement",
    type: "keyword"
  }),
  /* @__PURE__ */ Oe("from ${module} import ${names}", {
    label: "from",
    detail: "import",
    type: "keyword"
  })
], zC = /* @__PURE__ */ Dc(B1, /* @__PURE__ */ $l(/* @__PURE__ */ EC.concat(qC)));
function Zf(r, e) {
  let t = r.baseIndentFor(e), i = r.lineAt(r.pos, -1), n = i.from + i.text.length;
  return /^\s*($|#)/.test(i.text) && r.node.to < n + 100 && !/\S/.test(r.state.sliceDoc(n, r.node.to)) && r.lineIndent(r.pos, -1) <= t || /^\s*(else:|elif |except |finally:)/.test(r.textAfter) && r.lineIndent(r.pos, -1) > t ? null : t + r.unit;
}
const Xa = /* @__PURE__ */ Nt.define({
  name: "python",
  parser: /* @__PURE__ */ _C.configure({
    props: [
      /* @__PURE__ */ Br.add({
        Body: (r) => {
          var e;
          return (e = Zf(r, r.node)) !== null && e !== void 0 ? e : r.continue();
        },
        IfStatement: (r) => /^\s*(else:|elif )/.test(r.textAfter) ? r.baseIndent : r.continue(),
        TryStatement: (r) => /^\s*(except |finally:|else:)/.test(r.textAfter) ? r.baseIndent : r.continue(),
        "TupleExpression ComprehensionExpression ParamList ArgList ParenthesizedExpression": /* @__PURE__ */ wo({ closing: ")" }),
        "DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression": /* @__PURE__ */ wo({ closing: "}" }),
        "ArrayExpression ArrayComprehensionExpression": /* @__PURE__ */ wo({ closing: "]" }),
        "String FormatString": () => null,
        Script: (r) => {
          if (r.pos + /\s*/.exec(r.textAfter)[0].length >= r.node.to) {
            let e = null;
            for (let t = r.node, i = t.to; t = t.lastChild, !(!t || t.to != i); )
              t.type.name == "Body" && (e = t);
            if (e) {
              let t = Zf(r, e);
              if (t != null)
                return t;
            }
          }
          return r.continue();
        }
      }),
      /* @__PURE__ */ fr.add({
        "ArrayExpression DictionaryExpression SetExpression TupleExpression": wl,
        Body: (r, e) => ({ from: r.from + 1, to: r.to - (r.to == e.doc.length ? 0 : 1) })
      })
    ]
  }),
  languageData: {
    closeBrackets: {
      brackets: ["(", "[", "{", "'", '"', "'''", '"""'],
      stringPrefixes: [
        "f",
        "fr",
        "rf",
        "r",
        "u",
        "b",
        "br",
        "rb",
        "F",
        "FR",
        "RF",
        "R",
        "U",
        "B",
        "BR",
        "RB"
      ]
    },
    commentTokens: { line: "#" },
    indentOnInput: /^\s*([\}\]\)]|else:|elif |except |finally:)$/
  }
});
function YC() {
  return new cr(Xa, [
    Xa.data.of({ autocomplete: AC }),
    Xa.data.of({ autocomplete: zC })
  ]);
}
const WC = 36, _f = 1, VC = 2, Sn = 3, Za = 4, MC = 5, jC = 6, LC = 7, BC = 8, DC = 9, IC = 10, UC = 11, GC = 12, NC = 13, FC = 14, HC = 15, KC = 16, JC = 17, Rf = 18, eX = 19, D1 = 20, I1 = 21, Af = 22, tX = 23, rX = 24;
function Nh(r) {
  return r >= 65 && r <= 90 || r >= 97 && r <= 122 || r >= 48 && r <= 57;
}
function iX(r) {
  return r >= 48 && r <= 57 || r >= 97 && r <= 102 || r >= 65 && r <= 70;
}
function Kr(r, e, t) {
  for (let i = !1; ; ) {
    if (r.next < 0)
      return;
    if (r.next == e && !i) {
      r.advance();
      return;
    }
    i = t && !i && r.next == 92, r.advance();
  }
}
function nX(r) {
  for (; ; ) {
    if (r.next < 0 || r.peek(1) < 0)
      return;
    if (r.next == 36 && r.peek(1) == 36) {
      r.advance(2);
      return;
    }
    r.advance();
  }
}
function sX(r, e) {
  let t = "[{<(".indexOf(String.fromCharCode(e)), i = t < 0 ? e : "]}>)".charCodeAt(t);
  for (; ; ) {
    if (r.next < 0)
      return;
    if (r.next == i && r.peek(1) == 39) {
      r.advance(2);
      return;
    }
    r.advance();
  }
}
function U1(r, e) {
  for (; !(r.next != 95 && !Nh(r.next)); )
    e != null && (e += String.fromCharCode(r.next)), r.advance();
  return e;
}
function oX(r) {
  if (r.next == 39 || r.next == 34 || r.next == 96) {
    let e = r.next;
    r.advance(), Kr(r, e, !1);
  } else
    U1(r);
}
function Ef(r, e) {
  for (; r.next == 48 || r.next == 49; )
    r.advance();
  e && r.next == e && r.advance();
}
function qf(r, e) {
  for (; ; ) {
    if (r.next == 46) {
      if (e)
        break;
      e = !0;
    } else if (r.next < 48 || r.next > 57)
      break;
    r.advance();
  }
  if (r.next == 69 || r.next == 101)
    for (r.advance(), (r.next == 43 || r.next == 45) && r.advance(); r.next >= 48 && r.next <= 57; )
      r.advance();
}
function zf(r) {
  for (; !(r.next < 0 || r.next == 10); )
    r.advance();
}
function Hr(r, e) {
  for (let t = 0; t < e.length; t++)
    if (e.charCodeAt(t) == r)
      return !0;
  return !1;
}
const _a = ` 	\r
`;
function G1(r, e, t) {
  let i = /* @__PURE__ */ Object.create(null);
  i.true = i.false = MC, i.null = i.unknown = jC;
  for (let n of r.split(" "))
    n && (i[n] = D1);
  for (let n of e.split(" "))
    n && (i[n] = I1);
  for (let n of (t || "").split(" "))
    n && (i[n] = rX);
  return i;
}
const lX = "array binary bit boolean char character clob date decimal double float int integer interval large national nchar nclob numeric object precision real smallint time timestamp varchar varying ", aX = "absolute action add after all allocate alter and any are as asc assertion at authorization before begin between both breadth by call cascade cascaded case cast catalog check close collate collation column commit condition connect connection constraint constraints constructor continue corresponding count create cross cube current current_date current_default_transform_group current_transform_group_for_type current_path current_role current_time current_timestamp current_user cursor cycle data day deallocate declare default deferrable deferred delete depth deref desc describe descriptor deterministic diagnostics disconnect distinct do domain drop dynamic each else elseif end end-exec equals escape except exception exec execute exists exit external fetch first for foreign found from free full function general get global go goto grant group grouping handle having hold hour identity if immediate in indicator initially inner inout input insert intersect into is isolation join key language last lateral leading leave left level like limit local localtime localtimestamp locator loop map match method minute modifies module month names natural nesting new next no none not of old on only open option or order ordinality out outer output overlaps pad parameter partial path prepare preserve primary prior privileges procedure public read reads recursive redo ref references referencing relative release repeat resignal restrict result return returns revoke right role rollback rollup routine row rows savepoint schema scroll search second section select session session_user set sets signal similar size some space specific specifictype sql sqlexception sqlstate sqlwarning start state static system_user table temporary then timezone_hour timezone_minute to trailing transaction translation treat trigger under undo union unique unnest until update usage user using value values view when whenever where while with without work write year zone ", Fh = {
  backslashEscapes: !1,
  hashComments: !1,
  spaceAfterDashes: !1,
  slashComments: !1,
  doubleQuotedStrings: !1,
  doubleDollarQuotedStrings: !1,
  unquotedBitLiterals: !1,
  treatBitsAsBytes: !1,
  charSetCasts: !1,
  plsqlQuotingMechanism: !1,
  operatorChars: "*+-%<>!=&|~^/",
  specialVar: "?",
  identifierQuotes: '"',
  words: /* @__PURE__ */ G1(aX, lX)
};
function hX(r, e, t, i) {
  let n = {};
  for (let s in Fh)
    n[s] = (r.hasOwnProperty(s) ? r : Fh)[s];
  return e && (n.words = G1(e, t || "", i)), n;
}
function N1(r) {
  return new Ae((e) => {
    var t;
    let { next: i } = e;
    if (e.advance(), Hr(i, _a)) {
      for (; Hr(e.next, _a); )
        e.advance();
      e.acceptToken(WC);
    } else if (i == 36 && e.next == 36 && r.doubleDollarQuotedStrings)
      nX(e), e.acceptToken(Sn);
    else if (i == 39 || i == 34 && r.doubleQuotedStrings)
      Kr(e, i, r.backslashEscapes), e.acceptToken(Sn);
    else if (i == 35 && r.hashComments || i == 47 && e.next == 47 && r.slashComments)
      zf(e), e.acceptToken(_f);
    else if (i == 45 && e.next == 45 && (!r.spaceAfterDashes || e.peek(1) == 32))
      zf(e), e.acceptToken(_f);
    else if (i == 47 && e.next == 42) {
      e.advance();
      for (let n = 1; ; ) {
        let s = e.next;
        if (e.next < 0)
          break;
        if (e.advance(), s == 42 && e.next == 47) {
          if (n--, e.advance(), !n)
            break;
        } else
          s == 47 && e.next == 42 && (n++, e.advance());
      }
      e.acceptToken(VC);
    } else if ((i == 101 || i == 69) && e.next == 39)
      e.advance(), Kr(e, 39, !0);
    else if ((i == 110 || i == 78) && e.next == 39 && r.charSetCasts)
      e.advance(), Kr(e, 39, r.backslashEscapes), e.acceptToken(Sn);
    else if (i == 95 && r.charSetCasts)
      for (let n = 0; ; n++) {
        if (e.next == 39 && n > 1) {
          e.advance(), Kr(e, 39, r.backslashEscapes), e.acceptToken(Sn);
          break;
        }
        if (!Nh(e.next))
          break;
        e.advance();
      }
    else if (r.plsqlQuotingMechanism && (i == 113 || i == 81) && e.next == 39 && e.peek(1) > 0 && !Hr(e.peek(1), _a)) {
      let n = e.peek(1);
      e.advance(2), sX(e, n), e.acceptToken(Sn);
    } else if (i == 40)
      e.acceptToken(LC);
    else if (i == 41)
      e.acceptToken(BC);
    else if (i == 123)
      e.acceptToken(DC);
    else if (i == 125)
      e.acceptToken(IC);
    else if (i == 91)
      e.acceptToken(UC);
    else if (i == 93)
      e.acceptToken(GC);
    else if (i == 59)
      e.acceptToken(NC);
    else if (r.unquotedBitLiterals && i == 48 && e.next == 98)
      e.advance(), Ef(e), e.acceptToken(Af);
    else if ((i == 98 || i == 66) && (e.next == 39 || e.next == 34)) {
      const n = e.next;
      e.advance(), r.treatBitsAsBytes ? (Kr(e, n, r.backslashEscapes), e.acceptToken(tX)) : (Ef(e, n), e.acceptToken(Af));
    } else if (i == 48 && (e.next == 120 || e.next == 88) || (i == 120 || i == 88) && e.next == 39) {
      let n = e.next == 39;
      for (e.advance(); iX(e.next); )
        e.advance();
      n && e.next == 39 && e.advance(), e.acceptToken(Za);
    } else if (i == 46 && e.next >= 48 && e.next <= 57)
      qf(e, !0), e.acceptToken(Za);
    else if (i == 46)
      e.acceptToken(FC);
    else if (i >= 48 && i <= 57)
      qf(e, !1), e.acceptToken(Za);
    else if (Hr(i, r.operatorChars)) {
      for (; Hr(e.next, r.operatorChars); )
        e.advance();
      e.acceptToken(HC);
    } else if (Hr(i, r.specialVar))
      e.next == i && e.advance(), oX(e), e.acceptToken(JC);
    else if (Hr(i, r.identifierQuotes))
      Kr(e, i, !1), e.acceptToken(eX);
    else if (i == 58 || i == 44)
      e.acceptToken(KC);
    else if (Nh(i)) {
      let n = U1(e, String.fromCharCode(i));
      e.acceptToken(e.next == 46 ? Rf : (t = r.words[n.toLowerCase()]) !== null && t !== void 0 ? t : Rf);
    }
  });
}
const F1 = /* @__PURE__ */ N1(Fh), cX = /* @__PURE__ */ Ft.deserialize({
  version: 14,
  states: "%vQ]QQOOO#wQRO'#DSO$OQQO'#CwO%eQQO'#CxO%lQQO'#CyO%sQQO'#CzOOQQ'#DS'#DSOOQQ'#C}'#C}O'UQRO'#C{OOQQ'#Cv'#CvOOQQ'#C|'#C|Q]QQOOQOQQOOO'`QQO'#DOO(xQRO,59cO)PQQO,59cO)UQQO'#DSOOQQ,59d,59dO)cQQO,59dOOQQ,59e,59eO)jQQO,59eOOQQ,59f,59fO)qQQO,59fOOQQ-E6{-E6{OOQQ,59b,59bOOQQ-E6z-E6zOOQQ,59j,59jOOQQ-E6|-E6|O+VQRO1G.}O+^QQO,59cOOQQ1G/O1G/OOOQQ1G/P1G/POOQQ1G/Q1G/QP+kQQO'#C}O+rQQO1G.}O)PQQO,59cO,PQQO'#Cw",
  stateData: ",[~OtOSPOSQOS~ORUOSUOTUOUUOVROXSOZTO]XO^QO_UO`UOaPObPOcPOdUOeUOfUOgUOhUO~O^]ORvXSvXTvXUvXVvXXvXZvX]vX_vX`vXavXbvXcvXdvXevXfvXgvXhvX~OsvX~P!jOa_Ob_Oc_O~ORUOSUOTUOUUOVROXSOZTO^tO_UO`UOa`Ob`Oc`OdUOeUOfUOgUOhUO~OWaO~P$ZOYcO~P$ZO[eO~P$ZORUOSUOTUOUUOVROXSOZTO^QO_UO`UOaPObPOcPOdUOeUOfUOgUOhUO~O]hOsoX~P%zOajObjOcjO~O^]ORkaSkaTkaUkaVkaXkaZka]ka_ka`kaakabkackadkaekafkagkahka~Oska~P'kO^]O~OWvXYvX[vX~P!jOWnO~P$ZOYoO~P$ZO[pO~P$ZO^]ORkiSkiTkiUkiVkiXkiZki]ki_ki`kiakibkickidkiekifkigkihki~Oski~P)xOWkaYka[ka~P'kO]hO~P$ZOWkiYki[ki~P)xOasObsOcsO~O",
  goto: "#hwPPPPPPPPPPPPPPPPPPPPPPPPPPx||||!Y!^!d!xPPP#[TYOZeUORSTWZbdfqT[OZQZORiZSWOZQbRQdSQfTZgWbdfqQ^PWk^lmrQl_Qm`RrseVORSTWZbdfq",
  nodeNames: "⚠ LineComment BlockComment String Number Bool Null ( ) { } [ ] ; . Operator Punctuation SpecialVar Identifier QuotedIdentifier Keyword Type Bits Bytes Builtin Script Statement CompositeIdentifier Parens Braces Brackets Statement",
  maxTerm: 38,
  nodeProps: [
    ["isolate", -4, 1, 2, 3, 19, ""]
  ],
  skippedNodes: [0, 1, 2],
  repeatNodeCount: 3,
  tokenData: "RORO",
  tokenizers: [0, F1],
  topRules: { Script: [0, 25] },
  tokenPrec: 0
});
function Hh(r) {
  let e = r.cursor().moveTo(r.from, -1);
  for (; /Comment/.test(e.name); )
    e.moveTo(e.from, -1);
  return e.node;
}
function fs(r, e) {
  let t = r.sliceString(e.from, e.to), i = /^([`'"])(.*)\1$/.exec(t);
  return i ? i[2] : t;
}
function sl(r) {
  return r && (r.name == "Identifier" || r.name == "QuotedIdentifier");
}
function uX(r, e) {
  if (e.name == "CompositeIdentifier") {
    let t = [];
    for (let i = e.firstChild; i; i = i.nextSibling)
      sl(i) && t.push(fs(r, i));
    return t;
  }
  return [fs(r, e)];
}
function Yf(r, e) {
  for (let t = []; ; ) {
    if (!e || e.name != ".")
      return t;
    let i = Hh(e);
    if (!sl(i))
      return t;
    t.unshift(fs(r, i)), e = Hh(i);
  }
}
function dX(r, e) {
  let t = te(r).resolveInner(e, -1), i = fX(r.doc, t);
  return t.name == "Identifier" || t.name == "QuotedIdentifier" || t.name == "Keyword" ? {
    from: t.from,
    quoted: t.name == "QuotedIdentifier" ? r.doc.sliceString(t.from, t.from + 1) : null,
    parents: Yf(r.doc, Hh(t)),
    aliases: i
  } : t.name == "." ? { from: e, quoted: null, parents: Yf(r.doc, t), aliases: i } : { from: e, quoted: null, parents: [], empty: !0, aliases: i };
}
const pX = /* @__PURE__ */ new Set(/* @__PURE__ */ "where group having order union intersect except all distinct limit offset fetch for".split(" "));
function fX(r, e) {
  let t;
  for (let n = e; !t; n = n.parent) {
    if (!n)
      return null;
    n.name == "Statement" && (t = n);
  }
  let i = null;
  for (let n = t.firstChild, s = !1, o = null; n; n = n.nextSibling) {
    let l = n.name == "Keyword" ? r.sliceString(n.from, n.to).toLowerCase() : null, a = null;
    if (!s)
      s = l == "from";
    else if (l == "as" && o && sl(n.nextSibling))
      a = fs(r, n.nextSibling);
    else {
      if (l && pX.has(l))
        break;
      o && sl(n) && (a = fs(r, n));
    }
    a && (i || (i = /* @__PURE__ */ Object.create(null)), i[a] = uX(r, o)), o = /Identifier$/.test(n.name) ? n : null;
  }
  return i;
}
function OX(r, e) {
  return r ? e.map((t) => Object.assign(Object.assign({}, t), { label: t.label[0] == r ? t.label : r + t.label + r, apply: void 0 })) : e;
}
const mX = /^\w*$/, gX = /^[`'"]?\w*[`'"]?$/;
class hu {
  constructor() {
    this.list = [], this.children = void 0;
  }
  child(e, t) {
    let i = this.children || (this.children = /* @__PURE__ */ Object.create(null)), n = i[e];
    return n || (e && this.list.push(H1(e, "type", t)), i[e] = new hu());
  }
  addCompletions(e) {
    for (let t of e) {
      let i = this.list.findIndex((n) => n.label == t.label);
      i > -1 ? this.list[i] = t : this.list.push(t);
    }
  }
}
function H1(r, e, t) {
  return /^[a-z_][a-z_\d]*$/.test(r) ? { label: r, type: e } : { label: r, type: e, apply: t + r + t };
}
function bX(r, e, t, i, n, s) {
  var o;
  let l = new hu(), a = ((o = s == null ? void 0 : s.spec.identifierQuotes) === null || o === void 0 ? void 0 : o[0]) || '"', h = l.child(n || "", a);
  for (let c in r) {
    let u = c.replace(/\\?\./g, (p) => p == "." ? "\0" : p).split("\0"), d = u.length == 1 ? h : l;
    for (let p of u)
      d = d.child(p.replace(/\\\./g, "."), a);
    for (let p of r[c])
      p && d.list.push(typeof p == "string" ? H1(p, "property", a) : p);
  }
  return e && h.addCompletions(e), t && l.addCompletions(t), l.addCompletions(h.list), i && l.addCompletions(h.child(i, a).list), (c) => {
    let { parents: u, from: d, quoted: p, empty: f, aliases: m } = dX(c.state, c.pos);
    if (f && !c.explicit)
      return null;
    m && u.length == 1 && (u = m[u[0]] || u);
    let g = l;
    for (let k of u) {
      for (; !g.children || !g.children[k]; )
        if (g == l)
          g = h;
        else if (g == h && i)
          g = g.child(i, a);
        else
          return null;
      g = g.child(k, a);
    }
    let b = p && c.state.sliceDoc(c.pos, c.pos + 1) == p, v = g.list;
    return g == l && m && (v = v.concat(Object.keys(m).map((k) => ({ label: k, type: "constant" })))), {
      from: d,
      to: b ? c.pos + 1 : void 0,
      options: OX(p, v),
      validFor: p ? gX : mX
    };
  };
}
function wX(r, e) {
  let t = Object.keys(r).map((i) => ({
    label: e ? i.toUpperCase() : i,
    type: r[i] == I1 ? "type" : r[i] == D1 ? "keyword" : "variable",
    boost: -1
  }));
  return Dc(["QuotedIdentifier", "SpecialVar", "String", "LineComment", "BlockComment", "."], $l(t));
}
let yX = /* @__PURE__ */ cX.configure({
  props: [
    /* @__PURE__ */ Br.add({
      Statement: /* @__PURE__ */ si()
    }),
    /* @__PURE__ */ fr.add({
      Statement(r) {
        return { from: r.firstChild.to, to: r.to };
      },
      BlockComment(r) {
        return { from: r.from + 2, to: r.to - 2 };
      }
    }),
    /* @__PURE__ */ Jt({
      Keyword: O.keyword,
      Type: O.typeName,
      Builtin: /* @__PURE__ */ O.standard(O.name),
      Bits: O.number,
      Bytes: O.string,
      Bool: O.bool,
      Null: O.null,
      Number: O.number,
      String: O.string,
      Identifier: O.name,
      QuotedIdentifier: /* @__PURE__ */ O.special(O.string),
      SpecialVar: /* @__PURE__ */ O.special(O.name),
      LineComment: O.lineComment,
      BlockComment: O.blockComment,
      Operator: O.operator,
      "Semi Punctuation": O.punctuation,
      "( )": O.paren,
      "{ }": O.brace,
      "[ ]": O.squareBracket
    })
  ]
});
class cu {
  constructor(e, t, i) {
    this.dialect = e, this.language = t, this.spec = i;
  }
  /**
  Returns the language for this dialect as an extension.
  */
  get extension() {
    return this.language.extension;
  }
  /**
  Define a new dialect.
  */
  static define(e) {
    let t = hX(e, e.keywords, e.types, e.builtin), i = Nt.define({
      name: "sql",
      parser: yX.configure({
        tokenizers: [{ from: F1, to: N1(t) }]
      }),
      languageData: {
        commentTokens: { line: "--", block: { open: "/*", close: "*/" } },
        closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] }
      }
    });
    return new cu(t, i, e);
  }
}
function vX(r, e = !1) {
  return wX(r.dialect.words, e);
}
function xX(r, e = !1) {
  return r.language.data.of({
    autocomplete: vX(r, e)
  });
}
function SX(r) {
  return r.schema ? bX(r.schema, r.tables, r.schemas, r.defaultTable, r.defaultSchema, r.dialect || uu) : () => null;
}
function kX(r) {
  return r.schema ? (r.dialect || uu).language.data.of({
    autocomplete: SX(r)
  }) : [];
}
function $X(r = {}) {
  let e = r.dialect || uu;
  return new cr(e.language, [kX(r), xX(e, !!r.upperCaseKeywords)]);
}
const uu = /* @__PURE__ */ cu.define({}), Yt = {
  asciidoc: {
    name: "asciidoc",
    cm: Xc.define(SP),
    logo: "<it-simple-icons-asciidoctor></it-simple-icons-asciidoctor>",
    extension: "adoc",
    mime: "text/asciidoc",
    helpUrl: "https://docs.asciidoctor.org/asciidoc/latest/syntax-quick-reference/"
  },
  css: {
    name: "css",
    cm: R0(),
    logo: "<it-mdi-language-css3></it-mdi-language-css3>",
    extension: "css",
    mime: "text/css",
    helpUrl: "https://developer.mozilla.org/fr/docs/Web/CSS/Reference"
  },
  html: {
    name: "html",
    cm: c1(),
    logo: "<it-mdi-language-html5></it-mdi-language-html5>",
    extension: "html",
    mime: "text/html",
    helpUrl: "https://developer.mozilla.org/fr/docs/Web/HTML/Reference"
  },
  javascript: {
    name: "javascript",
    cm: Mh(),
    logo: "<it-mdi-language-javascript></it-mdi-language-javascript>",
    extension: "js",
    mime: "text/javascript",
    helpUrl: "https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference"
  },
  json: {
    name: "json",
    cm: RT(),
    logo: "<it-mdi-code-json></it-mdi-code-json>",
    extension: "json",
    mime: "application/json",
    helpUrl: "https://www.json.org/json-fr.html"
  },
  markdown: {
    name: "markdown",
    cm: b5(),
    logo: "<it-mdi-language-markdown></it-mdi-language-markdown>",
    extension: "md",
    mime: "text/markdown",
    helpUrl: "https://www.markdownguide.org/cheat-sheet/"
  },
  prolog: {
    name: "prolog",
    cm: _5(),
    logo: '<svg xmlns="http://www.w3.org/2000/svg" style="display:inline-block;vertical-align:middle;" width="1.5em" height="1.5em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><text x="2" y="15" fill="currentColor" style="font-weight:bold;font-size:inherit">?-</text></svg>',
    extension: "pl",
    mime: "text/x-prolog",
    helpUrl: "http://tau-prolog.org/documentation#prolog"
  },
  python: {
    name: "python",
    cm: YC(),
    logo: "<it-mdi-language-python></it-mdi-language-python>",
    extension: "py",
    mime: "text/x-python",
    helpUrl: "https://www.pythoncheatsheet.org/cheatsheet/dictionaries"
  },
  sql: {
    name: "sql",
    cm: $X(),
    logo: "<it-mdi-database></it-mdi-database>",
    extension: "sql",
    mime: "application/sql",
    helpUrl: "https://sql.sh"
  },
  text: {
    name: "text",
    cm: [],
    logo: "<it-mdi-format-text></it-mdi-format-text>",
    extension: "txt",
    mime: "text/plain",
    helpUrl: ""
  },
  typescript: {
    name: "typescript",
    cm: Mh({ typescript: !0 }),
    logo: "<it-mdi-language-typescript></it-mdi-language-typescript>",
    extension: "ts",
    mime: "video/mp2t",
    // !
    helpUrl: "https://www.typescriptlang.org/cheatsheets"
  }
}, QX = ":host{display:block}:host:focus{border:1px solid var(--color-primary)}.code-it{display:flex;flex-direction:column}.code-it:hover .menu-button{display:block}.editor{outline:none;border-radius:.5em}.editor-base{position:relative}.cm-editor{border-radius:.375rem;padding:4px 0}.dropdown__shortcuts__label{display:inline-flex;justify-content:space-between}.menu-button{display:none;position:absolute;top:4px;right:4px}.sl-toast-stack{left:0;right:auto}";
var PX = Object.defineProperty, TX = Object.getOwnPropertyDescriptor, CX = Object.getPrototypeOf, XX = Reflect.get, Ee = (r, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? TX(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (n = (i ? o(e, t, n) : o(n)) || n);
  return i && n && PX(e, t, n), n;
}, ZX = (r, e, t) => XX(CX(r), t, e);
const _X = Z.theme({
  "&.cm-editor.cm-focused": { outline: "none" }
}), RX = Z.domEventHandlers({
  keyup(r, e) {
    qh(e.dom, "keyup-mouseup-it");
  },
  mouseup(r, e) {
    qh(e.dom, "keyup-mouseup-it");
  }
}), AX = [
  {
    key: "F1",
    run(r) {
      return qh(r.dom, "toggle-toolbar-it"), !0;
    }
  },
  {
    key: "F4",
    run(r) {
      const e = fe.keymap.filter((t) => t.name === "gotoLine");
      return e.length === 1 && e[0].run(r), !0;
    }
  },
  Ng
];
let fe = class extends mi {
  constructor() {
    super(...arguments), this._language = "text", this._placeholder = "F1: afficher/masquer les barres d'outils et d'informations", this._readOnly = !1, this._indentSize = 2, this._theme = "dark", this.message = "", this.extensions = [], this.initialDoc = "", this.languageConfig = new Vt(), this.lineNumbersConfig = new Vt(), this.placeholderConfig = new Vt(), this.readOnlyConfig = new Vt(), this.indentationConfig = new Vt(), this.themeConfig = new Vt(), this.cursorLine = 0, this.cursorColumn = 0, this.lineNumbers = !1, this.preview = !1, this.src = "", this.toolbar = !1;
  }
  get indentSize() {
    return this._indentSize;
  }
  set indentSize(r) {
    r !== this._indentSize && (this._indentSize = r, this.theEditor && this.setIndentationExtension());
  }
  get language() {
    return this._language;
  }
  set language(r) {
    r !== this._language && (this._language = r, this.theEditor && this.setLanguageExtension());
  }
  get placeholder() {
    return this._placeholder;
  }
  set placeholder(r) {
    r !== this._placeholder && (this._placeholder = r, this.theEditor && this.setPlaceholderExtension());
  }
  get readOnly() {
    return this._readOnly;
  }
  set readOnly(r) {
    r !== this._readOnly && (this._readOnly = r, this.theEditor && this.setReadOnlyExtension());
  }
  get theme() {
    return this._theme;
  }
  set theme(r) {
    r !== this._theme && (this._theme = r, this.theEditor && this.setThemeExtension());
  }
  get value() {
    let r = this.initialDoc;
    return this.theEditor && (r = this.theEditor.state.doc.toString()), r;
  }
  set value(r) {
    r !== this.value && this.theEditor && this.theEditor.dispatch({
      changes: {
        from: 0,
        to: this.theEditor.state.doc.length,
        insert: r
      }
    });
  }
  /**
   * La réponse de l'éditeur.
   *
   * @returns {string}
   * @memberof CodeEditIt
   */
  answer() {
    return this.value;
  }
  get indentString() {
    let r = "";
    for (let e = 0; e < this.indentSize; e++)
      r = r.concat(" ");
    return r;
  }
  /**
   * Le nom courant de l'élément.
   *
   * @readonly
   * @type {string}
   * @memberof CodeEditIt
   */
  get tagTitle() {
    return `Editeur de code ${this.language}`;
  }
  createListeners() {
    this.addEventListener("keyup-mouseup-it", () => {
      const r = this.theEditor.state;
      this.cursorLine = r.doc.lineAt(r.selection.main.head).number, this.cursorColumn = r.selection.main.head - r.doc.lineAt(r.selection.main.head).from;
    }), this.addEventListener("toggle-toolbar-it", () => {
      this.toolbar = !this.toolbar;
    });
  }
  async fetchContent(r) {
    return await this.fetchSrc(r ?? "");
  }
  async fetchSrc(r) {
    return (await fetch(r)).text();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async firstUpdated(r) {
    this.legend = `Edition de code ${this.language}`, this.extensions = this.getInitialExtensions(), this.theEditor = new Z({
      doc: "",
      extensions: this.extensions,
      parent: this.editorContainer,
      root: this.shadowRoot
    }), this.value = await this.getInitialDoc(), this.setLanguageExtension(), this.createListeners();
  }
  getHelpUrl() {
    return this.isValidLanguage(this.language) ? Yt[this.language].helpUrl : `https://devdocs.io/${this.language}/`;
  }
  async getInitialDoc() {
    if (this.initialDoc = "", this.src)
      console.log("SRC", this.src), await this.fetchContent(this.src).then((r) => {
        console.log("RESP", r), this.initialDoc += r;
      }), console.log("RES", this.initialDoc);
    else {
      const r = this.querySelector('script[type="enibook"]');
      if (r) {
        const e = pP(r.innerHTML);
        this.initialDoc += e.replace(/&lt;(\/?script)(.*?)&gt;/g, "<$1$2>");
      }
    }
    return this.initialDoc;
  }
  getInitialExtensions() {
    return [
      eP,
      U.phrases.of(gP),
      RX,
      oP({
        highlightActiveBlock: !1,
        hideFirstIndent: !0
      }),
      tn.of(AX),
      this.indentationConfig.of(fi.of(this.indentString)),
      this.languageConfig.of([]),
      this.lineNumbers ? this.lineNumbersConfig.of(Cn()) : this.lineNumbersConfig.of(Cn({ formatNumber: () => "" })),
      Z.lineWrapping,
      _X,
      this.placeholderConfig.of(ea(this.placeholder)),
      this.readOnlyConfig.of(U.readOnly.of(this.readOnly)),
      this.themeConfig.of(this.theme === "dark" ? Rp : Ap)
    ];
  }
  /** Liste des langages reconnus par l'éditeur */
  get validLanguages() {
    return Object.keys(Yt);
  }
  handleCopyClipboard() {
    navigator.clipboard.writeText(this.value).then(
      () => {
        this.notify("Contenu de l'éditeur copié dans le presse-papier.", "success", "it-mdi-check-circle-outline");
      },
      () => {
        this.notify("A priori, interdiction d'écrire dans le presse-papier !", "warning", "it-mdi-alert-outline");
      }
    );
  }
  handleLineNumbers() {
    this.lineNumbers = !this.lineNumbers, this.theEditor.dispatch({
      effects: [
        this.lineNumbers ? this.lineNumbersConfig.reconfigure(Cn()) : this.lineNumbersConfig.reconfigure(Cn({ formatNumber: () => "" }))
      ]
    });
  }
  handleSelectCommand(r) {
    const e = r.detail.item.value;
    (0, eval)(`${e}(this.editor)`);
  }
  handleSelectLanguage(r) {
    const e = r.detail.item;
    this.languageMenuItems.forEach((t) => {
      t.checked = !1;
    }), e.checked = !0, this.language = e.value, this.theEditor.dispatch({
      effects: [
        this.languageConfig.reconfigure(
          Yt[this.language].cm
          /*cmLanguages[this.language]*/
        ),
        this.placeholderConfig.reconfigure(ea(this.placeholder))
      ]
    });
  }
  /** Teste si un langage fait partie des langages reconnus par l'éditeur. */
  isValidLanguage(r) {
    return Object.keys(Yt).includes(r);
  }
  /*
    protected async loadLanguage(lang: string): Promise<LanguageSupport | undefined>{
      const desc = LanguageDescription.matchLanguageName(languages, lang, true)
      const support = await desc?.load()
      return support
    }
  */
  renderAnswer() {
    return X`
      <div part="base" class="code-it">
        <div part="toolbar">
          ${this.renderToolbar()}
        </div>
        <div class="editor-base">
          <div part="editor" class="editor"></div>
          <div part="menuBtn" class="menu-button">
            ${this.readOnly ? X`<sl-tooltip content="copier dans le presse-papier"><sl-button variant="neutral" size="small" @click=${() => this.handleCopyClipboard()}><it-mdi-content-copy></it-mdi-content-copy></sl-button></sl-tooltip>` : X`<sl-tooltip content="activer/désactiver les barres d'outils et d'informations"><sl-button variant="neutral" size="small" @click=${() => {
      this.toolbar = !this.toolbar;
    }}><it-mdi-tools></it-mdi-tools></sl-button></sl-tooltip>`}
            ${this.btnFeedback ? X`<sl-tooltip content="interprétation"><sl-button variant="neutral" size="small" @click=${() => {
      this.emit("feedback-requested-it");
    }}><it-mdi-play></it-mdi-play></sl-button></sl-tooltip>` : X``}
          </div>
        </div>
        <div part="statusbar">
          ${this.renderStatusBar()}
        </div>
      </div>
    `;
  }
  renderCommentButtons() {
    return X`
      <sl-button-group ?hidden=${this.readOnly} label="commentaires">
        <sl-tooltip content="commenter/décommenter la ligne">
          <sl-button size="small" @click=${() => {
      mg(this.theEditor);
    }}><svg xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;display:inline-block" width="1em" height="1em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><path fill="currentColor" d="M5 5v14h2v2H3V3h4v2H5m15 6H7v2h13V7m0 4Z"/></svg></sl-button>
        </sl-tooltip>
        <sl-tooltip content="commenter/décommenter le bloc">
          <sl-button size="small" @click=${() => {
      gg(this.theEditor);
    }}><it-mdi-format-list-group></it-mdi-format-list-group></sl-button>
        </sl-tooltip>
      </sl-button-group>
    `;
  }
  renderHistoryButtons() {
    return X`
      <sl-button-group ?hidden=${this.readOnly} label="historique">
        <sl-tooltip content="annuler toutes les modifications">
          <sl-button size="small" @click=${() => {
      this.reset();
    }}><it-mdi-refresh></it-mdi-refresh></sl-button>
        </sl-tooltip>
        <sl-tooltip content="annuler la dernière modification">
          <sl-button size="small" @click=${() => {
      Ec(this.theEditor);
    }}><it-mdi-undo></it-mdi-undo></sl-button>
        </sl-tooltip>
        <sl-tooltip content="rétablir la dernière annulation">
          <sl-button size="small" @click=${() => {
      Mo(this.theEditor);
    }}><it-mdi-redo></it-mdi-redo></sl-button>
        </sl-tooltip>
      </sl-button-group>
    `;
  }
  renderIndentationButtons() {
    return X`
      <sl-button-group ?hidden=${this.readOnly} label="indentation">
        <sl-tooltip content="indenter">
          <sl-button size="small" @click=${() => {
      zc(this.theEditor);
    }}><it-mdi-format-indent-increase></it-mdi-format-indent-increase></sl-button>
        </sl-tooltip>
        <sl-tooltip content="désindenter">
          <sl-button size="small" @click=${() => {
      Yc(this.theEditor);
    }}><it-mdi-format-indent-decrease></it-mdi-format-indent-decrease></sl-button>
        </sl-tooltip>
      </sl-button-group>
    `;
  }
  renderMiscButtons() {
    return X`
      <sl-button-group label="langage et raccourcis clavier">
        <sl-tooltip content="choisir un langage">
          <sl-dropdown hoist>
            <sl-button slot="trigger" size="small" caret>${this.language ? Va(Yt[this.language].logo) : X`<it-mdi-help></it-mdi-help>`}</sl-button>
            <sl-menu class="dropdown__languages" @sl-select=${this.handleSelectLanguage}>
              ${Object.keys(
      Yt
      /*cmLanguages*/
    ).map((r) => X`<sl-menu-item type="checkbox" value="${r}" ?checked=${this.language === r}>${r}<div slot="prefix">${Va(Yt[r].logo)}</div></sl-menu-item>`)}
            </sl-menu>
          </sl-dropdown>
        </sl-tooltip>
        <sl-tooltip content="raccourcis clavier">
          <sl-dropdown stay-open-on-select hoist ?hidden=${this.readOnly}>
            <sl-button slot="trigger" size="small" caret><it-mdi-keyboard></it-mdi-keyboard></sl-button>
            <sl-menu class="dropdown__shortcuts">
              <sl-menu-item disabled>Commande<div slot="suffix">Raccourci clavier</div></sl-menu-item>
              <sl-divider></sl-divider>
              ${fe.keymap.map((r) => X`<sl-menu-item @click=${() => {
      r.run(this.theEditor);
    }}>${r.run.name}<div slot="suffix">${r.key}</div></sl-menu-item>`)}
              <sl-divider></sl-divider>
              <sl-menu-item disabled>Commande<div slot="suffix">Raccourci clavier</div></sl-menu-item>
            </sl-menu>
          </sl-dropdown>
        </sl-tooltip>
      </sl-button-group>
      <sl-button-group label="outils">
        <sl-tooltip content="afficher/cacher les numéros de ligne">
          <sl-button size="small" @click=${() => this.handleLineNumbers()}><it-mdi-format-list-numbered></it-mdi-format-list-numbered></sl-button>
        </sl-tooltip>
        <sl-tooltip content="copier dans le presse-papier">
          <sl-button size="small" @click=${() => this.handleCopyClipboard()}><it-mdi-content-copy></it-mdi-content-copy></sl-button>
        </sl-tooltip>
        <sl-tooltip content="changer de thème">
          <sl-button size="small" @click=${() => this.toggleTheme()}><it-mdi-theme-light-dark></it-mdi-theme-light-dark></sl-button>
        </sl-tooltip>
        <sl-tooltip .content=${this.fullscreen ? "quitter le mode plein écran" : "passer en mode plein écran"}>
          <sl-button size="small" @click=${() => this.toggleFullscreen()}>
            ${this.fullscreen ? X`<it-mdi-fullscreen-exit></it-mdi-fullscreen-exit>` : X`<it-mdi-fullscreen></it-mdi-fullscreen>`}
          </sl-button>
        </sl-tooltip>
      </sl-button-group>
    `;
  }
  renderSearchButtons() {
    return X`
      <sl-button-group label="rechercher/remplacer">
        <sl-tooltip content="${this.readOnly ? "rechercher" : "rechercher/remplacer"}">
          <sl-button size="small" @click=${() => {
      jc(this.theEditor);
    }}><it-mdi-find-replace></it-mdi-find-replace></sl-button>
        </sl-tooltip>
        <sl-tooltip content="atteindre la ligne:colonne">
          <sl-button size="small" @click=${() => {
      e0(this.theEditor);
    }}><it-mdi-text-search></it-mdi-text-search></sl-button>
        </sl-tooltip>
      </sl-button-group>
    `;
  }
  renderStatusBar() {
    return X`
      <toolbar-it class="statusbar" ?hidden=${!this.toolbar}>
        <sl-button-group slot="end" label="informations">
          <sl-tooltip content="numéros de la ligne et de la colonne courantes">
            <sl-button size="small" variant="neutral">L ${this.cursorLine} - C ${this.cursorColumn}</sl-button>
          </sl-tooltip>
          <sl-tooltip content="indentation en nombre d'espaces">
            <sl-button size="small" variant="neutral">Indent : ${this.indentSize}</sl-button>
          </sl-tooltip>
          <sl-tooltip content="format de données Mime et lien sur une page d'aide">
            <sl-button size="small" variant="neutral" href="${this.getHelpUrl()}" target="_blank">${Yt[this.language].mime}</sl-button>
          </sl-tooltip>
          <sl-tooltip content="mode de l'éditeur : édition ou lecture seule">
            <sl-button size="small" variant="neutral">${this.readOnly ? X`lecture seule` : X`édition`}</sl-button>
          </sl-tooltip>      
        </sl-button-group>
      </toolbar-it>
    `;
  }
  renderToolbar() {
    return X`
      <toolbar-it class="toolbar" ?hidden=${!this.toolbar}>
        <div slot="start">
          ${this.renderHistoryButtons()}
          ${this.renderIndentationButtons()}
          ${this.renderCommentButtons()}
          ${this.renderSearchButtons()}
        </div>
        <div slot="end">
          ${this.renderMiscButtons()}
        </div>
      </toolbar-it>
    `;
  }
  /**
   * Réinitialiser l'éditeur.
   *
   * @memberof CodeEditIt
   */
  reset() {
    this.value = this.initialDoc;
  }
  async setLanguageExtension() {
    Object.keys(
      Yt
      /*cmLanguages*/
    ).includes(this.language) && this.theEditor.dispatch({
      effects: [
        this.languageConfig.reconfigure(
          Yt[this.language].cm
          /*cmLanguages[this.language]*/
        )
      ]
    });
  }
  setPlaceholderExtension() {
    this.theEditor.dispatch({
      effects: [
        this.placeholderConfig.reconfigure(ea(this.placeholder))
      ]
    });
  }
  setReadOnlyExtension() {
    this.theEditor.dispatch({
      effects: [
        this.readOnlyConfig.reconfigure(U.readOnly.of(this.readOnly))
      ]
    });
  }
  setIndentationExtension() {
    this.theEditor.dispatch({
      effects: [
        this.indentationConfig.reconfigure(fi.of(this.indentString))
      ]
    });
  }
  setThemeExtension() {
    this.theEditor.dispatch({
      effects: [
        this.themeConfig.reconfigure(this.theme === "dark" ? Rp : Ap)
      ]
    });
  }
  toAsciidoc() {
    return "Editeur de code";
  }
  toggleTheme() {
    this.theme = this.theme === "dark" ? "light" : "dark", this.setThemeExtension();
  }
  updated(r) {
    r.has("fieldset") && (this.editorContainer.innerHTML = "", this.editorContainer.appendChild(this.theEditor.dom));
  }
};
fe.styles = [
  ZX(fe, fe, "styles"),
  Zt(QX),
  re`/* layer: preflights */
*,::before,::after{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-pan-x: ;--un-pan-y: ;--un-pinch-zoom: ;--un-scroll-snap-strictness:proximity;--un-ordinal: ;--un-slashed-zero: ;--un-numeric-figure: ;--un-numeric-spacing: ;--un-numeric-fraction: ;--un-border-spacing-x:0;--un-border-spacing-y:0;--un-ring-offset-shadow:0 0 rgb(0 0 0 / 0);--un-ring-shadow:0 0 rgb(0 0 0 / 0);--un-shadow-inset: ;--un-shadow:0 0 rgb(0 0 0 / 0);--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgb(147 197 253 / 0.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: ;}::backdrop{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-pan-x: ;--un-pan-y: ;--un-pinch-zoom: ;--un-scroll-snap-strictness:proximity;--un-ordinal: ;--un-slashed-zero: ;--un-numeric-figure: ;--un-numeric-spacing: ;--un-numeric-fraction: ;--un-border-spacing-x:0;--un-border-spacing-y:0;--un-ring-offset-shadow:0 0 rgb(0 0 0 / 0);--un-ring-shadow:0 0 rgb(0 0 0 / 0);--un-shadow-inset: ;--un-shadow:0 0 rgb(0 0 0 / 0);--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgb(147 197 253 / 0.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: ;}
/* layer: icons */
.it-mdi-alert-outline{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M12 2L1 21h22M12 6l7.53 13H4.47M11 10v4h2v-4m-2 6v2h2v-2'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
.it-mdi-check-circle-outline{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10s10-4.5 10-10S17.5 2 12 2m0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8s8 3.59 8 8s-3.59 8-8 8m4.59-12.42L10 14.17l-2.59-2.58L6 13l4 4l8-8z'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
it-mdi-code-json{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M5 3h2v2H5v5a2 2 0 0 1-2 2a2 2 0 0 1 2 2v5h2v2H5c-1.07-.27-2-.9-2-2v-4a2 2 0 0 0-2-2H0v-2h1a2 2 0 0 0 2-2V5a2 2 0 0 1 2-2m14 0a2 2 0 0 1 2 2v4a2 2 0 0 0 2 2h1v2h-1a2 2 0 0 0-2 2v4a2 2 0 0 1-2 2h-2v-2h2v-5a2 2 0 0 1 2-2a2 2 0 0 1-2-2V5h-2V3zm-7 12a1 1 0 0 1 1 1a1 1 0 0 1-1 1a1 1 0 0 1-1-1a1 1 0 0 1 1-1m-4 0a1 1 0 0 1 1 1a1 1 0 0 1-1 1a1 1 0 0 1-1-1a1 1 0 0 1 1-1m8 0a1 1 0 0 1 1 1a1 1 0 0 1-1 1a1 1 0 0 1-1-1a1 1 0 0 1 1-1'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
it-mdi-content-copy{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M19 21H8V7h11m0-2H8a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2m-3-4H4a2 2 0 0 0-2 2v14h2V3h12z'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
it-mdi-database{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M12 3C7.58 3 4 4.79 4 7s3.58 4 8 4s8-1.79 8-4s-3.58-4-8-4M4 9v3c0 2.21 3.58 4 8 4s8-1.79 8-4V9c0 2.21-3.58 4-8 4s-8-1.79-8-4m0 5v3c0 2.21 3.58 4 8 4s8-1.79 8-4v-3c0 2.21-3.58 4-8 4s-8-1.79-8-4'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
it-mdi-find-replace{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M11 6c1.38 0 2.63.56 3.54 1.46L12 10h6V4l-2.05 2.05A6.976 6.976 0 0 0 11 4c-3.53 0-6.43 2.61-6.92 6H6.1A5 5 0 0 1 11 6m5.64 9.14A6.89 6.89 0 0 0 17.92 12H15.9a5 5 0 0 1-4.9 4c-1.38 0-2.63-.56-3.54-1.46L10 12H4v6l2.05-2.05A6.976 6.976 0 0 0 11 18c1.55 0 3-.5 4.14-1.36L20 21.5l1.5-1.5z'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
it-mdi-format-indent-decrease{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M11 13h10v-2H11m0-2h10V7H11M3 3v2h18V3M3 21h18v-2H3m0-7l4 4V8m4 9h10v-2H11z'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
it-mdi-format-indent-increase{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M11 13h10v-2H11m0-2h10V7H11M3 3v2h18V3M11 17h10v-2H11M3 8v8l4-4m-4 9h18v-2H3z'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
it-mdi-format-list-group{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M5 5v14h2v2H3V3h4v2zm15 2H7v2h13zm0 4H7v2h13zm0 4H7v2h13z'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
it-mdi-format-list-numbered{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M7 13v-2h14v2zm0 6v-2h14v2zM7 7V5h14v2zM3 8V5H2V4h2v4zm-1 9v-1h3v4H2v-1h2v-.5H3v-1h1V17zm2.25-7a.75.75 0 0 1 .75.75c0 .2-.08.39-.21.52L3.12 13H5v1H2v-.92L4 11H2v-1z'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
it-mdi-format-text{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='m18.5 4l1.16 4.35l-.96.26c-.45-.87-.91-1.74-1.44-2.18C16.73 6 16.11 6 15.5 6H13v10.5c0 .5 0 1 .33 1.25c.34.25 1 .25 1.67.25v1H9v-1c.67 0 1.33 0 1.67-.25c.33-.25.33-.75.33-1.25V6H8.5c-.61 0-1.23 0-1.76.43c-.53.44-.99 1.31-1.44 2.18l-.96-.26L5.5 4z'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
it-mdi-fullscreen{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M5 5h5v2H7v3H5zm9 0h5v5h-2V7h-3zm3 9h2v5h-5v-2h3zm-7 3v2H5v-5h2v3z'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
it-mdi-fullscreen-exit{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M14 14h5v2h-3v3h-2zm-9 0h5v5H8v-3H5zm3-9h2v5H5V8h3zm11 3v2h-5V5h2v3z'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
it-mdi-help{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M10 19h3v3h-3zm2-17c5.35.22 7.68 5.62 4.5 9.67c-.83 1-2.17 1.66-2.83 2.5C13 15 13 16 13 17h-3c0-1.67 0-3.08.67-4.08c.66-1 2-1.59 2.83-2.25C15.92 8.43 15.32 5.26 12 5a3 3 0 0 0-3 3H6a6 6 0 0 1 6-6'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
it-mdi-keyboard{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M19 10h-2V8h2m0 5h-2v-2h2m-3-1h-2V8h2m0 5h-2v-2h2m0 6H8v-2h8m-9-5H5V8h2m0 5H5v-2h2m1 0h2v2H8m0-5h2v2H8m3 1h2v2h-2m0-5h2v2h-2m9-5H4c-1.11 0-2 .89-2 2v10a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
it-mdi-language-css3{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='m5 3l-.65 3.34h13.59L17.5 8.5H3.92l-.66 3.33h13.59l-.76 3.81l-5.48 1.81l-4.75-1.81l.33-1.64H2.85l-.79 4l7.85 3l9.05-3l1.2-6.03l.24-1.21L21.94 3z'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
it-mdi-language-html5{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='m12 17.56l4.07-1.13l.55-6.1H9.38L9.2 8.3h7.6l.2-1.99H7l.56 6.01h6.89l-.23 2.58l-2.22.6l-2.22-.6l-.14-1.66h-2l.29 3.19zM4.07 3h15.86L18.5 19.2L12 21l-6.5-1.8z'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
it-mdi-language-javascript{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M3 3h18v18H3zm4.73 15.04c.4.85 1.19 1.55 2.54 1.55c1.5 0 2.53-.8 2.53-2.55v-5.78h-1.7V17c0 .86-.35 1.08-.9 1.08c-.58 0-.82-.4-1.09-.87zm5.98-.18c.5.98 1.51 1.73 3.09 1.73c1.6 0 2.8-.83 2.8-2.36c0-1.41-.81-2.04-2.25-2.66l-.42-.18c-.73-.31-1.04-.52-1.04-1.02c0-.41.31-.73.81-.73c.48 0 .8.21 1.09.73l1.31-.87c-.55-.96-1.33-1.33-2.4-1.33c-1.51 0-2.48.96-2.48 2.23c0 1.38.81 2.03 2.03 2.55l.42.18c.78.34 1.24.55 1.24 1.13c0 .48-.45.83-1.15.83c-.83 0-1.31-.43-1.67-1.03z'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
it-mdi-language-markdown{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M20.56 18H3.44C2.65 18 2 17.37 2 16.59V7.41C2 6.63 2.65 6 3.44 6h17.12c.79 0 1.44.63 1.44 1.41v9.18c0 .78-.65 1.41-1.44 1.41M6.81 15.19v-3.66l1.92 2.35l1.92-2.35v3.66h1.93V8.81h-1.93l-1.92 2.35l-1.92-2.35H4.89v6.38zM19.69 12h-1.92V8.81h-1.92V12h-1.93l2.89 3.28z'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
it-mdi-language-python{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M19.14 7.5A2.86 2.86 0 0 1 22 10.36v3.78A2.86 2.86 0 0 1 19.14 17H12c0 .39.32.96.71.96H17v1.68a2.86 2.86 0 0 1-2.86 2.86H9.86A2.86 2.86 0 0 1 7 19.64v-3.75a2.85 2.85 0 0 1 2.86-2.85h5.25a2.85 2.85 0 0 0 2.85-2.86V7.5zm-4.28 11.79c-.4 0-.72.3-.72.89c0 .59.32.71.72.71a.71.71 0 0 0 .71-.71c0-.59-.32-.89-.71-.89m-10-1.79A2.86 2.86 0 0 1 2 14.64v-3.78A2.86 2.86 0 0 1 4.86 8H12c0-.39-.32-.96-.71-.96H7V5.36A2.86 2.86 0 0 1 9.86 2.5h4.28A2.86 2.86 0 0 1 17 5.36v3.75a2.85 2.85 0 0 1-2.86 2.85H8.89a2.85 2.85 0 0 0-2.85 2.86v2.68zM9.14 5.71c.4 0 .72-.3.72-.89c0-.59-.32-.71-.72-.71c-.39 0-.71.12-.71.71s.32.89.71.89'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
it-mdi-language-typescript{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M3 3h18v18H3zm10.71 14.86c.5.98 1.51 1.73 3.09 1.73c1.6 0 2.8-.83 2.8-2.36c0-1.41-.81-2.04-2.25-2.66l-.42-.18c-.73-.31-1.04-.52-1.04-1.02c0-.41.31-.73.81-.73c.48 0 .8.21 1.09.73l1.31-.87c-.55-.96-1.33-1.33-2.4-1.33c-1.51 0-2.48.96-2.48 2.23c0 1.38.81 2.03 2.03 2.55l.42.18c.78.34 1.24.55 1.24 1.13c0 .48-.45.83-1.15.83c-.83 0-1.31-.43-1.67-1.03zM13 11.25H8v1.5h1.5V20h1.75v-7.25H13z'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
it-mdi-play{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M8 5.14v14l11-7z'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
it-mdi-redo{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M18.4 10.6C16.55 9 14.15 8 11.5 8c-4.65 0-8.58 3.03-9.96 7.22L3.9 16a8.002 8.002 0 0 1 7.6-5.5c1.95 0 3.73.72 5.12 1.88L13 16h9V7z'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
it-mdi-refresh{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M17.65 6.35A7.958 7.958 0 0 0 12 4a8 8 0 0 0-8 8a8 8 0 0 0 8 8c3.73 0 6.84-2.55 7.73-6h-2.08A5.99 5.99 0 0 1 12 18a6 6 0 0 1-6-6a6 6 0 0 1 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4z'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
it-mdi-text-search{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='m19.31 18.9l3.08 3.1L21 23.39l-3.12-3.07c-.69.43-1.51.68-2.38.68c-2.5 0-4.5-2-4.5-4.5s2-4.5 4.5-4.5s4.5 2 4.5 4.5c0 .88-.25 1.71-.69 2.4m-3.81.1a2.5 2.5 0 0 0 0-5a2.5 2.5 0 0 0 0 5M21 4v2H3V4zM3 16v-2h6v2zm0-5V9h18v2h-2.03c-1.01-.63-2.2-1-3.47-1s-2.46.37-3.47 1z'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
it-mdi-theme-light-dark{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M7.5 2c-1.79 1.15-3 3.18-3 5.5s1.21 4.35 3.03 5.5C4.46 13 2 10.54 2 7.5A5.5 5.5 0 0 1 7.5 2m11.57 1.5l1.43 1.43L4.93 20.5L3.5 19.07zm-6.18 2.43L11.41 5L9.97 6l.42-1.7L9 3.24l1.75-.12l.58-1.65L12 3.1l1.73.03l-1.35 1.13zm-3.3 3.61l-1.16-.73l-1.12.78l.34-1.32l-1.09-.83l1.36-.09l.45-1.29l.51 1.27l1.36.03l-1.05.87zM19 13.5a5.5 5.5 0 0 1-5.5 5.5c-1.22 0-2.35-.4-3.26-1.07l7.69-7.69c.67.91 1.07 2.04 1.07 3.26m-4.4 6.58l2.77-1.15l-.24 3.35zm4.33-2.7l1.15-2.77l2.2 2.54zm1.15-4.96l-1.14-2.78l3.34.24zM9.63 18.93l2.77 1.15l-2.53 2.19z'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
it-mdi-tools{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='m21.71 20.29l-1.42 1.42a1 1 0 0 1-1.41 0L7 9.85A3.81 3.81 0 0 1 6 10a4 4 0 0 1-3.78-5.3l2.54 2.54l.53-.53l1.42-1.42l.53-.53L4.7 2.22A4 4 0 0 1 10 6a3.81 3.81 0 0 1-.15 1l11.86 11.88a1 1 0 0 1 0 1.41M2.29 18.88a1 1 0 0 0 0 1.41l1.42 1.42a1 1 0 0 0 1.41 0l5.47-5.46l-2.83-2.83M20 2l-4 2v2l-2.17 2.17l2 2L18 8h2l2-4Z'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
it-mdi-undo{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M12.5 8c-2.65 0-5.05 1-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88c3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
it-simple-icons-asciidoctor{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M18.069 0H5.932A5.934 5.934 0 0 0 0 5.932v12.136A5.935 5.935 0 0 0 5.932 24h12.136A5.934 5.934 0 0 0 24 18.068V5.932A5.934 5.934 0 0 0 18.069 0m-7.361 15.404H8.81l-.005.013L7.2 19.282a.506.506 0 1 1-.934-.388l1.45-3.49H4.868a.506.506 0 1 1 0-1.012h5.84a.506.506 0 1 1 0 1.012m7.919 4.165a.506.506 0 0 1-.655-.29L12.621 6.232l-2.395 5.76h1.55a.506.506 0 1 1 0 1.012h-5.84a.506.506 0 1 1 0-1.011h3.195l.004-.012l3.022-7.269a.506.506 0 0 1 .457-.311a.506.506 0 0 1 .478.314l5.816 14.182a.506.506 0 0 1-.281.673'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
/* layer: typography */
:is([prose=""],.prose) :where(h1,h2,h3,h4,h5,h6):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-headings);font-weight:600;line-height:1.25;}:is([prose=""],.prose) :where(a):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-links);text-decoration:underline;font-weight:500;}:is([prose=""],.prose) :where(a code):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-links);}:is([prose=""],.prose) :where(p,ul,ol,pre):not(:where(.not-prose,.not-prose *)){margin:1em 0;line-height:1.75;}:is([prose=""],.prose) :where(blockquote):not(:where(.not-prose,.not-prose *)){margin:1em 0;padding-left:1em;font-style:italic;border-left:.25em solid var(--un-prose-borders);}:is([prose=""],.prose) :where(h1):not(:where(.not-prose,.not-prose *)){margin:1rem 0;font-size:2.25em;}:is([prose=""],.prose) :where(h2):not(:where(.not-prose,.not-prose *)){margin:1.75em 0 .5em;font-size:1.75em;}:is([prose=""],.prose) :where(h3):not(:where(.not-prose,.not-prose *)){margin:1.5em 0 .5em;font-size:1.375em;}:is([prose=""],.prose) :where(h4):not(:where(.not-prose,.not-prose *)){margin:1em 0;font-size:1.125em;}:is([prose=""],.prose) :where(img,video):not(:where(.not-prose,.not-prose *)){max-width:100%;}:is([prose=""],.prose) :where(figure,picture):not(:where(.not-prose,.not-prose *)){margin:1em 0;}:is([prose=""],.prose) :where(figcaption):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-captions);font-size:.875em;}:is([prose=""],.prose) :where(code):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-code);font-size:.875em;font-weight:600;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;}:is([prose=""],.prose) :where(:not(pre) > code):not(:where(.not-prose,.not-prose *))::before,:is([prose=""],.prose) :where(:not(pre) > code):not(:where(.not-prose,.not-prose *))::after{content:"\`";}:is([prose=""],.prose) :where(pre):not(:where(.not-prose,.not-prose *)){padding:1.25rem 1.5rem;overflow-x:auto;border-radius:.375rem;}:is([prose=""],.prose) :where(pre,code):not(:where(.not-prose,.not-prose *)){white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;hyphens:none;background:transparent;}:is([prose=""],.prose) :where(pre code):not(:where(.not-prose,.not-prose *)){font-weight:inherit;}:is([prose=""],.prose) :where(ol,ul):not(:where(.not-prose,.not-prose *)){padding-left:1.25em;}:is([prose=""],.prose) :where(ol):not(:where(.not-prose,.not-prose *)){list-style-type:decimal;}:is([prose=""],.prose) :where(ol[type="A"]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-alpha;}:is([prose=""],.prose) :where(ol[type="a"]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-alpha;}:is([prose=""],.prose) :where(ol[type="A" s]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-alpha;}:is([prose=""],.prose) :where(ol[type="a" s]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-alpha;}:is([prose=""],.prose) :where(ol[type="I"]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-roman;}:is([prose=""],.prose) :where(ol[type="i"]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-roman;}:is([prose=""],.prose) :where(ol[type="I" s]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-roman;}:is([prose=""],.prose) :where(ol[type="i" s]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-roman;}:is([prose=""],.prose) :where(ol[type="1"]):not(:where(.not-prose,.not-prose *)){list-style-type:decimal;}:is([prose=""],.prose) :where(ul):not(:where(.not-prose,.not-prose *)){list-style-type:disc;}:is([prose=""],.prose) :where(ol > li):not(:where(.not-prose,.not-prose *))::marker,:is([prose=""],.prose) :where(ul > li):not(:where(.not-prose,.not-prose *))::marker,:is([prose=""],.prose) :where(summary):not(:where(.not-prose,.not-prose *))::marker{color:var(--un-prose-lists);}:is([prose=""],.prose) :where(hr):not(:where(.not-prose,.not-prose *)){margin:2em 0;border:1px solid var(--un-prose-hr);}:is([prose=""],.prose) :where(table):not(:where(.not-prose,.not-prose *)){display:block;margin:1em 0;border-collapse:collapse;overflow-x:auto;}:is([prose=""],.prose) :where(tr):not(:where(.not-prose,.not-prose *)):nth-child(2n){background:var(--un-prose-bg-soft);}:is([prose=""],.prose) :where(td,th):not(:where(.not-prose,.not-prose *)){border:1px solid var(--un-prose-borders);padding:.625em 1em;}:is([prose=""],.prose) :where(abbr):not(:where(.not-prose,.not-prose *)){cursor:help;}:is([prose=""],.prose) :where(kbd):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-code);border:1px solid;padding:.25rem .5rem;font-size:.875em;border-radius:.25rem;}:is([prose=""],.prose) :where(details):not(:where(.not-prose,.not-prose *)){margin:1em 0;padding:1.25rem 1.5rem;background:var(--un-prose-bg-soft);}:is([prose=""],.prose) :where(summary):not(:where(.not-prose,.not-prose *)){cursor:pointer;font-weight:600;}
/* layer: default */
.static{position:static;}
[hidden=""]{display:none;}
.outline{outline-style:solid;}`
];
fe.keymap = Q0();
Ee([
  De()
], fe.prototype, "message", 2);
Ee([
  J(".editor")
], fe.prototype, "editorContainer", 2);
Ee([
  J("sl-menu.dropdown__languages")
], fe.prototype, "menuLanguages", 2);
Ee([
  Eb("sl-menu.dropdown__languages > sl-menu-item")
], fe.prototype, "languageMenuItems", 2);
Ee([
  De()
], fe.prototype, "cursorLine", 2);
Ee([
  De()
], fe.prototype, "cursorColumn", 2);
Ee([
  y({ type: Number, reflect: !0, attribute: "indent-size" })
], fe.prototype, "indentSize", 1);
Ee([
  y({ type: String, reflect: !0 })
], fe.prototype, "language", 1);
Ee([
  y({ type: Boolean, reflect: !0, attribute: "line-numbers" })
], fe.prototype, "lineNumbers", 2);
Ee([
  y({ type: String, reflect: !0 })
], fe.prototype, "placeholder", 1);
Ee([
  y({ type: Boolean, reflect: !0 })
], fe.prototype, "preview", 2);
Ee([
  y({ type: Boolean, reflect: !0, attribute: "read-only" })
], fe.prototype, "readOnly", 1);
Ee([
  y({ type: String, reflect: !0 })
], fe.prototype, "src", 2);
Ee([
  y({ type: String, reflect: !0 })
], fe.prototype, "theme", 1);
Ee([
  y({ type: Boolean, reflect: !1 })
], fe.prototype, "toolbar", 2);
Ee([
  y({ attribute: !1 })
], fe.prototype, "value", 1);
fe = Ee([
  Mr("code-it")
], fe);
var EX = re`
  ${We}

  :host {
    --color: var(--sl-panel-border-color);
    --width: var(--sl-panel-border-width);
    --spacing: var(--sl-spacing-medium);
  }

  :host(:not([vertical])) {
    display: block;
    border-top: solid var(--width) var(--color);
    margin: var(--spacing) 0;
  }

  :host([vertical]) {
    display: inline-block;
    height: 100%;
    border-left: solid var(--width) var(--color);
    margin: 0 var(--spacing);
  }
`, _l = class extends ve {
  constructor() {
    super(...arguments), this.vertical = !1;
  }
  connectedCallback() {
    super.connectedCallback(), this.setAttribute("role", "separator");
  }
  handleVerticalChange() {
    this.setAttribute("aria-orientation", this.vertical ? "vertical" : "horizontal");
  }
};
_l.styles = EX;
w([
  y({ type: Boolean, reflect: !0 })
], _l.prototype, "vertical", 2);
w([
  $e("vertical")
], _l.prototype, "handleVerticalChange", 1);
_l.define("sl-divider");
var qX = re`
  ${We}

  :host {
    display: block;
  }

  .menu-label {
    display: inline-block;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-semibold);
    line-height: var(--sl-line-height-normal);
    letter-spacing: var(--sl-letter-spacing-normal);
    color: var(--sl-color-neutral-500);
    padding: var(--sl-spacing-2x-small) var(--sl-spacing-x-large);
    user-select: none;
    -webkit-user-select: none;
  }
`, K1 = class extends ve {
  render() {
    return X` <slot part="base" class="menu-label"></slot> `;
  }
};
K1.styles = qX;
K1.define("sl-menu-label");
var J1 = re`
  .form-control .form-control__label {
    display: none;
  }

  .form-control .form-control__help-text {
    display: none;
  }

  /* Label */
  .form-control--has-label .form-control__label {
    display: inline-block;
    color: var(--sl-input-label-color);
    margin-bottom: var(--sl-spacing-3x-small);
  }

  .form-control--has-label.form-control--small .form-control__label {
    font-size: var(--sl-input-label-font-size-small);
  }

  .form-control--has-label.form-control--medium .form-control__label {
    font-size: var(--sl-input-label-font-size-medium);
  }

  .form-control--has-label.form-control--large .form-control__label {
    font-size: var(--sl-input-label-font-size-large);
  }

  :host([required]) .form-control--has-label .form-control__label::after {
    content: var(--sl-input-required-content);
    margin-inline-start: var(--sl-input-required-content-offset);
    color: var(--sl-input-required-content-color);
  }

  /* Help text */
  .form-control--has-help-text .form-control__help-text {
    display: block;
    color: var(--sl-input-help-text-color);
    margin-top: var(--sl-spacing-3x-small);
  }

  .form-control--has-help-text.form-control--small .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-small);
  }

  .form-control--has-help-text.form-control--medium .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-medium);
  }

  .form-control--has-help-text.form-control--large .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-large);
  }

  .form-control--has-help-text.form-control--radio-group .form-control__help-text {
    margin-top: var(--sl-spacing-2x-small);
  }
`, zX = re`
  ${We}
  ${J1}

  :host {
    --thumb-size: 20px;
    --tooltip-offset: 10px;
    --track-color-active: var(--sl-color-neutral-200);
    --track-color-inactive: var(--sl-color-neutral-200);
    --track-active-offset: 0%;
    --track-height: 6px;

    display: block;
  }

  .range {
    position: relative;
  }

  .range__control {
    --percent: 0%;
    -webkit-appearance: none;
    border-radius: 3px;
    width: 100%;
    height: var(--track-height);
    background: transparent;
    line-height: var(--sl-input-height-medium);
    vertical-align: middle;
    margin: 0;

    background-image: linear-gradient(
      to right,
      var(--track-color-inactive) 0%,
      var(--track-color-inactive) min(var(--percent), var(--track-active-offset)),
      var(--track-color-active) min(var(--percent), var(--track-active-offset)),
      var(--track-color-active) max(var(--percent), var(--track-active-offset)),
      var(--track-color-inactive) max(var(--percent), var(--track-active-offset)),
      var(--track-color-inactive) 100%
    );
  }

  .range--rtl .range__control {
    background-image: linear-gradient(
      to left,
      var(--track-color-inactive) 0%,
      var(--track-color-inactive) min(var(--percent), var(--track-active-offset)),
      var(--track-color-active) min(var(--percent), var(--track-active-offset)),
      var(--track-color-active) max(var(--percent), var(--track-active-offset)),
      var(--track-color-inactive) max(var(--percent), var(--track-active-offset)),
      var(--track-color-inactive) 100%
    );
  }

  /* Webkit */
  .range__control::-webkit-slider-runnable-track {
    width: 100%;
    height: var(--track-height);
    border-radius: 3px;
    border: none;
  }

  .range__control::-webkit-slider-thumb {
    border: none;
    width: var(--thumb-size);
    height: var(--thumb-size);
    border-radius: 50%;
    background-color: var(--sl-color-primary-600);
    border: solid var(--sl-input-border-width) var(--sl-color-primary-600);
    -webkit-appearance: none;
    margin-top: calc(var(--thumb-size) / -2 + var(--track-height) / 2);
    cursor: pointer;
  }

  .range__control:enabled::-webkit-slider-thumb:hover {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
  }

  .range__control:enabled:focus-visible::-webkit-slider-thumb {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .range__control:enabled::-webkit-slider-thumb:active {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    cursor: grabbing;
  }

  /* Firefox */
  .range__control::-moz-focus-outer {
    border: 0;
  }

  .range__control::-moz-range-progress {
    background-color: var(--track-color-active);
    border-radius: 3px;
    height: var(--track-height);
  }

  .range__control::-moz-range-track {
    width: 100%;
    height: var(--track-height);
    background-color: var(--track-color-inactive);
    border-radius: 3px;
    border: none;
  }

  .range__control::-moz-range-thumb {
    border: none;
    height: var(--thumb-size);
    width: var(--thumb-size);
    border-radius: 50%;
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    transition:
      var(--sl-transition-fast) border-color,
      var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) box-shadow;
    cursor: pointer;
  }

  .range__control:enabled::-moz-range-thumb:hover {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
  }

  .range__control:enabled:focus-visible::-moz-range-thumb {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .range__control:enabled::-moz-range-thumb:active {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    cursor: grabbing;
  }

  /* States */
  .range__control:focus-visible {
    outline: none;
  }

  .range__control:disabled {
    opacity: 0.5;
  }

  .range__control:disabled::-webkit-slider-thumb {
    cursor: not-allowed;
  }

  .range__control:disabled::-moz-range-thumb {
    cursor: not-allowed;
  }

  /* Tooltip output */
  .range__tooltip {
    position: absolute;
    z-index: var(--sl-z-index-tooltip);
    left: 0;
    border-radius: var(--sl-tooltip-border-radius);
    background-color: var(--sl-tooltip-background-color);
    font-family: var(--sl-tooltip-font-family);
    font-size: var(--sl-tooltip-font-size);
    font-weight: var(--sl-tooltip-font-weight);
    line-height: var(--sl-tooltip-line-height);
    color: var(--sl-tooltip-color);
    opacity: 0;
    padding: var(--sl-tooltip-padding);
    transition: var(--sl-transition-fast) opacity;
    pointer-events: none;
  }

  .range__tooltip:after {
    content: '';
    position: absolute;
    width: 0;
    height: 0;
    left: 50%;
    translate: calc(-1 * var(--sl-tooltip-arrow-size));
  }

  .range--tooltip-visible .range__tooltip {
    opacity: 1;
  }

  /* Tooltip on top */
  .range--tooltip-top .range__tooltip {
    top: calc(-1 * var(--thumb-size) - var(--tooltip-offset));
  }

  .range--tooltip-top .range__tooltip:after {
    border-top: var(--sl-tooltip-arrow-size) solid var(--sl-tooltip-background-color);
    border-left: var(--sl-tooltip-arrow-size) solid transparent;
    border-right: var(--sl-tooltip-arrow-size) solid transparent;
    top: 100%;
  }

  /* Tooltip on bottom */
  .range--tooltip-bottom .range__tooltip {
    bottom: calc(-1 * var(--thumb-size) - var(--tooltip-offset));
  }

  .range--tooltip-bottom .range__tooltip:after {
    border-bottom: var(--sl-tooltip-arrow-size) solid var(--sl-tooltip-background-color);
    border-left: var(--sl-tooltip-arrow-size) solid transparent;
    border-right: var(--sl-tooltip-arrow-size) solid transparent;
    bottom: 100%;
  }

  @media (forced-colors: active) {
    .range__control,
    .range__tooltip {
      border: solid 1px transparent;
    }

    .range__control::-webkit-slider-thumb {
      border: solid 1px transparent;
    }

    .range__control::-moz-range-thumb {
      border: solid 1px transparent;
    }

    .range__tooltip:after {
      display: none;
    }
  }
`, eb = (r = "value") => (e, t) => {
  const i = e.constructor, n = i.prototype.attributeChangedCallback;
  i.prototype.attributeChangedCallback = function(s, o, l) {
    var a;
    const h = i.getPropertyOptions(r), c = typeof h.attribute == "string" ? h.attribute : r;
    if (s === c) {
      const u = h.converter || qi, p = (typeof u == "function" ? u : (a = u == null ? void 0 : u.fromAttribute) != null ? a : qi.fromAttribute)(l, h.type);
      this[r] !== p && (this[t] = p);
    }
    n.call(this, s, o, l);
  };
};
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const tb = al(class extends hl {
  constructor(r) {
    if (super(r), r.type !== tr.PROPERTY && r.type !== tr.ATTRIBUTE && r.type !== tr.BOOLEAN_ATTRIBUTE)
      throw Error("The `live` directive is not allowed on child or event bindings");
    if (!tO(r))
      throw Error("`live` bindings can only contain a single expression");
  }
  render(r) {
    return r;
  }
  update(r, [e]) {
    if (e === pt || e === de)
      return e;
    const t = r.element, i = r.name;
    if (r.type === tr.PROPERTY) {
      if (e === t[i])
        return pt;
    } else if (r.type === tr.BOOLEAN_ATTRIBUTE) {
      if (!!e === t.hasAttribute(i))
        return pt;
    } else if (r.type === tr.ATTRIBUTE && t.getAttribute(i) === e + "")
      return pt;
    return Nb(r), e;
  }
});
var me = class extends ve {
  constructor() {
    super(...arguments), this.formControlController = new tc(this), this.hasSlotController = new ms(this, "help-text", "label"), this.localize = new Vr(this), this.hasFocus = !1, this.hasTooltip = !1, this.title = "", this.name = "", this.value = 0, this.label = "", this.helpText = "", this.disabled = !1, this.min = 0, this.max = 100, this.step = 1, this.tooltip = "top", this.tooltipFormatter = (r) => r.toString(), this.form = "", this.defaultValue = 0;
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  connectedCallback() {
    super.connectedCallback(), this.resizeObserver = new ResizeObserver(() => this.syncRange()), this.value < this.min && (this.value = this.min), this.value > this.max && (this.value = this.max), this.updateComplete.then(() => {
      this.syncRange(), this.resizeObserver.observe(this.input);
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.resizeObserver.unobserve(this.input);
  }
  handleChange() {
    this.emit("sl-change");
  }
  handleInput() {
    this.value = parseFloat(this.input.value), this.emit("sl-input"), this.syncRange();
  }
  handleBlur() {
    this.hasFocus = !1, this.hasTooltip = !1, this.emit("sl-blur");
  }
  handleFocus() {
    this.hasFocus = !0, this.hasTooltip = !0, this.emit("sl-focus");
  }
  handleThumbDragStart() {
    this.hasTooltip = !0;
  }
  handleThumbDragEnd() {
    this.hasTooltip = !1;
  }
  syncProgress(r) {
    this.input.style.setProperty("--percent", `${r * 100}%`);
  }
  syncTooltip(r) {
    if (this.output !== null) {
      const e = this.input.offsetWidth, t = this.output.offsetWidth, i = getComputedStyle(this.input).getPropertyValue("--thumb-size"), n = this.localize.dir() === "rtl", s = e * r;
      if (n) {
        const o = `${e - s}px + ${r} * ${i}`;
        this.output.style.translate = `calc((${o} - ${t / 2}px - ${i} / 2))`;
      } else {
        const o = `${s}px - ${r} * ${i}`;
        this.output.style.translate = `calc(${o} - ${t / 2}px + ${i} / 2)`;
      }
    }
  }
  handleValueChange() {
    this.formControlController.updateValidity(), this.input.value = this.value.toString(), this.value = parseFloat(this.input.value), this.syncRange();
  }
  handleDisabledChange() {
    this.formControlController.setValidity(this.disabled);
  }
  syncRange() {
    const r = Math.max(0, (this.value - this.min) / (this.max - this.min));
    this.syncProgress(r), this.tooltip !== "none" && this.syncTooltip(r);
  }
  handleInvalid(r) {
    this.formControlController.setValidity(!1), this.formControlController.emitInvalidEvent(r);
  }
  /** Sets focus on the range. */
  focus(r) {
    this.input.focus(r);
  }
  /** Removes focus from the range. */
  blur() {
    this.input.blur();
  }
  /** Increments the value of the range by the value of the step attribute. */
  stepUp() {
    this.input.stepUp(), this.value !== Number(this.input.value) && (this.value = Number(this.input.value));
  }
  /** Decrements the value of the range by the value of the step attribute. */
  stepDown() {
    this.input.stepDown(), this.value !== Number(this.input.value) && (this.value = Number(this.input.value));
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(r) {
    this.input.setCustomValidity(r), this.formControlController.updateValidity();
  }
  render() {
    const r = this.hasSlotController.test("label"), e = this.hasSlotController.test("help-text"), t = this.label ? !0 : !!r, i = this.helpText ? !0 : !!e;
    return X`
      <div
        part="form-control"
        class=${je({
      "form-control": !0,
      "form-control--medium": !0,
      // range only has one size
      "form-control--has-label": t,
      "form-control--has-help-text": i
    })}
      >
        <label
          part="form-control-label"
          class="form-control__label"
          for="input"
          aria-hidden=${t ? "false" : "true"}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <div
            part="base"
            class=${je({
      range: !0,
      "range--disabled": this.disabled,
      "range--focused": this.hasFocus,
      "range--rtl": this.localize.dir() === "rtl",
      "range--tooltip-visible": this.hasTooltip,
      "range--tooltip-top": this.tooltip === "top",
      "range--tooltip-bottom": this.tooltip === "bottom"
    })}
            @mousedown=${this.handleThumbDragStart}
            @mouseup=${this.handleThumbDragEnd}
            @touchstart=${this.handleThumbDragStart}
            @touchend=${this.handleThumbDragEnd}
          >
            <input
              part="input"
              id="input"
              class="range__control"
              title=${this.title}
              type="range"
              name=${I(this.name)}
              ?disabled=${this.disabled}
              min=${I(this.min)}
              max=${I(this.max)}
              step=${I(this.step)}
              .value=${tb(this.value.toString())}
              aria-describedby="help-text"
              @change=${this.handleChange}
              @focus=${this.handleFocus}
              @input=${this.handleInput}
              @invalid=${this.handleInvalid}
              @blur=${this.handleBlur}
            />
            ${this.tooltip !== "none" && !this.disabled ? X`
                  <output part="tooltip" class="range__tooltip">
                    ${typeof this.tooltipFormatter == "function" ? this.tooltipFormatter(this.value) : this.value}
                  </output>
                ` : ""}
          </div>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${i ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
me.styles = zX;
w([
  J(".range__control")
], me.prototype, "input", 2);
w([
  J(".range__tooltip")
], me.prototype, "output", 2);
w([
  De()
], me.prototype, "hasFocus", 2);
w([
  De()
], me.prototype, "hasTooltip", 2);
w([
  y()
], me.prototype, "title", 2);
w([
  y()
], me.prototype, "name", 2);
w([
  y({ type: Number })
], me.prototype, "value", 2);
w([
  y()
], me.prototype, "label", 2);
w([
  y({ attribute: "help-text" })
], me.prototype, "helpText", 2);
w([
  y({ type: Boolean, reflect: !0 })
], me.prototype, "disabled", 2);
w([
  y({ type: Number })
], me.prototype, "min", 2);
w([
  y({ type: Number })
], me.prototype, "max", 2);
w([
  y({ type: Number })
], me.prototype, "step", 2);
w([
  y()
], me.prototype, "tooltip", 2);
w([
  y({ attribute: !1 })
], me.prototype, "tooltipFormatter", 2);
w([
  y({ reflect: !0 })
], me.prototype, "form", 2);
w([
  eb()
], me.prototype, "defaultValue", 2);
w([
  Rb({ passive: !0 })
], me.prototype, "handleThumbDragStart", 1);
w([
  $e("value", { waitUntilFirstUpdate: !0 })
], me.prototype, "handleValueChange", 1);
w([
  $e("disabled", { waitUntilFirstUpdate: !0 })
], me.prototype, "handleDisabledChange", 1);
w([
  $e("hasTooltip", { waitUntilFirstUpdate: !0 })
], me.prototype, "syncRange", 1);
me.define("sl-range");
const YX = ":host{display:inline-block}.primary-color__colors{display:grid;grid-template-columns:repeat(9,1fr);grid-gap:var(--sl-spacing-small);justify-items:center;z-index:var(--sl-z-index-dropdown);border:solid var(--sl-panel-border-width) var(--sl-panel-border-color);border-radius:var(--sl-border-radius-medium);background:var(--sl-panel-background-color);padding:var(--sl-spacing-x-small)}.primary-color__ranges{background:var(--sl-panel-background-color);z-index:var(--sl-z-index-dropdown)}sl-range{--thumb-size: var(--sl-spacing-small);--tooltip-offset: calc(-1*var(--sl-spacing-small));--track-color-active: var(--color-primary);--track-color-inactive: var(--sl-color-primary-200);--track-height: var(--sl-spacing-3x-small)}sl-range::part(base){padding:var(--sl-spacing-small);padding-top:var(--sl-spacing-x-large)}sl-range::part(tooltip){left:var(--sl-spacing-small)}";
var WX = Object.defineProperty, VX = Object.getOwnPropertyDescriptor, MX = Object.getPrototypeOf, jX = Reflect.get, Rl = (r, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? VX(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (n = (i ? o(e, t, n) : o(n)) || n);
  return i && n && WX(e, t, n), n;
}, LX = (r, e, t) => jX(MX(r), t, e);
const BX = [
  "gray",
  "red",
  "orange",
  "amber",
  "yellow",
  "lime",
  "green",
  "emerald",
  "teal",
  "cyan",
  "sky",
  "blue",
  "indigo",
  "violet",
  "purple",
  "fuchsia",
  "pink",
  "rose"
];
let Cr = class extends Pt {
  constructor() {
    super(), this.color = "purple", this.range = 5, this.size = "small", this.initLocalStorage(), this.setPrimaryColor();
  }
  /** Modifie la couleur principale du thème à l'aide des primitives [`shoelace`](https://shoelace.style/tokens/color). */
  cssPrimaryColor() {
    return `
      :root,
      .sl-theme-light,
      .sl-theme-dark {
        --sl-color-primary-50: var(--sl-color-${this.color}-50);
        --sl-color-primary-100: var(--sl-color-${this.color}-100);
        --sl-color-primary-200: var(--sl-color-${this.color}-200);
        --sl-color-primary-300: var(--sl-color-${this.color}-300);
        --sl-color-primary-400: var(--sl-color-${this.color}-400);
        --sl-color-primary-500: var(--sl-color-${this.color}-500);
        --sl-color-primary-600: var(--sl-color-${this.color}-600);
        --sl-color-primary-700: var(--sl-color-${this.color}-700);
        --sl-color-primary-800: var(--sl-color-${this.color}-800);
        --sl-color-primary-900: var(--sl-color-${this.color}-900);
        --sl-color-primary-950: var(--sl-color-${this.color}-950);
        --color-primary: var(--sl-color-primary-${this.range}00);
        --color-success: var(--sl-color-success-500);
        --color-warning: var(--sl-color-warning-500);
        --color-danger: var(--sl-color-danger-500);
        --color-neutral: var(--sl-color-neutral-500);
      }
    `;
  }
  get colors() {
    return BX.map(
      (r) => ({ name: r, value: `var(--sl-color-${r}-${this.range}00);` })
    );
  }
  handleChangeRange(r) {
    const e = r.target;
    this.range = e.value, this.setPrimaryColor();
  }
  initLocalStorage() {
    const r = localStorage.getItem("color"), e = localStorage.getItem("range");
    r ? this.color = r : localStorage.setItem("color", this.color), e ? this.range = parseInt(e) : localStorage.setItem("range", `${this.range}`);
  }
  render() {
    return X`
      <div part="base" class="primary-color">
        <sl-dropdown hoist>
          <sl-button size=${this.size} slot="trigger" caret>
            <it-mdi-palette-outline style="color:var(--color-primary);"></it-mdi-palette-outline>
          </sl-button>
          <div class='primary-color__colors'>
            ${this.colors.map(
      (r) => X`
                <div class='primary-color__colors__color' @click=${() => {
        this.color = r.name, this.setPrimaryColor();
      }}>
                  <it-mdi-square-rounded title=${r.name} style="cursor:pointer;width:1.5em;height:1.5em;color:${r.value}"></it-mdi-square-rounded>
                </div>
              `
    )}
          </div>
          <div class='primary-color__ranges'>
            <sl-range min="1" max="9" step="1" tooltip="top" .value=${this.range} @sl-change=${this.handleChangeRange}></sl-range>
          </div>
        </sl-dropdown>
      </div>
    `;
  }
  setPrimaryColor() {
    localStorage.color = this.color, localStorage.range = this.range;
    let r = document.querySelector("style#colors");
    r || (r = document.createElement("style"), r.id = "colors", document.head.appendChild(r)), r.innerHTML = this.cssPrimaryColor();
  }
  get tagTitle() {
    return "Couleurs";
  }
  toAsciidoc() {
    throw new Error("Method not implemented.");
  }
};
Cr.styles = [
  LX(Cr, Cr, "styles"),
  Zt(YX),
  re`/* layer: preflights */
*,::before,::after{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-pan-x: ;--un-pan-y: ;--un-pinch-zoom: ;--un-scroll-snap-strictness:proximity;--un-ordinal: ;--un-slashed-zero: ;--un-numeric-figure: ;--un-numeric-spacing: ;--un-numeric-fraction: ;--un-border-spacing-x:0;--un-border-spacing-y:0;--un-ring-offset-shadow:0 0 rgb(0 0 0 / 0);--un-ring-shadow:0 0 rgb(0 0 0 / 0);--un-shadow-inset: ;--un-shadow:0 0 rgb(0 0 0 / 0);--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgb(147 197 253 / 0.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: ;}::backdrop{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-pan-x: ;--un-pan-y: ;--un-pinch-zoom: ;--un-scroll-snap-strictness:proximity;--un-ordinal: ;--un-slashed-zero: ;--un-numeric-figure: ;--un-numeric-spacing: ;--un-numeric-fraction: ;--un-border-spacing-x:0;--un-border-spacing-y:0;--un-ring-offset-shadow:0 0 rgb(0 0 0 / 0);--un-ring-shadow:0 0 rgb(0 0 0 / 0);--un-shadow-inset: ;--un-shadow:0 0 rgb(0 0 0 / 0);--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgb(147 197 253 / 0.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: ;}
/* layer: icons */
it-mdi-palette-outline{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M12 22A10 10 0 0 1 2 12A10 10 0 0 1 12 2c5.5 0 10 4 10 9a6 6 0 0 1-6 6h-1.8c-.3 0-.5.2-.5.5c0 .1.1.2.1.3c.4.5.6 1.1.6 1.7c.1 1.4-1 2.5-2.4 2.5m0-18a8 8 0 0 0-8 8a8 8 0 0 0 8 8c.3 0 .5-.2.5-.5c0-.2-.1-.3-.1-.4c-.4-.5-.6-1-.6-1.6c0-1.4 1.1-2.5 2.5-2.5H16a4 4 0 0 0 4-4c0-3.9-3.6-7-8-7m-5.5 6c.8 0 1.5.7 1.5 1.5S7.3 13 6.5 13S5 12.3 5 11.5S5.7 10 6.5 10m3-4c.8 0 1.5.7 1.5 1.5S10.3 9 9.5 9S8 8.3 8 7.5S8.7 6 9.5 6m5 0c.8 0 1.5.7 1.5 1.5S15.3 9 14.5 9S13 8.3 13 7.5S13.7 6 14.5 6m3 4c.8 0 1.5.7 1.5 1.5s-.7 1.5-1.5 1.5s-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
it-mdi-square-rounded{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M8 3h8c2.76 0 5 2.24 5 5v8c0 2.76-2.24 5-5 5H8c-2.76 0-5-2.24-5-5V8c0-2.76 2.24-5 5-5'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
/* layer: typography */
:is([prose=""],.prose) :where(h1,h2,h3,h4,h5,h6):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-headings);font-weight:600;line-height:1.25;}:is([prose=""],.prose) :where(a):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-links);text-decoration:underline;font-weight:500;}:is([prose=""],.prose) :where(a code):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-links);}:is([prose=""],.prose) :where(p,ul,ol,pre):not(:where(.not-prose,.not-prose *)){margin:1em 0;line-height:1.75;}:is([prose=""],.prose) :where(blockquote):not(:where(.not-prose,.not-prose *)){margin:1em 0;padding-left:1em;font-style:italic;border-left:.25em solid var(--un-prose-borders);}:is([prose=""],.prose) :where(h1):not(:where(.not-prose,.not-prose *)){margin:1rem 0;font-size:2.25em;}:is([prose=""],.prose) :where(h2):not(:where(.not-prose,.not-prose *)){margin:1.75em 0 .5em;font-size:1.75em;}:is([prose=""],.prose) :where(h3):not(:where(.not-prose,.not-prose *)){margin:1.5em 0 .5em;font-size:1.375em;}:is([prose=""],.prose) :where(h4):not(:where(.not-prose,.not-prose *)){margin:1em 0;font-size:1.125em;}:is([prose=""],.prose) :where(img,video):not(:where(.not-prose,.not-prose *)){max-width:100%;}:is([prose=""],.prose) :where(figure,picture):not(:where(.not-prose,.not-prose *)){margin:1em 0;}:is([prose=""],.prose) :where(figcaption):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-captions);font-size:.875em;}:is([prose=""],.prose) :where(code):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-code);font-size:.875em;font-weight:600;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;}:is([prose=""],.prose) :where(:not(pre) > code):not(:where(.not-prose,.not-prose *))::before,:is([prose=""],.prose) :where(:not(pre) > code):not(:where(.not-prose,.not-prose *))::after{content:"\`";}:is([prose=""],.prose) :where(pre):not(:where(.not-prose,.not-prose *)){padding:1.25rem 1.5rem;overflow-x:auto;border-radius:.375rem;}:is([prose=""],.prose) :where(pre,code):not(:where(.not-prose,.not-prose *)){white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;hyphens:none;background:transparent;}:is([prose=""],.prose) :where(pre code):not(:where(.not-prose,.not-prose *)){font-weight:inherit;}:is([prose=""],.prose) :where(ol,ul):not(:where(.not-prose,.not-prose *)){padding-left:1.25em;}:is([prose=""],.prose) :where(ol):not(:where(.not-prose,.not-prose *)){list-style-type:decimal;}:is([prose=""],.prose) :where(ol[type="A"]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-alpha;}:is([prose=""],.prose) :where(ol[type="a"]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-alpha;}:is([prose=""],.prose) :where(ol[type="A" s]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-alpha;}:is([prose=""],.prose) :where(ol[type="a" s]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-alpha;}:is([prose=""],.prose) :where(ol[type="I"]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-roman;}:is([prose=""],.prose) :where(ol[type="i"]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-roman;}:is([prose=""],.prose) :where(ol[type="I" s]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-roman;}:is([prose=""],.prose) :where(ol[type="i" s]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-roman;}:is([prose=""],.prose) :where(ol[type="1"]):not(:where(.not-prose,.not-prose *)){list-style-type:decimal;}:is([prose=""],.prose) :where(ul):not(:where(.not-prose,.not-prose *)){list-style-type:disc;}:is([prose=""],.prose) :where(ol > li):not(:where(.not-prose,.not-prose *))::marker,:is([prose=""],.prose) :where(ul > li):not(:where(.not-prose,.not-prose *))::marker,:is([prose=""],.prose) :where(summary):not(:where(.not-prose,.not-prose *))::marker{color:var(--un-prose-lists);}:is([prose=""],.prose) :where(hr):not(:where(.not-prose,.not-prose *)){margin:2em 0;border:1px solid var(--un-prose-hr);}:is([prose=""],.prose) :where(table):not(:where(.not-prose,.not-prose *)){display:block;margin:1em 0;border-collapse:collapse;overflow-x:auto;}:is([prose=""],.prose) :where(tr):not(:where(.not-prose,.not-prose *)):nth-child(2n){background:var(--un-prose-bg-soft);}:is([prose=""],.prose) :where(td,th):not(:where(.not-prose,.not-prose *)){border:1px solid var(--un-prose-borders);padding:.625em 1em;}:is([prose=""],.prose) :where(abbr):not(:where(.not-prose,.not-prose *)){cursor:help;}:is([prose=""],.prose) :where(kbd):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-code);border:1px solid;padding:.25rem .5rem;font-size:.875em;border-radius:.25rem;}:is([prose=""],.prose) :where(details):not(:where(.not-prose,.not-prose *)){margin:1em 0;padding:1.25rem 1.5rem;background:var(--un-prose-bg-soft);}:is([prose=""],.prose) :where(summary):not(:where(.not-prose,.not-prose *)){cursor:pointer;font-weight:600;}
/* layer: default */
.static{position:static;}`
];
Rl([
  y({ type: String, reflect: !0 })
], Cr.prototype, "color", 2);
Rl([
  y({ type: String, reflect: !0 })
], Cr.prototype, "range", 2);
Rl([
  y({ type: String, reflect: !0 })
], Cr.prototype, "size", 2);
Cr = Rl([
  Mr("color-it")
], Cr);
const DX = [
  "enib",
  "lorem",
  "ipsum",
  "dolor",
  "sit",
  "amet,",
  "consectetur",
  "adipiscing",
  "elit",
  "ut",
  "aliquam,",
  "purus",
  "sit",
  "amet",
  "luctus",
  "venenatis,",
  "lectus",
  "magna",
  "fringilla",
  "urna,",
  "porttitor",
  "rhoncus",
  "dolor",
  "purus",
  "non",
  "enim",
  "enit",
  "enise",
  "praesent",
  "elementum",
  "facilisis",
  "leo,",
  "vel",
  "fringilla",
  "est",
  "ullamcorper",
  "eget",
  "nulla",
  "facilisi",
  "etiam",
  "dignissim",
  "diam",
  "quis",
  "lobortis",
  "scelerisque",
  "fermentum",
  "dui",
  "faucibus",
  "in",
  "ornare",
  "quam",
  "viverra",
  "orci",
  "sagittis",
  "eu",
  "volutpat",
  "odio",
  "facilisis",
  "mauris",
  "sit",
  "amet",
  "massa",
  "vitae",
  "tortor",
  "condimentum",
  "lacinia",
  "quis",
  "vel",
  "eros",
  "donec",
  "ac",
  "odio",
  "tempor",
  "orci",
  "dapibus",
  "ultrices",
  "in",
  "iaculis",
  "nunc",
  "sed",
  "augue",
  "lacus,",
  "viverra",
  "vitae",
  "congue",
  "eu,",
  "consequat",
  "ac",
  "felis",
  "donec",
  "et",
  "odio",
  "pellentesque",
  "diam",
  "volutpat",
  "commodo",
  "sed",
  "egestas",
  "egestas",
  "fringilla",
  "phasellus",
  "faucibus",
  "scelerisque",
  "eleifend",
  "donec",
  "pretium",
  "vulputate",
  "sapien",
  "nec",
  "sagittis",
  "aliquam",
  "malesuada",
  "bibendum",
  "arcu",
  "vitae",
  "elementum",
  "curabitur",
  "vitae",
  "nunc",
  "sed",
  "velit",
  "dignissim",
  "sodales",
  "ut",
  "eu",
  "sem",
  "integer",
  "vitae",
  "justo",
  "eget",
  "magna",
  "fermentum",
  "iaculis",
  "eu",
  "non",
  "diam",
  "phasellus",
  "vestibulum",
  "lorem",
  "sed",
  "risus",
  "ultricies",
  "tristique",
  "nulla",
  "aliquet",
  "tortor,",
  "at",
  "auctor",
  "urna",
  "nunc",
  "id",
  "cursus",
  "metus",
  "aliquam",
  "eleifend",
  "mi",
  "in",
  "nulla",
  "posuere",
  "sollicitudin",
  "aliquam",
  "ultrices",
  "sagittis",
  "orci,",
  "a",
  "scelerisque",
  "purus",
  "semper",
  "eget",
  "duis",
  "at",
  "tellus",
  "at",
  "urna",
  "condimentum",
  "mattis",
  "pellentesque",
  "id",
  "nibh",
  "tortor,",
  "id",
  "aliquet",
  "lectus",
  "proin",
  "nibh",
  "nisl,",
  "condimentum",
  "id",
  "venenatis",
  "a,",
  "condimentum",
  "vitae",
  "sapien",
  "pellentesque",
  "habitant",
  "morbi",
  "tristique",
  "senectus",
  "et",
  "netus",
  "et",
  "malesuada",
  "fames",
  "ac",
  "turpis",
  "egestas",
  "sed",
  "tempus,",
  "urna",
  "et",
  "pharetra",
  "pharetra,",
  "massa",
  "massa",
  "ultricies",
  "mi,",
  "quis",
  "hendrerit",
  "dolor",
  "magna",
  "eget",
  "est",
  "lorem",
  "ipsum",
  "dolor",
  "sit",
  "amet,",
  "consectetur",
  "adipiscing",
  "elit",
  "pellentesque",
  "habitant",
  "morbi",
  "tristique",
  "senectus",
  "et",
  "netus",
  "et",
  "malesuada",
  "fames",
  "ac",
  "turpis",
  "egestas",
  "integer",
  "eget",
  "aliquet",
  "nibh",
  "praesent",
  "tristique",
  "magna",
  "sit",
  "amet",
  "purus",
  "gravida",
  "quis",
  "blandit",
  "turpis",
  "cursus",
  "in",
  "hac",
  "habitasse",
  "platea",
  "dictumst",
  "quisque",
  "sagittis,",
  "purus",
  "sit",
  "amet",
  "volutpat",
  "consequat,",
  "mauris",
  "nunc",
  "congue",
  "nisi,",
  "vitae",
  "suscipit",
  "tellus",
  "mauris",
  "a",
  "diam",
  "maecenas",
  "sed",
  "ut",
  "sem",
  "viverra",
  "aliquet",
  "eget",
  "sit",
  "amet",
  "tellus",
  "cras",
  "adipiscing",
  "eu",
  "turpis",
  "egestas",
  "pretium",
  "aenean",
  "pharetra,",
  "magna",
  "ac",
  "placerat",
  "vestibulum,",
  "lectus",
  "mauris",
  "ultrices",
  "eros,",
  "in",
  "cursus",
  "turpis",
  "massa",
  "tincidunt",
  "dui",
  "ut",
  "ornare",
  "lectus",
  "sit",
  "amet",
  "est",
  "placerat",
  "in",
  "egestas",
  "erat",
  "imperdiet",
  "sed",
  "euismod",
  "nisi",
  "porta",
  "lorem",
  "mollis",
  "aliquam",
  "ut",
  "porttitor",
  "leo",
  "a",
  "diam",
  "sollicitudin",
  "tempor",
  "id",
  "eu",
  "nisl",
  "nunc",
  "mi",
  "ipsum,",
  "faucibus",
  "vitae",
  "aliquet",
  "nec,",
  "ullamcorper",
  "sit",
  "amet",
  "risus",
  "nullam",
  "eget",
  "felis",
  "eget",
  "nunc",
  "lobortis",
  "mattis",
  "aliquam",
  "faucibus",
  "purus",
  "in",
  "massa",
  "tempor",
  "nec",
  "feugiat",
  "nisl",
  "pretium",
  "fusce",
  "id",
  "velit",
  "ut",
  "tortor",
  "pretium",
  "viverra",
  "suspendisse",
  "potenti",
  "nullam",
  "ac",
  "tortor",
  "vitae",
  "purus",
  "faucibus",
  "ornare",
  "suspendisse",
  "sed",
  "nisi",
  "lacus,",
  "sed",
  "viverra",
  "tellus",
  "in",
  "hac",
  "habitasse",
  "platea",
  "dictumst",
  "vestibulum",
  "rhoncus",
  "est",
  "pellentesque",
  "elit",
  "ullamcorper",
  "dignissim",
  "cras",
  "tincidunt",
  "lobortis",
  "feugiat",
  "vivamus",
  "at",
  "augue",
  "eget",
  "arcu",
  "dictum",
  "varius",
  "duis",
  "at",
  "consectetur",
  "lorem",
  "donec",
  "massa",
  "sapien,",
  "faucibus",
  "et",
  "molestie",
  "ac,",
  "feugiat",
  "sed",
  "lectus",
  "vestibulum",
  "mattis",
  "ullamcorper",
  "velit",
  "sed",
  "ullamcorper",
  "morbi",
  "tincidunt",
  "ornare",
  "massa,",
  "eget",
  "egestas",
  "purus",
  "viverra",
  "accumsan",
  "in",
  "nisl",
  "nisi,",
  "scelerisque",
  "eu",
  "ultrices",
  "vitae,",
  "auctor",
  "eu",
  "augue",
  "ut",
  "lectus",
  "arcu,",
  "bibendum",
  "at",
  "varius",
  "vel,",
  "pharetra",
  "vel",
  "turpis",
  "nunc",
  "eget",
  "lorem",
  "dolor,",
  "sed",
  "viverra",
  "ipsum",
  "nunc",
  "aliquet",
  "bibendum",
  "enim,",
  "facilisis",
  "gravida",
  "neque",
  "convallis",
  "a",
  "cras",
  "semper",
  "auctor",
  "neque,",
  "vitae",
  "tempus",
  "quam",
  "pellentesque",
  "nec",
  "nam",
  "aliquam",
  "sem",
  "et",
  "tortor",
  "consequat",
  "id",
  "porta",
  "nibh",
  "enib,",
  "venenatis",
  "cras",
  "sed",
  "felis",
  "eget",
  "velit",
  "aliquet",
  "sagittis",
  "id",
  "consectetur",
  "purus",
  "ut",
  "faucibus",
  "pulvinar",
  "elementum",
  "integer",
  "neque,",
  "volutpat",
  "ac",
  "tincidunt",
  "vitae,",
  "semper",
  "quis",
  "lectus",
  "nulla",
  "at",
  "volutpat",
  "diam",
  "ut",
  "venenatis",
  "tellus",
  "in",
  "metus",
  "vulputate",
  "eu",
  "scelerisque",
  "felis",
  "imperdiet",
  "proin",
  "fermentum",
  "leo",
  "vel",
  "orci",
  "porta",
  "non",
  "pulvinar",
  "neque",
  "laoreet",
  "suspendisse",
  "interdum",
  "consectetur",
  "libero,",
  "id",
  "faucibus",
  "nisl",
  "tincidunt",
  "eget",
  "nullam",
  "non",
  "nisi",
  "est,",
  "sit",
  "amet",
  "facilisis",
  "magna",
  "etiam",
  "tempor,",
  "orci",
  "eu",
  "lobortis",
  "elementum,",
  "nibh",
  "tellus",
  "molestie",
  "nunc,",
  "non",
  "blandit",
  "massa",
  "nec",
  "dui",
  "nunc",
  "mattis",
  "ut",
  "tellus",
  "elementum",
  "sagittis",
  "vitae",
  "et",
  "leo",
  "duis",
  "ut",
  "diam",
  "quam",
  "nulla",
  "porttitor",
  "massa",
  "id",
  "neque",
  "aliquam",
  "vestibulum",
  "morbi",
  "blandit",
  "cursus",
  "risus,",
  "at",
  "ultrices",
  "mi",
  "tempus",
  "imperdiet",
  "nulla",
  "malesuada",
  "pellentesque",
  "elit",
  "eget",
  "gravida",
  "cum",
  "sociis",
  "natoque",
  "penatibus",
  "et",
  "magnis",
  "dis",
  "parturient",
  "montes,",
  "nascetur",
  "ridiculus",
  "mus",
  "mauris",
  "vitae",
  "ultricies",
  "leo",
  "integer",
  "malesuada",
  "nunc",
  "vel",
  "risus",
  "commodo",
  "viverra",
  "maecenas",
  "accumsan,",
  "lacus",
  "vel",
  "facilisis",
  "volutpat,",
  "est",
  "velit",
  "egestas",
  "dui,",
  "id",
  "ornare",
  "arcu",
  "odio",
  "ut",
  "sem",
  "nulla",
  "pharetra",
  "diam",
  "sit",
  "amet",
  "nisl",
  "suscipit",
  "adipiscing",
  "bibendum",
  "est",
  "ultricies",
  "integer",
  "quis",
  "auctor",
  "elit",
  "sed",
  "vulputate",
  "mi",
  "sit",
  "amet",
  "mauris",
  "commodo",
  "quis",
  "imperdiet",
  "massa",
  "tincidunt",
  "nunc",
  "pulvinar",
  "sapien",
  "et",
  "ligula",
  "ullamcorper",
  "malesuada",
  "proin",
  "libero",
  "nunc,",
  "consequat",
  "interdum",
  "varius",
  "sit",
  "amet,",
  "mattis",
  "vulputate",
  "nulla",
  "aliquet",
  "porttitor",
  "lacus,",
  "luctus",
  "accumsan",
  "tortor",
  "posuere",
  "ac",
  "ut",
  "consequat",
  "semper",
  "viverra",
  "nam",
  "libero",
  "justo,",
  "laoreet",
  "sit",
  "amet",
  "cursus",
  "sit",
  "amet,",
  "dictum",
  "sit",
  "amet",
  "justo",
  "donec",
  "diam,",
  "vulputate",
  "ut",
  "pharetra",
  "sit",
  "amet,",
  "aliquam",
  "id",
  "diam",
  "maecenas",
  "ultricies",
  "mi",
  "eget",
  "mauris",
  "pharetra",
  "et",
  "ultrices",
  "neque",
  "ornare",
  "aenean",
  "euismod",
  "elementum",
  "nisi,",
  "quis",
  "eleifend",
  "quam",
  "adipiscing",
  "vitae",
  "proin",
  "sagittis,",
  "nisl",
  "rhoncus",
  "mattis",
  "rhoncus,",
  "urna",
  "neque",
  "viverra",
  "justo,",
  "nec",
  "ultrices",
  "dui",
  "sapien",
  "eget",
  "mi",
  "proin",
  "sed",
  "libero",
  "enim,",
  "sed",
  "faucibus",
  "turpis",
  "in",
  "eu",
  "mi",
  "bibendum",
  "neque",
  "egestas",
  "congue",
  "quisque",
  "egestas",
  "diam",
  "in",
  "arcu",
  "cursus",
  "euismod",
  "quis",
  "viverra",
  "nibh",
  "cras",
  "pulvinar",
  "mattis",
  "nunc,",
  "sed",
  "blandit",
  "libero",
  "volutpat",
  "sed",
  "cras",
  "ornare",
  "arcu",
  "dui",
  "vivamus",
  "arcu",
  "felis,",
  "bibendum",
  "ut",
  "tristique",
  "et,",
  "egestas",
  "quis",
  "ipsum",
  "suspendisse",
  "ultrices",
  "gravida",
  "dictum",
  "fusce",
  "ut",
  "placerat",
  "orci",
  "nulla",
  "pellentesque",
  "dignissim",
  "enim,",
  "sit",
  "amet",
  "venenatis",
  "urna",
  "cursus",
  "eget",
  "nunc",
  "scelerisque",
  "viverra",
  "mauris,",
  "in",
  "aliquam",
  "sem",
  "fringilla",
  "ut",
  "morbi",
  "tincidunt",
  "augue",
  "interdum",
  "velit",
  "euismod",
  "in",
  "pellentesque",
  "massa",
  "placerat",
  "duis",
  "ultricies",
  "lacus",
  "sed",
  "turpis",
  "tincidunt",
  "id",
  "aliquet",
  "risus",
  "feugiat",
  "in",
  "ante",
  "metus,",
  "dictum",
  "at",
  "tempor",
  "commodo,",
  "ullamcorper",
  "a",
  "lacus",
  "vestibulum",
  "sed",
  "arcu",
  "non",
  "odio",
  "euismod",
  "lacinia",
  "at",
  "quis",
  "risus",
  "sed",
  "vulputate",
  "odio",
  "ut",
  "blandit",
  "volutpat",
  "maecenas",
  "volutpat",
  "blandit",
  "aliquam",
  "etiam",
  "erat",
  "velit,",
  "scelerisque",
  "in",
  "dictum",
  "non,",
  "consectetur",
  "a",
  "erat",
  "nam",
  "at",
  "lectus",
  "urna",
  "duis",
  "convallis",
  "convallis",
  "tellus,",
  "id",
  "interdum",
  "velit",
  "laoreet",
  "id",
  "donec",
  "ultrices",
  "tincidunt",
  "arcu,",
  "non",
  "sodales",
  "neque",
  "sodales",
  "ut",
  "etiam",
  "sit",
  "amet",
  "nisl",
  "purus,",
  "in",
  "mollis",
  "nunc",
  "sed",
  "id",
  "semper",
  "risus",
  "in",
  "hendrerit",
  "gravida",
  "rutrum",
  "quisque",
  "non",
  "tellus",
  "orci,",
  "ac",
  "auctor",
  "augue",
  "mauris",
  "augue",
  "neque,",
  "gravida",
  "in",
  "fermentum",
  "et,",
  "sollicitudin",
  "ac",
  "orci",
  "phasellus",
  "egestas",
  "tellus",
  "rutrum",
  "tellus",
  "pellentesque",
  "eu",
  "tincidunt",
  "tortor",
  "aliquam",
  "nulla",
  "facilisi",
  "cras",
  "fermentum,",
  "odio",
  "eu",
  "feugiat",
  "pretium,",
  "nibh",
  "ipsum",
  "consequat",
  "nisl,",
  "vel",
  "pretium",
  "lectus",
  "quam",
  "id",
  "leo",
  "in",
  "vitae",
  "turpis",
  "massa",
  "sed",
  "elementum",
  "tempus",
  "egestas",
  "sed",
  "sed",
  "risus",
  "pretium",
  "quam",
  "vulputate",
  "dignissim",
  "suspendisse",
  "in",
  "est",
  "ante",
  "in",
  "nibh",
  "mauris,",
  "cursus",
  "mattis",
  "molestie",
  "a,",
  "iaculis",
  "at",
  "erat",
  "pellentesque",
  "adipiscing",
  "commodo",
  "elit,",
  "at",
  "imperdiet",
  "dui",
  "accumsan",
  "sit",
  "amet",
  "nulla",
  "facilisi",
  "morbi",
  "tempus",
  "iaculis",
  "urna,",
  "id",
  "volutpat",
  "lacus",
  "laoreet",
  "non",
  "curabitur",
  "gravida",
  "arcu",
  "ac",
  "tortor",
  "dignissim",
  "convallis",
  "aenean",
  "et",
  "tortor",
  "at",
  "risus",
  "viverra",
  "adipiscing",
  "at",
  "in",
  "tellus",
  "integer",
  "feugiat",
  "scelerisque",
  "varius",
  "morbi",
  "nunc,",
  "faucibus",
  "a",
  "pellentesque",
  "sit",
  "amet,",
  "porttitor",
  "eget",
  "dolor",
  "morbi",
  "non",
  "arcu",
  "risus,",
  "quis",
  "varius",
  "quam",
  "quisque",
  "id",
  "diam",
  "vel",
  "quam",
  "elementum",
  "pulvinar",
  "etiam",
  "non",
  "quam",
  "lacus",
  "suspendisse",
  "faucibus",
  "interdum",
  "posuere",
  "lorem",
  "ipsum",
  "dolor",
  "sit",
  "amet,",
  "consectetur",
  "adipiscing",
  "elit",
  "duis",
  "tristique",
  "sollicitudin",
  "nibh",
  "sit",
  "amet",
  "commodo",
  "nulla",
  "facilisi",
  "nullam",
  "vehicula",
  "ipsum",
  "a",
  "arcu",
  "cursus",
  "vitae",
  "congue",
  "mauris",
  "rhoncus",
  "aenean",
  "vel",
  "elit",
  "scelerisque",
  "mauris",
  "pellentesque",
  "pulvinar",
  "pellentesque",
  "habitant",
  "morbi",
  "tristique",
  "senectus",
  "et",
  "netus",
  "et",
  "malesuada",
  "fames",
  "ac",
  "turpis",
  "egestas",
  "maecenas",
  "pharetra",
  "convallis",
  "posuere",
  "morbi",
  "leo",
  "urna,",
  "molestie",
  "at",
  "elementum",
  "eu,",
  "facilisis",
  "sed",
  "odio",
  "morbi",
  "quis",
  "commodo",
  "odio",
  "aenean",
  "sed",
  "adipiscing",
  "diam",
  "donec",
  "adipiscing",
  "tristique",
  "risus",
  "nec",
  "feugiat",
  "in",
  "fermentum",
  "posuere",
  "urna",
  "nec",
  "tincidunt",
  "praesent",
  "semper",
  "feugiat",
  "nibh",
  "sed",
  "pulvinar",
  "proin",
  "gravida",
  "hendrerit",
  "lectus",
  "a",
  "molestie",
  "enibook"
], IX = ":host{display:block;margin-bottom:.5rem}p{margin:0;margin-bottom:.5rem}p:last-child{margin-bottom:0}ol,ul,dl{margin:0}dt{font-weight:600}";
var UX = Object.defineProperty, GX = Object.getOwnPropertyDescriptor, NX = Object.getPrototypeOf, FX = Reflect.get, du = (r, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? GX(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (n = (i ? o(e, t, n) : o(n)) || n);
  return i && n && UX(e, t, n), n;
}, HX = (r, e, t) => FX(NX(r), t, e);
let li = class extends Pt {
  constructor() {
    super(...arguments), this.count = 1, this.type = "paragraph";
  }
  createTerm() {
    const r = this.randomLength(1, 3), e = [];
    for (let t = 0; t < r; t++)
      e.push(this.createText("word"));
    return e.join(" ");
  }
  /** Texte aléatoire généré selon son type. */
  createText(r = "paragraph") {
    let e, t;
    const i = [], n = [], s = [];
    switch (r) {
      case "dlist":
      case "olist":
      case "ulist":
        t = this.randomLength(1, 3);
        for (let o = 0; o < t; o++)
          n.push(this.createText("sentence"));
        e = n.join(" ");
        break;
      case "paragraph":
        t = this.randomLength(2, 10);
        for (let o = 0; o < t; o++)
          i.push(this.createText("sentence"));
        e = i.join(" ");
        break;
      case "sentence":
        t = this.randomLength(5, 30);
        for (let o = 0; o < t; o++)
          s.push(this.createText("word"));
        s[0] = s[0].substring(0, 1).toUpperCase() + s[0].substring(1), e = `${s.join(" ")}.`.replace(/(\.,|,\.)/g, ".");
        break;
      case "word":
        e = this.dictionary[this.randomLength(0, this.dictionary.length - 1)];
        break;
    }
    return e;
  }
  /**
   * Dictionnaire de mots.
   */
  get dictionary() {
    return DX;
  }
  /**
   * Le nom courant de l'élément : `Lorem Ipsum`.
   */
  get tagTitle() {
    return "Lorem Ipsum";
  }
  randomLength(r, e) {
    return r < 0 || e < r ? this.randomLength(1, 10) : Math.floor(Math.random() * (e - r + 1) + r);
  }
  render() {
    return this.count < 1 && (this.count = 1), X`
      <div part="base" class="lorem-ipsum prose">
        ${this.renderTemplate()}
      </div>
    `;
  }
  renderTemplate() {
    let r = X``;
    switch (this.type) {
      case "dlist":
        r = this.renderList("dl", this.count);
        break;
      case "olist":
        r = this.renderList("ol", this.count);
        break;
      case "paragraph":
        r = this.renderParagraph(this.count);
        break;
      case "sentence":
        r = this.renderSentence(this.count);
        break;
      case "ulist":
        r = this.renderList("ul", this.count);
        break;
      case "word":
        r = this.renderWord(this.count);
        break;
    }
    return r;
  }
  renderList(r = "ul", e = 1) {
    const t = [];
    for (let s = 0; s < e; s++)
      t.push(this.createText("olist"));
    let i = X`${t.map(
      (s) => X`<li>${s}</li>`
    )}`;
    const n = X`${t.map(
      (s) => X`<dt>${this.createTerm()}</dt>
          <dd>${s}</dd>`
    )}`;
    switch (r) {
      case "ol":
        i = X`<ol part="olist">
          ${i}
        </ol>`;
        break;
      case "dl":
        i = X`<dl part="dlist">${n}</dl>`;
        break;
      case "ul":
      default:
        i = X`<ul part="ulist">
          ${i}
        </ul>`;
    }
    return i;
  }
  renderParagraph(r = 1) {
    const e = [];
    for (let t = 0; t < r; t++)
      e.push(this.createText("paragraph"));
    return X`${e.map(
      (t) => X`<p part="paragraph">${t}</p>`
    )}`;
  }
  renderSentence(r = 1) {
    const e = [];
    for (let t = 0; t < r; t++)
      e.push(this.createText("sentence"));
    return X`<p part="sentence">
      ${e.map((t) => X`${t}<br />`)}
    </p>`;
  }
  renderWord(r = 1) {
    const e = [];
    for (let t = 0; t < r; t++)
      e.push(this.createText("word"));
    return X`<p part="word">${e.map((t) => X`${t} `)}</p>`;
  }
  /**
   * Syntaxe `asciidoc` équivalente `name::target[attributes]`
   *
   * Voir la documentation Asciidoc sur les <a href="https://docs.asciidoctor.org/asciidoc/latest/key-concepts/#macros">macros de type _block_</a>
   * @examples `lorem-ipsum::paragraph[]` , `lorem-ipsum::olist[count=2]`
   */
  toAsciidoc() {
    return `
      lorem-ipsum::${this.type}[count=${this.count}]
    `.replace(/^ +| +$/gm, "");
  }
};
li.styles = [
  HX(li, li, "styles"),
  Zt(IX),
  re`/* layer: preflights */
*,::before,::after{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-pan-x: ;--un-pan-y: ;--un-pinch-zoom: ;--un-scroll-snap-strictness:proximity;--un-ordinal: ;--un-slashed-zero: ;--un-numeric-figure: ;--un-numeric-spacing: ;--un-numeric-fraction: ;--un-border-spacing-x:0;--un-border-spacing-y:0;--un-ring-offset-shadow:0 0 rgb(0 0 0 / 0);--un-ring-shadow:0 0 rgb(0 0 0 / 0);--un-shadow-inset: ;--un-shadow:0 0 rgb(0 0 0 / 0);--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgb(147 197 253 / 0.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: ;}::backdrop{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-pan-x: ;--un-pan-y: ;--un-pinch-zoom: ;--un-scroll-snap-strictness:proximity;--un-ordinal: ;--un-slashed-zero: ;--un-numeric-figure: ;--un-numeric-spacing: ;--un-numeric-fraction: ;--un-border-spacing-x:0;--un-border-spacing-y:0;--un-ring-offset-shadow:0 0 rgb(0 0 0 / 0);--un-ring-shadow:0 0 rgb(0 0 0 / 0);--un-shadow-inset: ;--un-shadow:0 0 rgb(0 0 0 / 0);--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgb(147 197 253 / 0.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: ;}
/* layer: typography */
:is([prose=""],.prose) :where(h1,h2,h3,h4,h5,h6):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-headings);font-weight:600;line-height:1.25;}:is([prose=""],.prose) :where(a):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-links);text-decoration:underline;font-weight:500;}:is([prose=""],.prose) :where(a code):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-links);}:is([prose=""],.prose) :where(p,ul,ol,pre):not(:where(.not-prose,.not-prose *)){margin:1em 0;line-height:1.75;}:is([prose=""],.prose) :where(blockquote):not(:where(.not-prose,.not-prose *)){margin:1em 0;padding-left:1em;font-style:italic;border-left:.25em solid var(--un-prose-borders);}:is([prose=""],.prose) :where(h1):not(:where(.not-prose,.not-prose *)){margin:1rem 0;font-size:2.25em;}:is([prose=""],.prose) :where(h2):not(:where(.not-prose,.not-prose *)){margin:1.75em 0 .5em;font-size:1.75em;}:is([prose=""],.prose) :where(h3):not(:where(.not-prose,.not-prose *)){margin:1.5em 0 .5em;font-size:1.375em;}:is([prose=""],.prose) :where(h4):not(:where(.not-prose,.not-prose *)){margin:1em 0;font-size:1.125em;}:is([prose=""],.prose) :where(img,video):not(:where(.not-prose,.not-prose *)){max-width:100%;}:is([prose=""],.prose) :where(figure,picture):not(:where(.not-prose,.not-prose *)){margin:1em 0;}:is([prose=""],.prose) :where(figcaption):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-captions);font-size:.875em;}:is([prose=""],.prose) :where(code):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-code);font-size:.875em;font-weight:600;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;}:is([prose=""],.prose) :where(:not(pre) > code):not(:where(.not-prose,.not-prose *))::before,:is([prose=""],.prose) :where(:not(pre) > code):not(:where(.not-prose,.not-prose *))::after{content:"\`";}:is([prose=""],.prose) :where(pre):not(:where(.not-prose,.not-prose *)){padding:1.25rem 1.5rem;overflow-x:auto;border-radius:.375rem;}:is([prose=""],.prose) :where(pre,code):not(:where(.not-prose,.not-prose *)){white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;hyphens:none;background:transparent;}:is([prose=""],.prose) :where(pre code):not(:where(.not-prose,.not-prose *)){font-weight:inherit;}:is([prose=""],.prose) :where(ol,ul):not(:where(.not-prose,.not-prose *)){padding-left:1.25em;}:is([prose=""],.prose) :where(ol):not(:where(.not-prose,.not-prose *)){list-style-type:decimal;}:is([prose=""],.prose) :where(ol[type="A"]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-alpha;}:is([prose=""],.prose) :where(ol[type="a"]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-alpha;}:is([prose=""],.prose) :where(ol[type="A" s]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-alpha;}:is([prose=""],.prose) :where(ol[type="a" s]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-alpha;}:is([prose=""],.prose) :where(ol[type="I"]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-roman;}:is([prose=""],.prose) :where(ol[type="i"]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-roman;}:is([prose=""],.prose) :where(ol[type="I" s]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-roman;}:is([prose=""],.prose) :where(ol[type="i" s]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-roman;}:is([prose=""],.prose) :where(ol[type="1"]):not(:where(.not-prose,.not-prose *)){list-style-type:decimal;}:is([prose=""],.prose) :where(ul):not(:where(.not-prose,.not-prose *)){list-style-type:disc;}:is([prose=""],.prose) :where(ol > li):not(:where(.not-prose,.not-prose *))::marker,:is([prose=""],.prose) :where(ul > li):not(:where(.not-prose,.not-prose *))::marker,:is([prose=""],.prose) :where(summary):not(:where(.not-prose,.not-prose *))::marker{color:var(--un-prose-lists);}:is([prose=""],.prose) :where(hr):not(:where(.not-prose,.not-prose *)){margin:2em 0;border:1px solid var(--un-prose-hr);}:is([prose=""],.prose) :where(table):not(:where(.not-prose,.not-prose *)){display:block;margin:1em 0;border-collapse:collapse;overflow-x:auto;}:is([prose=""],.prose) :where(tr):not(:where(.not-prose,.not-prose *)):nth-child(2n){background:var(--un-prose-bg-soft);}:is([prose=""],.prose) :where(td,th):not(:where(.not-prose,.not-prose *)){border:1px solid var(--un-prose-borders);padding:.625em 1em;}:is([prose=""],.prose) :where(abbr):not(:where(.not-prose,.not-prose *)){cursor:help;}:is([prose=""],.prose) :where(kbd):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-code);border:1px solid;padding:.25rem .5rem;font-size:.875em;border-radius:.25rem;}:is([prose=""],.prose) :where(details):not(:where(.not-prose,.not-prose *)){margin:1em 0;padding:1.25rem 1.5rem;background:var(--un-prose-bg-soft);}:is([prose=""],.prose) :where(summary):not(:where(.not-prose,.not-prose *)){cursor:pointer;font-weight:600;}
.prose,
[prose=""]{color:var(--un-prose-body);max-width:65ch;}
/* layer: default */
.static{position:static;}`
];
du([
  y({ type: Number, reflect: !0 })
], li.prototype, "count", 2);
du([
  y({ type: String, reflect: !0 })
], li.prototype, "type", 2);
li = du([
  Mr("lorem-ipsum-it")
], li);
const KX = ":host{display:inline-block}kbd{font-family:var(--sl-font-mono);background-color:var(--sl-color-neutral-50);border-radius:var(--sl-border-radius-small);border:1px solid var(--sl-color-neutral-200);box-shadow:inset 0 1px 0 var(--color-white);padding:var(--sl-spacing-3x-small) var(--sl-spacing-2x-small)}";
var JX = Object.defineProperty, eZ = Object.getOwnPropertyDescriptor, tZ = Object.getPrototypeOf, rZ = Reflect.get, Al = (r, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? eZ(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (n = (i ? o(e, t, n) : o(n)) || n);
  return i && n && JX(e, t, n), n;
}, iZ = (r, e, t) => rZ(tZ(r), t, e);
let Xr = class extends Pt {
  constructor() {
    super(), this.size = "small", this.theme = this.getTheme();
  }
  firstUpdated(r) {
    this.setTheme(this.theme), this.menu.addEventListener("sl-select", (e) => {
      const t = e;
      this.setTheme(t.detail.item.value);
    }), window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", () => this.setTheme(this.theme)), document.addEventListener("keydown", (e) => {
      const t = e.composedPath();
      e.key === "\\" && !t.some((i) => {
        var n;
        return ["input", "textarea"].includes((n = i.tagName) == null ? void 0 : n.toLowerCase());
      }) && (e.preventDefault(), this.setTheme(this.isDark() ? "light" : "dark"));
    });
  }
  getTheme() {
    return localStorage.getItem("theme") || "system";
  }
  isDark() {
    return this.theme === "system" ? window.matchMedia("(prefers-color-scheme: dark)").matches : this.theme === "dark";
  }
  render() {
    return X`
      <sl-dropdown class="theme" hoist>
        <sl-button size=${this.size} slot="trigger" caret>
          ${this.isDark() ? X`<it-mdi-weather-night style="color:var(--sl-color-yellow-500)"></it-mdi-weather-night>` : X`<it-mdi-white-balance-sunny style="color:var(--sl-color-yellow-500)"></it-mdi-white-balance-sunny>`}
        </sl-button>
        <sl-menu>
          <sl-menu-item type="checkbox" value="light">Clair</sl-menu-item>
          <sl-menu-item type="checkbox" value="dark">Sombre</sl-menu-item>
          <sl-divider></sl-divider>
          <sl-menu-item type="checkbox" value="system">System</sl-menu-item>
        </sl-menu>
      </sl-dropdown>
    `;
  }
  setTheme(r) {
    const e = Object.assign(document.createElement("style"), {
      textContent: "* { transition: none !important; }"
    });
    this.theme = r, localStorage.setItem("theme", this.theme), [...this.menu.querySelectorAll("sl-menu-item")].map((t) => t.checked = t.getAttribute("value") === this.theme), document.body.appendChild(e), requestAnimationFrame(() => {
      document.documentElement.classList.toggle("sl-theme-dark", this.isDark()), document.documentElement.classList.toggle("sl-theme-light", !this.isDark()), requestAnimationFrame(() => document.body.removeChild(e));
    });
  }
  get tagTitle() {
    return "Thème";
  }
  toAsciidoc() {
    throw new Error("Method not implemented.");
  }
};
Xr.styles = [
  iZ(Xr, Xr, "styles"),
  Zt(KX),
  re`/* layer: preflights */
*,::before,::after{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-pan-x: ;--un-pan-y: ;--un-pinch-zoom: ;--un-scroll-snap-strictness:proximity;--un-ordinal: ;--un-slashed-zero: ;--un-numeric-figure: ;--un-numeric-spacing: ;--un-numeric-fraction: ;--un-border-spacing-x:0;--un-border-spacing-y:0;--un-ring-offset-shadow:0 0 rgb(0 0 0 / 0);--un-ring-shadow:0 0 rgb(0 0 0 / 0);--un-shadow-inset: ;--un-shadow:0 0 rgb(0 0 0 / 0);--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgb(147 197 253 / 0.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: ;}::backdrop{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-pan-x: ;--un-pan-y: ;--un-pinch-zoom: ;--un-scroll-snap-strictness:proximity;--un-ordinal: ;--un-slashed-zero: ;--un-numeric-figure: ;--un-numeric-spacing: ;--un-numeric-fraction: ;--un-border-spacing-x:0;--un-border-spacing-y:0;--un-ring-offset-shadow:0 0 rgb(0 0 0 / 0);--un-ring-shadow:0 0 rgb(0 0 0 / 0);--un-shadow-inset: ;--un-shadow:0 0 rgb(0 0 0 / 0);--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgb(147 197 253 / 0.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: ;}
/* layer: icons */
it-mdi-weather-night{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='m17.75 4.09l-2.53 1.94l.91 3.06l-2.63-1.81l-2.63 1.81l.91-3.06l-2.53-1.94L12.44 4l1.06-3l1.06 3zm3.5 6.91l-1.64 1.25l.59 1.98l-1.7-1.17l-1.7 1.17l.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95zm-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85c-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14c.4-.4.82-.76 1.27-1.08c.75-.53 1.93.36 1.85 1.19c-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82c-2.81 3.14-2.7 7.96.31 10.98c3.02 3.01 7.84 3.12 10.98.31'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
it-mdi-white-balance-sunny{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='m3.55 19.09l1.41 1.41l1.8-1.79l-1.42-1.42M12 6c-3.31 0-6 2.69-6 6s2.69 6 6 6s6-2.69 6-6c0-3.32-2.69-6-6-6m8 7h3v-2h-3m-2.76 7.71l1.8 1.79l1.41-1.41l-1.79-1.8M20.45 5l-1.41-1.4l-1.8 1.79l1.42 1.42M13 1h-2v3h2M6.76 5.39L4.96 3.6L3.55 5l1.79 1.81zM1 13h3v-2H1m12 9h-2v3h2'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
/* layer: typography */
:is([prose=""],.prose) :where(h1,h2,h3,h4,h5,h6):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-headings);font-weight:600;line-height:1.25;}:is([prose=""],.prose) :where(a):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-links);text-decoration:underline;font-weight:500;}:is([prose=""],.prose) :where(a code):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-links);}:is([prose=""],.prose) :where(p,ul,ol,pre):not(:where(.not-prose,.not-prose *)){margin:1em 0;line-height:1.75;}:is([prose=""],.prose) :where(blockquote):not(:where(.not-prose,.not-prose *)){margin:1em 0;padding-left:1em;font-style:italic;border-left:.25em solid var(--un-prose-borders);}:is([prose=""],.prose) :where(h1):not(:where(.not-prose,.not-prose *)){margin:1rem 0;font-size:2.25em;}:is([prose=""],.prose) :where(h2):not(:where(.not-prose,.not-prose *)){margin:1.75em 0 .5em;font-size:1.75em;}:is([prose=""],.prose) :where(h3):not(:where(.not-prose,.not-prose *)){margin:1.5em 0 .5em;font-size:1.375em;}:is([prose=""],.prose) :where(h4):not(:where(.not-prose,.not-prose *)){margin:1em 0;font-size:1.125em;}:is([prose=""],.prose) :where(img,video):not(:where(.not-prose,.not-prose *)){max-width:100%;}:is([prose=""],.prose) :where(figure,picture):not(:where(.not-prose,.not-prose *)){margin:1em 0;}:is([prose=""],.prose) :where(figcaption):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-captions);font-size:.875em;}:is([prose=""],.prose) :where(code):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-code);font-size:.875em;font-weight:600;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;}:is([prose=""],.prose) :where(:not(pre) > code):not(:where(.not-prose,.not-prose *))::before,:is([prose=""],.prose) :where(:not(pre) > code):not(:where(.not-prose,.not-prose *))::after{content:"\`";}:is([prose=""],.prose) :where(pre):not(:where(.not-prose,.not-prose *)){padding:1.25rem 1.5rem;overflow-x:auto;border-radius:.375rem;}:is([prose=""],.prose) :where(pre,code):not(:where(.not-prose,.not-prose *)){white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;hyphens:none;background:transparent;}:is([prose=""],.prose) :where(pre code):not(:where(.not-prose,.not-prose *)){font-weight:inherit;}:is([prose=""],.prose) :where(ol,ul):not(:where(.not-prose,.not-prose *)){padding-left:1.25em;}:is([prose=""],.prose) :where(ol):not(:where(.not-prose,.not-prose *)){list-style-type:decimal;}:is([prose=""],.prose) :where(ol[type="A"]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-alpha;}:is([prose=""],.prose) :where(ol[type="a"]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-alpha;}:is([prose=""],.prose) :where(ol[type="A" s]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-alpha;}:is([prose=""],.prose) :where(ol[type="a" s]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-alpha;}:is([prose=""],.prose) :where(ol[type="I"]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-roman;}:is([prose=""],.prose) :where(ol[type="i"]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-roman;}:is([prose=""],.prose) :where(ol[type="I" s]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-roman;}:is([prose=""],.prose) :where(ol[type="i" s]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-roman;}:is([prose=""],.prose) :where(ol[type="1"]):not(:where(.not-prose,.not-prose *)){list-style-type:decimal;}:is([prose=""],.prose) :where(ul):not(:where(.not-prose,.not-prose *)){list-style-type:disc;}:is([prose=""],.prose) :where(ol > li):not(:where(.not-prose,.not-prose *))::marker,:is([prose=""],.prose) :where(ul > li):not(:where(.not-prose,.not-prose *))::marker,:is([prose=""],.prose) :where(summary):not(:where(.not-prose,.not-prose *))::marker{color:var(--un-prose-lists);}:is([prose=""],.prose) :where(hr):not(:where(.not-prose,.not-prose *)){margin:2em 0;border:1px solid var(--un-prose-hr);}:is([prose=""],.prose) :where(table):not(:where(.not-prose,.not-prose *)){display:block;margin:1em 0;border-collapse:collapse;overflow-x:auto;}:is([prose=""],.prose) :where(tr):not(:where(.not-prose,.not-prose *)):nth-child(2n){background:var(--un-prose-bg-soft);}:is([prose=""],.prose) :where(td,th):not(:where(.not-prose,.not-prose *)){border:1px solid var(--un-prose-borders);padding:.625em 1em;}:is([prose=""],.prose) :where(abbr):not(:where(.not-prose,.not-prose *)){cursor:help;}:is([prose=""],.prose) :where(kbd):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-code);border:1px solid;padding:.25rem .5rem;font-size:.875em;border-radius:.25rem;}:is([prose=""],.prose) :where(details):not(:where(.not-prose,.not-prose *)){margin:1em 0;padding:1.25rem 1.5rem;background:var(--un-prose-bg-soft);}:is([prose=""],.prose) :where(summary):not(:where(.not-prose,.not-prose *)){cursor:pointer;font-weight:600;}
/* layer: default */
.static{position:static;}
.transition{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms;}`
];
Al([
  J("sl-menu")
], Xr.prototype, "menu", 2);
Al([
  De()
], Xr.prototype, "theme", 2);
Al([
  y({ type: String, reflect: !0 })
], Xr.prototype, "size", 2);
Xr = Al([
  Mr("theme-it")
], Xr);
const nZ = ":host{display:inline-block}";
var sZ = Object.defineProperty, oZ = Object.getOwnPropertyDescriptor, lZ = Object.getPrototypeOf, aZ = Reflect.get, Or = (r, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? oZ(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (n = (i ? o(e, t, n) : o(n)) || n);
  return i && n && sZ(e, t, n), n;
}, hZ = (r, e, t) => aZ(lZ(r), t, e);
const Wf = "Cacher", Vf = "Montrer";
let lt = class extends Pt {
  constructor() {
    super(...arguments), this.selector = "unknown", this.size = "small", this.textShow = "<it-mdi-show-outline></it-mdi-show-outline>", this.textHide = "<it-mdi-hide-outline></it-mdi-hide-outline>", this.tooltipShow = Vf, this.tooltipHide = Wf, this.visibility = !1, this.hidden = !1;
  }
  getHidden() {
    return this.element ? this.visibility ? this.element.style.visibility === "hidden" : this.element.style.display === "none" : !1;
  }
  firstUpdated(r) {
    this.tooltipShow === Vf && (this.tooltipShow += ` "${this.selector}"`), this.tooltipHide === Wf && (this.tooltipHide += ` "${this.selector}"`), this.element = document.querySelector(this.selector), this.hidden = this.getHidden();
  }
  render() {
    return X`
      <sl-tooltip content=${this.hidden ? this.tooltipShow : this.tooltipHide}>
        <sl-button size=${this.size} @click=${() => this.toggleSelector()}>
          ${Va(this.hidden ? this.textShow : this.textHide)}
        </sl-button>
      </sl-tooltip>
    `;
  }
  /**
   * Le nom courant de l'élément : `Bascule`.
   */
  get tagTitle() {
    return "Bascule";
  }
  /**
   * Syntaxe `asciidoc` équivalente :
   *
   * ```
   * name:target[attributes]   
   * ```
   *
   * - `name` : `toggle-it`  (la macro `asciidoc` a le même nom que l'élément `html` correspondant);
   * - `target` : `selector` 
   * - `attributes` : `size`, `text-hide`, `text-show`, `tooltip-hide`, `tooltip-show`, `visibility`.
   *
   * Voir la documentation Asciidoc sur les <a href="https://docs.asciidoctor.org/asciidoc/latest/key-concepts/#macros">macros de type _inline_</a>
   *
   * @examples 
   * `toggle-it:#header[visibility]`, 
   * `toggle-it:#header[text-hide="cacher l'en-tête",text-show="montrer l'en-tête",visibility]`
   */
  toAsciidoc() {
    throw new Error("Method not implemented.");
  }
  toggleSelector() {
    this.element && (this.visibility ? this.element.style.visibility = this.element.style.visibility === "hidden" ? "visible" : "hidden" : this.element.style.display = this.element.style.display === "none" ? "" : "none"), this.hidden = this.getHidden();
  }
};
lt.styles = [
  hZ(lt, lt, "styles"),
  Zt(nZ),
  re`/* layer: preflights */
*,::before,::after{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-pan-x: ;--un-pan-y: ;--un-pinch-zoom: ;--un-scroll-snap-strictness:proximity;--un-ordinal: ;--un-slashed-zero: ;--un-numeric-figure: ;--un-numeric-spacing: ;--un-numeric-fraction: ;--un-border-spacing-x:0;--un-border-spacing-y:0;--un-ring-offset-shadow:0 0 rgb(0 0 0 / 0);--un-ring-shadow:0 0 rgb(0 0 0 / 0);--un-shadow-inset: ;--un-shadow:0 0 rgb(0 0 0 / 0);--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgb(147 197 253 / 0.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: ;}::backdrop{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-pan-x: ;--un-pan-y: ;--un-pinch-zoom: ;--un-scroll-snap-strictness:proximity;--un-ordinal: ;--un-slashed-zero: ;--un-numeric-figure: ;--un-numeric-spacing: ;--un-numeric-fraction: ;--un-border-spacing-x:0;--un-border-spacing-y:0;--un-ring-offset-shadow:0 0 rgb(0 0 0 / 0);--un-ring-shadow:0 0 rgb(0 0 0 / 0);--un-shadow-inset: ;--un-shadow:0 0 rgb(0 0 0 / 0);--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgb(147 197 253 / 0.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: ;}
/* layer: icons */
it-mdi-hide-outline{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M2 5.27L3.28 4L20 20.72L18.73 22l-3.08-3.08c-1.15.38-2.37.58-3.65.58c-5 0-9.27-3.11-11-7.5c.69-1.76 1.79-3.31 3.19-4.54zM12 9a3 3 0 0 1 3 3a3 3 0 0 1-.17 1L11 9.17A3 3 0 0 1 12 9m0-4.5c5 0 9.27 3.11 11 7.5a11.79 11.79 0 0 1-4 5.19l-1.42-1.43A9.862 9.862 0 0 0 20.82 12A9.821 9.821 0 0 0 12 6.5c-1.09 0-2.16.18-3.16.5L7.3 5.47c1.44-.62 3.03-.97 4.7-.97M3.18 12A9.821 9.821 0 0 0 12 17.5c.69 0 1.37-.07 2-.21L11.72 15A3.064 3.064 0 0 1 9 12.28L5.6 8.87c-.99.85-1.82 1.91-2.42 3.13'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
it-mdi-show-outline{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M12 9a3 3 0 0 1 3 3a3 3 0 0 1-3 3a3 3 0 0 1-3-3a3 3 0 0 1 3-3m0-4.5c5 0 9.27 3.11 11 7.5c-1.73 4.39-6 7.5-11 7.5S2.73 16.39 1 12c1.73-4.39 6-7.5 11-7.5M3.18 12a9.821 9.821 0 0 0 17.64 0a9.821 9.821 0 0 0-17.64 0'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
/* layer: typography */
:is([prose=""],.prose) :where(h1,h2,h3,h4,h5,h6):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-headings);font-weight:600;line-height:1.25;}:is([prose=""],.prose) :where(a):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-links);text-decoration:underline;font-weight:500;}:is([prose=""],.prose) :where(a code):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-links);}:is([prose=""],.prose) :where(p,ul,ol,pre):not(:where(.not-prose,.not-prose *)){margin:1em 0;line-height:1.75;}:is([prose=""],.prose) :where(blockquote):not(:where(.not-prose,.not-prose *)){margin:1em 0;padding-left:1em;font-style:italic;border-left:.25em solid var(--un-prose-borders);}:is([prose=""],.prose) :where(h1):not(:where(.not-prose,.not-prose *)){margin:1rem 0;font-size:2.25em;}:is([prose=""],.prose) :where(h2):not(:where(.not-prose,.not-prose *)){margin:1.75em 0 .5em;font-size:1.75em;}:is([prose=""],.prose) :where(h3):not(:where(.not-prose,.not-prose *)){margin:1.5em 0 .5em;font-size:1.375em;}:is([prose=""],.prose) :where(h4):not(:where(.not-prose,.not-prose *)){margin:1em 0;font-size:1.125em;}:is([prose=""],.prose) :where(img,video):not(:where(.not-prose,.not-prose *)){max-width:100%;}:is([prose=""],.prose) :where(figure,picture):not(:where(.not-prose,.not-prose *)){margin:1em 0;}:is([prose=""],.prose) :where(figcaption):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-captions);font-size:.875em;}:is([prose=""],.prose) :where(code):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-code);font-size:.875em;font-weight:600;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;}:is([prose=""],.prose) :where(:not(pre) > code):not(:where(.not-prose,.not-prose *))::before,:is([prose=""],.prose) :where(:not(pre) > code):not(:where(.not-prose,.not-prose *))::after{content:"\`";}:is([prose=""],.prose) :where(pre):not(:where(.not-prose,.not-prose *)){padding:1.25rem 1.5rem;overflow-x:auto;border-radius:.375rem;}:is([prose=""],.prose) :where(pre,code):not(:where(.not-prose,.not-prose *)){white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;hyphens:none;background:transparent;}:is([prose=""],.prose) :where(pre code):not(:where(.not-prose,.not-prose *)){font-weight:inherit;}:is([prose=""],.prose) :where(ol,ul):not(:where(.not-prose,.not-prose *)){padding-left:1.25em;}:is([prose=""],.prose) :where(ol):not(:where(.not-prose,.not-prose *)){list-style-type:decimal;}:is([prose=""],.prose) :where(ol[type="A"]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-alpha;}:is([prose=""],.prose) :where(ol[type="a"]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-alpha;}:is([prose=""],.prose) :where(ol[type="A" s]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-alpha;}:is([prose=""],.prose) :where(ol[type="a" s]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-alpha;}:is([prose=""],.prose) :where(ol[type="I"]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-roman;}:is([prose=""],.prose) :where(ol[type="i"]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-roman;}:is([prose=""],.prose) :where(ol[type="I" s]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-roman;}:is([prose=""],.prose) :where(ol[type="i" s]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-roman;}:is([prose=""],.prose) :where(ol[type="1"]):not(:where(.not-prose,.not-prose *)){list-style-type:decimal;}:is([prose=""],.prose) :where(ul):not(:where(.not-prose,.not-prose *)){list-style-type:disc;}:is([prose=""],.prose) :where(ol > li):not(:where(.not-prose,.not-prose *))::marker,:is([prose=""],.prose) :where(ul > li):not(:where(.not-prose,.not-prose *))::marker,:is([prose=""],.prose) :where(summary):not(:where(.not-prose,.not-prose *))::marker{color:var(--un-prose-lists);}:is([prose=""],.prose) :where(hr):not(:where(.not-prose,.not-prose *)){margin:2em 0;border:1px solid var(--un-prose-hr);}:is([prose=""],.prose) :where(table):not(:where(.not-prose,.not-prose *)){display:block;margin:1em 0;border-collapse:collapse;overflow-x:auto;}:is([prose=""],.prose) :where(tr):not(:where(.not-prose,.not-prose *)):nth-child(2n){background:var(--un-prose-bg-soft);}:is([prose=""],.prose) :where(td,th):not(:where(.not-prose,.not-prose *)){border:1px solid var(--un-prose-borders);padding:.625em 1em;}:is([prose=""],.prose) :where(abbr):not(:where(.not-prose,.not-prose *)){cursor:help;}:is([prose=""],.prose) :where(kbd):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-code);border:1px solid;padding:.25rem .5rem;font-size:.875em;border-radius:.25rem;}:is([prose=""],.prose) :where(details):not(:where(.not-prose,.not-prose *)){margin:1em 0;padding:1.25rem 1.5rem;background:var(--un-prose-bg-soft);}:is([prose=""],.prose) :where(summary):not(:where(.not-prose,.not-prose *)){cursor:pointer;font-weight:600;}
/* layer: default */
.visible{visibility:visible;}
.static{position:static;}
.hidden{display:none;}`
];
Or([
  y({ type: String, reflect: !0 })
], lt.prototype, "selector", 2);
Or([
  y({ type: String, reflect: !0 })
], lt.prototype, "size", 2);
Or([
  y({ type: String, reflect: !0, attribute: "text-show" })
], lt.prototype, "textShow", 2);
Or([
  y({ type: String, reflect: !0, attribute: "text-hide" })
], lt.prototype, "textHide", 2);
Or([
  y({ type: String, reflect: !0, attribute: "tooltip-show" })
], lt.prototype, "tooltipShow", 2);
Or([
  y({ type: String, reflect: !0, attribute: "tooltip-hide" })
], lt.prototype, "tooltipHide", 2);
Or([
  y({ type: Boolean, reflect: !0 })
], lt.prototype, "visibility", 2);
Or([
  De()
], lt.prototype, "hidden", 2);
lt = Or([
  Mr("toggle-it")
], lt);
var cZ = re`
  ${We}
  ${J1}

  :host {
    display: block;
  }

  .input {
    flex: 1 1 auto;
    display: inline-flex;
    align-items: stretch;
    justify-content: start;
    position: relative;
    width: 100%;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    letter-spacing: var(--sl-input-letter-spacing);
    vertical-align: middle;
    overflow: hidden;
    cursor: text;
    transition:
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) border,
      var(--sl-transition-fast) box-shadow,
      var(--sl-transition-fast) background-color;
  }

  /* Standard inputs */
  .input--standard {
    background-color: var(--sl-input-background-color);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
  }

  .input--standard:hover:not(.input--disabled) {
    background-color: var(--sl-input-background-color-hover);
    border-color: var(--sl-input-border-color-hover);
  }

  .input--standard.input--focused:not(.input--disabled) {
    background-color: var(--sl-input-background-color-focus);
    border-color: var(--sl-input-border-color-focus);
    box-shadow: 0 0 0 var(--sl-focus-ring-width) var(--sl-input-focus-ring-color);
  }

  .input--standard.input--focused:not(.input--disabled) .input__control {
    color: var(--sl-input-color-focus);
  }

  .input--standard.input--disabled {
    background-color: var(--sl-input-background-color-disabled);
    border-color: var(--sl-input-border-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .input--standard.input--disabled .input__control {
    color: var(--sl-input-color-disabled);
  }

  .input--standard.input--disabled .input__control::placeholder {
    color: var(--sl-input-placeholder-color-disabled);
  }

  /* Filled inputs */
  .input--filled {
    border: none;
    background-color: var(--sl-input-filled-background-color);
    color: var(--sl-input-color);
  }

  .input--filled:hover:not(.input--disabled) {
    background-color: var(--sl-input-filled-background-color-hover);
  }

  .input--filled.input--focused:not(.input--disabled) {
    background-color: var(--sl-input-filled-background-color-focus);
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .input--filled.input--disabled {
    background-color: var(--sl-input-filled-background-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .input__control {
    flex: 1 1 auto;
    font-family: inherit;
    font-size: inherit;
    font-weight: inherit;
    min-width: 0;
    height: 100%;
    color: var(--sl-input-color);
    border: none;
    background: inherit;
    box-shadow: none;
    padding: 0;
    margin: 0;
    cursor: inherit;
    -webkit-appearance: none;
  }

  .input__control::-webkit-search-decoration,
  .input__control::-webkit-search-cancel-button,
  .input__control::-webkit-search-results-button,
  .input__control::-webkit-search-results-decoration {
    -webkit-appearance: none;
  }

  .input__control:-webkit-autofill,
  .input__control:-webkit-autofill:hover,
  .input__control:-webkit-autofill:focus,
  .input__control:-webkit-autofill:active {
    box-shadow: 0 0 0 var(--sl-input-height-large) var(--sl-input-background-color-hover) inset !important;
    -webkit-text-fill-color: var(--sl-color-primary-500);
    caret-color: var(--sl-input-color);
  }

  .input--filled .input__control:-webkit-autofill,
  .input--filled .input__control:-webkit-autofill:hover,
  .input--filled .input__control:-webkit-autofill:focus,
  .input--filled .input__control:-webkit-autofill:active {
    box-shadow: 0 0 0 var(--sl-input-height-large) var(--sl-input-filled-background-color) inset !important;
  }

  .input__control::placeholder {
    color: var(--sl-input-placeholder-color);
    user-select: none;
    -webkit-user-select: none;
  }

  .input:hover:not(.input--disabled) .input__control {
    color: var(--sl-input-color-hover);
  }

  .input__control:focus {
    outline: none;
  }

  .input__prefix,
  .input__suffix {
    display: inline-flex;
    flex: 0 0 auto;
    align-items: center;
    cursor: default;
  }

  .input__prefix ::slotted(sl-icon),
  .input__suffix ::slotted(sl-icon) {
    color: var(--sl-input-icon-color);
  }

  /*
   * Size modifiers
   */

  .input--small {
    border-radius: var(--sl-input-border-radius-small);
    font-size: var(--sl-input-font-size-small);
    height: var(--sl-input-height-small);
  }

  .input--small .input__control {
    height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-small);
  }

  .input--small .input__clear,
  .input--small .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-small) * 2);
  }

  .input--small .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-small);
  }

  .input--small .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-small);
  }

  .input--medium {
    border-radius: var(--sl-input-border-radius-medium);
    font-size: var(--sl-input-font-size-medium);
    height: var(--sl-input-height-medium);
  }

  .input--medium .input__control {
    height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-medium);
  }

  .input--medium .input__clear,
  .input--medium .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-medium) * 2);
  }

  .input--medium .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-medium);
  }

  .input--medium .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-medium);
  }

  .input--large {
    border-radius: var(--sl-input-border-radius-large);
    font-size: var(--sl-input-font-size-large);
    height: var(--sl-input-height-large);
  }

  .input--large .input__control {
    height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-large);
  }

  .input--large .input__clear,
  .input--large .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-large) * 2);
  }

  .input--large .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-large);
  }

  .input--large .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-large);
  }

  /*
   * Pill modifier
   */

  .input--pill.input--small {
    border-radius: var(--sl-input-height-small);
  }

  .input--pill.input--medium {
    border-radius: var(--sl-input-height-medium);
  }

  .input--pill.input--large {
    border-radius: var(--sl-input-height-large);
  }

  /*
   * Clearable + Password Toggle
   */

  .input__clear:not(.input__clear--visible) {
    visibility: hidden;
  }

  .input__clear,
  .input__password-toggle {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: inherit;
    color: var(--sl-input-icon-color);
    border: none;
    background: none;
    padding: 0;
    transition: var(--sl-transition-fast) color;
    cursor: pointer;
  }

  .input__clear:hover,
  .input__password-toggle:hover {
    color: var(--sl-input-icon-color-hover);
  }

  .input__clear:focus,
  .input__password-toggle:focus {
    outline: none;
  }

  .input--empty .input__clear {
    visibility: hidden;
  }

  /* Don't show the browser's password toggle in Edge */
  ::-ms-reveal {
    display: none;
  }

  /* Hide the built-in number spinner */
  .input--no-spin-buttons input[type='number']::-webkit-outer-spin-button,
  .input--no-spin-buttons input[type='number']::-webkit-inner-spin-button {
    -webkit-appearance: none;
    display: none;
  }

  .input--no-spin-buttons input[type='number'] {
    -moz-appearance: textfield;
  }
`, B = class extends ve {
  constructor() {
    super(...arguments), this.formControlController = new tc(this, {
      assumeInteractionOn: ["sl-blur", "sl-input"]
    }), this.hasSlotController = new ms(this, "help-text", "label"), this.localize = new Vr(this), this.hasFocus = !1, this.title = "", this.__numberInput = Object.assign(document.createElement("input"), { type: "number" }), this.__dateInput = Object.assign(document.createElement("input"), { type: "date" }), this.type = "text", this.name = "", this.value = "", this.defaultValue = "", this.size = "medium", this.filled = !1, this.pill = !1, this.label = "", this.helpText = "", this.clearable = !1, this.disabled = !1, this.placeholder = "", this.readonly = !1, this.passwordToggle = !1, this.passwordVisible = !1, this.noSpinButtons = !1, this.form = "", this.required = !1, this.spellcheck = !0;
  }
  //
  // NOTE: We use an in-memory input for these getters/setters instead of the one in the template because the properties
  // can be set before the component is rendered.
  //
  /**
   * Gets or sets the current value as a `Date` object. Returns `null` if the value can't be converted. This will use the native `<input type="{{type}}">` implementation and may result in an error.
   */
  get valueAsDate() {
    var r;
    return this.__dateInput.type = this.type, this.__dateInput.value = this.value, ((r = this.input) == null ? void 0 : r.valueAsDate) || this.__dateInput.valueAsDate;
  }
  set valueAsDate(r) {
    this.__dateInput.type = this.type, this.__dateInput.valueAsDate = r, this.value = this.__dateInput.value;
  }
  /** Gets or sets the current value as a number. Returns `NaN` if the value can't be converted. */
  get valueAsNumber() {
    var r;
    return this.__numberInput.value = this.value, ((r = this.input) == null ? void 0 : r.valueAsNumber) || this.__numberInput.valueAsNumber;
  }
  set valueAsNumber(r) {
    this.__numberInput.valueAsNumber = r, this.value = this.__numberInput.value;
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  handleBlur() {
    this.hasFocus = !1, this.emit("sl-blur");
  }
  handleChange() {
    this.value = this.input.value, this.emit("sl-change");
  }
  handleClearClick(r) {
    this.value = "", this.emit("sl-clear"), this.emit("sl-input"), this.emit("sl-change"), this.input.focus(), r.stopPropagation();
  }
  handleFocus() {
    this.hasFocus = !0, this.emit("sl-focus");
  }
  handleInput() {
    this.value = this.input.value, this.formControlController.updateValidity(), this.emit("sl-input");
  }
  handleInvalid(r) {
    this.formControlController.setValidity(!1), this.formControlController.emitInvalidEvent(r);
  }
  handleKeyDown(r) {
    const e = r.metaKey || r.ctrlKey || r.shiftKey || r.altKey;
    r.key === "Enter" && !e && setTimeout(() => {
      !r.defaultPrevented && !r.isComposing && this.formControlController.submit();
    });
  }
  handlePasswordToggle() {
    this.passwordVisible = !this.passwordVisible;
  }
  handleDisabledChange() {
    this.formControlController.setValidity(this.disabled);
  }
  handleStepChange() {
    this.input.step = String(this.step), this.formControlController.updateValidity();
  }
  async handleValueChange() {
    await this.updateComplete, this.formControlController.updateValidity();
  }
  /** Sets focus on the input. */
  focus(r) {
    this.input.focus(r);
  }
  /** Removes focus from the input. */
  blur() {
    this.input.blur();
  }
  /** Selects all the text in the input. */
  select() {
    this.input.select();
  }
  /** Sets the start and end positions of the text selection (0-based). */
  setSelectionRange(r, e, t = "none") {
    this.input.setSelectionRange(r, e, t);
  }
  /** Replaces a range of text with a new string. */
  setRangeText(r, e, t, i) {
    this.input.setRangeText(r, e, t, i), this.value !== this.input.value && (this.value = this.input.value);
  }
  /** Displays the browser picker for an input element (only works if the browser supports it for the input type). */
  showPicker() {
    "showPicker" in HTMLInputElement.prototype && this.input.showPicker();
  }
  /** Increments the value of a numeric input type by the value of the step attribute. */
  stepUp() {
    this.input.stepUp(), this.value !== this.input.value && (this.value = this.input.value);
  }
  /** Decrements the value of a numeric input type by the value of the step attribute. */
  stepDown() {
    this.input.stepDown(), this.value !== this.input.value && (this.value = this.input.value);
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(r) {
    this.input.setCustomValidity(r), this.formControlController.updateValidity();
  }
  render() {
    const r = this.hasSlotController.test("label"), e = this.hasSlotController.test("help-text"), t = this.label ? !0 : !!r, i = this.helpText ? !0 : !!e, n = this.clearable && !this.disabled && !this.readonly, s = n && (typeof this.value == "number" || this.value.length > 0);
    return X`
      <div
        part="form-control"
        class=${je({
      "form-control": !0,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-label": t,
      "form-control--has-help-text": i
    })}
      >
        <label
          part="form-control-label"
          class="form-control__label"
          for="input"
          aria-hidden=${t ? "false" : "true"}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <div
            part="base"
            class=${je({
      input: !0,
      // Sizes
      "input--small": this.size === "small",
      "input--medium": this.size === "medium",
      "input--large": this.size === "large",
      // States
      "input--pill": this.pill,
      "input--standard": !this.filled,
      "input--filled": this.filled,
      "input--disabled": this.disabled,
      "input--focused": this.hasFocus,
      "input--empty": !this.value,
      "input--no-spin-buttons": this.noSpinButtons
    })}
          >
            <span part="prefix" class="input__prefix">
              <slot name="prefix"></slot>
            </span>

            <input
              part="input"
              id="input"
              class="input__control"
              type=${this.type === "password" && this.passwordVisible ? "text" : this.type}
              title=${this.title}
              name=${I(this.name)}
              ?disabled=${this.disabled}
              ?readonly=${this.readonly}
              ?required=${this.required}
              placeholder=${I(this.placeholder)}
              minlength=${I(this.minlength)}
              maxlength=${I(this.maxlength)}
              min=${I(this.min)}
              max=${I(this.max)}
              step=${I(this.step)}
              .value=${tb(this.value)}
              autocapitalize=${I(this.autocapitalize)}
              autocomplete=${I(this.autocomplete)}
              autocorrect=${I(this.autocorrect)}
              ?autofocus=${this.autofocus}
              spellcheck=${this.spellcheck}
              pattern=${I(this.pattern)}
              enterkeyhint=${I(this.enterkeyhint)}
              inputmode=${I(this.inputmode)}
              aria-describedby="help-text"
              @change=${this.handleChange}
              @input=${this.handleInput}
              @invalid=${this.handleInvalid}
              @keydown=${this.handleKeyDown}
              @focus=${this.handleFocus}
              @blur=${this.handleBlur}
            />

            ${n ? X`
                  <button
                    part="clear-button"
                    class=${je({
      input__clear: !0,
      "input__clear--visible": s
    })}
                    type="button"
                    aria-label=${this.localize.term("clearEntry")}
                    @click=${this.handleClearClick}
                    tabindex="-1"
                  >
                    <slot name="clear-icon">
                      <sl-icon name="x-circle-fill" library="system"></sl-icon>
                    </slot>
                  </button>
                ` : ""}
            ${this.passwordToggle && !this.disabled ? X`
                  <button
                    part="password-toggle-button"
                    class="input__password-toggle"
                    type="button"
                    aria-label=${this.localize.term(this.passwordVisible ? "hidePassword" : "showPassword")}
                    @click=${this.handlePasswordToggle}
                    tabindex="-1"
                  >
                    ${this.passwordVisible ? X`
                          <slot name="show-password-icon">
                            <sl-icon name="eye-slash" library="system"></sl-icon>
                          </slot>
                        ` : X`
                          <slot name="hide-password-icon">
                            <sl-icon name="eye" library="system"></sl-icon>
                          </slot>
                        `}
                  </button>
                ` : ""}

            <span part="suffix" class="input__suffix">
              <slot name="suffix"></slot>
            </span>
          </div>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${i ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
B.styles = cZ;
B.dependencies = { "sl-icon": vt };
w([
  J(".input__control")
], B.prototype, "input", 2);
w([
  De()
], B.prototype, "hasFocus", 2);
w([
  y()
], B.prototype, "title", 2);
w([
  y({ reflect: !0 })
], B.prototype, "type", 2);
w([
  y()
], B.prototype, "name", 2);
w([
  y()
], B.prototype, "value", 2);
w([
  eb()
], B.prototype, "defaultValue", 2);
w([
  y({ reflect: !0 })
], B.prototype, "size", 2);
w([
  y({ type: Boolean, reflect: !0 })
], B.prototype, "filled", 2);
w([
  y({ type: Boolean, reflect: !0 })
], B.prototype, "pill", 2);
w([
  y()
], B.prototype, "label", 2);
w([
  y({ attribute: "help-text" })
], B.prototype, "helpText", 2);
w([
  y({ type: Boolean })
], B.prototype, "clearable", 2);
w([
  y({ type: Boolean, reflect: !0 })
], B.prototype, "disabled", 2);
w([
  y()
], B.prototype, "placeholder", 2);
w([
  y({ type: Boolean, reflect: !0 })
], B.prototype, "readonly", 2);
w([
  y({ attribute: "password-toggle", type: Boolean })
], B.prototype, "passwordToggle", 2);
w([
  y({ attribute: "password-visible", type: Boolean })
], B.prototype, "passwordVisible", 2);
w([
  y({ attribute: "no-spin-buttons", type: Boolean })
], B.prototype, "noSpinButtons", 2);
w([
  y({ reflect: !0 })
], B.prototype, "form", 2);
w([
  y({ type: Boolean, reflect: !0 })
], B.prototype, "required", 2);
w([
  y()
], B.prototype, "pattern", 2);
w([
  y({ type: Number })
], B.prototype, "minlength", 2);
w([
  y({ type: Number })
], B.prototype, "maxlength", 2);
w([
  y()
], B.prototype, "min", 2);
w([
  y()
], B.prototype, "max", 2);
w([
  y()
], B.prototype, "step", 2);
w([
  y()
], B.prototype, "autocapitalize", 2);
w([
  y()
], B.prototype, "autocorrect", 2);
w([
  y()
], B.prototype, "autocomplete", 2);
w([
  y({ type: Boolean })
], B.prototype, "autofocus", 2);
w([
  y()
], B.prototype, "enterkeyhint", 2);
w([
  y({
    type: Boolean,
    converter: {
      // Allow "true|false" attribute values but keep the property boolean
      fromAttribute: (r) => !(!r || r === "false"),
      toAttribute: (r) => r ? "true" : "false"
    }
  })
], B.prototype, "spellcheck", 2);
w([
  y()
], B.prototype, "inputmode", 2);
w([
  $e("disabled", { waitUntilFirstUpdate: !0 })
], B.prototype, "handleDisabledChange", 1);
w([
  $e("step", { waitUntilFirstUpdate: !0 })
], B.prototype, "handleStepChange", 1);
w([
  $e("value", { waitUntilFirstUpdate: !0 })
], B.prototype, "handleValueChange", 1);
B.define("sl-input");
const uZ = ":host{display:inline-block}.tools{display:inline-flex}.tools__container{display:inline-flex;justify-content:flex-end}";
var dZ = Object.defineProperty, pZ = Object.getOwnPropertyDescriptor, fZ = Object.getPrototypeOf, OZ = Reflect.get, Ir = (r, e, t, i) => {
  for (var n = i > 1 ? void 0 : i ? pZ(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (n = (i ? o(e, t, n) : o(n)) || n);
  return i && n && dZ(e, t, n), n;
}, mZ = (r, e, t) => OZ(fZ(r), t, e);
let wt = class extends Pt {
  constructor() {
    super(...arguments), this.size = "small", this.menuItems = [];
  }
  firstUpdated(r) {
    this.menuItems = [...this.menu.querySelectorAll("sl-menu-item")];
  }
  handleSelectTool(r) {
    const e = r.detail.item;
    if (e.toggleAttribute("checked"), e.checked) {
      switch (e.value) {
        case "all":
          this.clockElement.removeAttribute("hidden"), this.colorElement.removeAttribute("hidden"), this.themeElement.removeAttribute("hidden"), this.menuItems.forEach((t) => t.checked = !0);
          break;
        case "date":
          this.clockElement.removeAttribute("hidden");
          break;
        case "theme":
          this.themeElement.removeAttribute("hidden");
          break;
        case "color":
          this.colorElement.removeAttribute("hidden");
          break;
      }
      !this.menuItemAll.checked && this.menuItems.length - 1 === this.menuItems.filter((t) => t.checked).length && (this.menuItemAll.checked = !0);
    } else
      switch (e.value) {
        case "all":
          this.clockElement.setAttribute("hidden", ""), this.colorElement.setAttribute("hidden", ""), this.themeElement.setAttribute("hidden", ""), this.menuItems.forEach((t) => t.checked = !1);
          break;
        case "date":
          this.clockElement.setAttribute("hidden", ""), this.menuItemAll.checked = !1;
          break;
        case "theme":
          this.themeElement.setAttribute("hidden", ""), this.menuItemAll.checked = !1;
          break;
        case "color":
          this.colorElement.setAttribute("hidden", ""), this.menuItemAll.checked = !1;
          break;
      }
  }
  render() {
    return X`
      <div part="base" class="tools">
        <div class="tools__container">
          <!--
          <alarm-it size=${this.size} hidden></alarm-it>
          <chrono-it size=${this.size} hidden></chrono-it>
          <timer-it size=${this.size} hidden></timer-it>
          -->
          <clock-it size=${this.size} date time hidden></clock-it>
          <color-it size=${this.size} hidden></color-it>
          <theme-it size=${this.size} hidden></theme-it>
        </div>
        <sl-dropdown part="dropdown" stay-open-on-select hoist>
          <sl-button size=${this.size} slot="trigger" caret>
            <it-mdi-cog class="dropdown-icon"></it-mdi-cog>
          </sl-button>
          <sl-menu @sl-select=${this.handleSelectTool}>
            <sl-menu-item value="all" type="checkbox">
              Tout sélectionner
            </sl-menu-item>
            <sl-divider></sl-divider>
            <sl-menu-item value="theme" type="checkbox">
              <it-mdi-theme-light-dark slot="prefix"></it-mdi-theme-light-dark>
              Thème
            </sl-menu-item>
            <sl-menu-item value="color" type="checkbox">
              <it-mdi-palette-outline slot="prefix"></it-mdi-palette-outline>
              Couleur
            </sl-menu-item>
            <sl-divider></sl-divider>
            <sl-menu-item value="date" type="checkbox">
              <it-mdi-calendar-clock-outline slot="prefix"></it-mdi-calendar-clock-outline>
              Date et heure
            </sl-menu-item>
            <!--
            <sl-menu-item value="chrono">
              <div slot="prefix" class="it-mdi-timer-outline"></div>
              Chronomètre
            </sl-menu-item>
            <sl-menu-item value="timer">
              <div slot="prefix" class="it-mdi-camera-timer"></div>
              Minuteur
            </sl-menu-item>
            <sl-menu-item value="alarm">
              <div slot="prefix" class="it-mdi-bell-outline"></div>
              Alarme
            </sl-menu-item>
            -->
          </sl-menu>
        </sl-dropdown>
      </div>
    `;
  }
  get tagTitle() {
    return "Outils";
  }
  toAsciidoc() {
    throw new Error("Method not implemented.");
  }
};
wt.styles = [
  mZ(wt, wt, "styles"),
  Zt(uZ),
  re`/* layer: preflights */
*,::before,::after{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-pan-x: ;--un-pan-y: ;--un-pinch-zoom: ;--un-scroll-snap-strictness:proximity;--un-ordinal: ;--un-slashed-zero: ;--un-numeric-figure: ;--un-numeric-spacing: ;--un-numeric-fraction: ;--un-border-spacing-x:0;--un-border-spacing-y:0;--un-ring-offset-shadow:0 0 rgb(0 0 0 / 0);--un-ring-shadow:0 0 rgb(0 0 0 / 0);--un-shadow-inset: ;--un-shadow:0 0 rgb(0 0 0 / 0);--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgb(147 197 253 / 0.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: ;}::backdrop{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-pan-x: ;--un-pan-y: ;--un-pinch-zoom: ;--un-scroll-snap-strictness:proximity;--un-ordinal: ;--un-slashed-zero: ;--un-numeric-figure: ;--un-numeric-spacing: ;--un-numeric-fraction: ;--un-border-spacing-x:0;--un-border-spacing-y:0;--un-ring-offset-shadow:0 0 rgb(0 0 0 / 0);--un-ring-shadow:0 0 rgb(0 0 0 / 0);--un-shadow-inset: ;--un-shadow:0 0 rgb(0 0 0 / 0);--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgb(147 197 253 / 0.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: ;}
/* layer: icons */
.it-mdi-bell-outline{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M10 21h4c0 1.1-.9 2-2 2s-2-.9-2-2m11-2v1H3v-1l2-2v-6c0-3.1 2-5.8 5-6.7V4c0-1.1.9-2 2-2s2 .9 2 2v.3c3 .9 5 3.6 5 6.7v6zm-4-8c0-2.8-2.2-5-5-5s-5 2.2-5 5v7h10z'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
.it-mdi-camera-timer{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M4.94 6.35c-.39-.39-.39-1.03 0-1.42a.996.996 0 0 1 1.41 0l6.72 5.38l.35.28c.78.78.78 2.05 0 2.83c-.78.78-2.05.78-2.83 0l-.28-.35zM12 20a8 8 0 0 0 8-8c0-2.21-.9-4.21-2.34-5.66l1.41-1.41A9.969 9.969 0 0 1 22 12a10 10 0 0 1-10 10A10 10 0 0 1 2 12h2a8 8 0 0 0 8 8m0-19a2 2 0 0 1 2 2a2 2 0 0 1-2 2a2 2 0 0 1-2-2a2 2 0 0 1 2-2'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
.it-mdi-timer-outline{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M12 20a7 7 0 0 1-7-7a7 7 0 0 1 7-7a7 7 0 0 1 7 7a7 7 0 0 1-7 7m7.03-12.61l1.42-1.42c-.45-.51-.9-.97-1.41-1.41L17.62 6c-1.55-1.26-3.5-2-5.62-2a9 9 0 0 0-9 9a9 9 0 0 0 9 9c5 0 9-4.03 9-9c0-2.12-.74-4.07-1.97-5.61M11 14h2V8h-2m4-7H9v2h6z'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
it-mdi-calendar-clock-outline{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M6 1v2H5c-1.11 0-2 .89-2 2v14a2 2 0 0 0 2 2h6.1c1.26 1.24 2.99 2 4.9 2c3.87 0 7-3.13 7-7c0-1.91-.76-3.64-2-4.9V5a2 2 0 0 0-2-2h-1V1h-2v2H8V1M5 5h14v2H5m0 2h14v.67c-.91-.43-1.93-.67-3-.67c-3.87 0-7 3.13-7 7c0 1.07.24 2.09.67 3H5m11-7.85c2.68 0 4.85 2.17 4.85 4.85c0 2.68-2.17 4.85-4.85 4.85c-2.68 0-4.85-2.17-4.85-4.85c0-2.68 2.17-4.85 4.85-4.85M15 13v3.69l3.19 1.84l.75-1.3l-2.44-1.41V13Z'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
it-mdi-cog{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M12 15.5A3.5 3.5 0 0 1 8.5 12A3.5 3.5 0 0 1 12 8.5a3.5 3.5 0 0 1 3.5 3.5a3.5 3.5 0 0 1-3.5 3.5m7.43-2.53c.04-.32.07-.64.07-.97c0-.33-.03-.66-.07-1l2.11-1.63c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.31-.61-.22l-2.49 1c-.52-.39-1.06-.73-1.69-.98l-.37-2.65A.506.506 0 0 0 14 2h-4c-.25 0-.46.18-.5.42l-.37 2.65c-.63.25-1.17.59-1.69.98l-2.49-1c-.22-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64L4.57 11c-.04.34-.07.67-.07 1c0 .33.03.65.07.97l-2.11 1.66c-.19.15-.25.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1.01c.52.4 1.06.74 1.69.99l.37 2.65c.04.24.25.42.5.42h4c.25 0 .46-.18.5-.42l.37-2.65c.63-.26 1.17-.59 1.69-.99l2.49 1.01c.22.08.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64z'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
it-mdi-palette-outline{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M12 22A10 10 0 0 1 2 12A10 10 0 0 1 12 2c5.5 0 10 4 10 9a6 6 0 0 1-6 6h-1.8c-.3 0-.5.2-.5.5c0 .1.1.2.1.3c.4.5.6 1.1.6 1.7c.1 1.4-1 2.5-2.4 2.5m0-18a8 8 0 0 0-8 8a8 8 0 0 0 8 8c.3 0 .5-.2.5-.5c0-.2-.1-.3-.1-.4c-.4-.5-.6-1-.6-1.6c0-1.4 1.1-2.5 2.5-2.5H16a4 4 0 0 0 4-4c0-3.9-3.6-7-8-7m-5.5 6c.8 0 1.5.7 1.5 1.5S7.3 13 6.5 13S5 12.3 5 11.5S5.7 10 6.5 10m3-4c.8 0 1.5.7 1.5 1.5S10.3 9 9.5 9S8 8.3 8 7.5S8.7 6 9.5 6m5 0c.8 0 1.5.7 1.5 1.5S15.3 9 14.5 9S13 8.3 13 7.5S13.7 6 14.5 6m3 4c.8 0 1.5.7 1.5 1.5s-.7 1.5-1.5 1.5s-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
it-mdi-theme-light-dark{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 24 24' display='inline-block' vertical-align='middle' width='1em' height='1em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M7.5 2c-1.79 1.15-3 3.18-3 5.5s1.21 4.35 3.03 5.5C4.46 13 2 10.54 2 7.5A5.5 5.5 0 0 1 7.5 2m11.57 1.5l1.43 1.43L4.93 20.5L3.5 19.07zm-6.18 2.43L11.41 5L9.97 6l.42-1.7L9 3.24l1.75-.12l.58-1.65L12 3.1l1.73.03l-1.35 1.13zm-3.3 3.61l-1.16-.73l-1.12.78l.34-1.32l-1.09-.83l1.36-.09l.45-1.29l.51 1.27l1.36.03l-1.05.87zM19 13.5a5.5 5.5 0 0 1-5.5 5.5c-1.22 0-2.35-.4-3.26-1.07l7.69-7.69c.67.91 1.07 2.04 1.07 3.26m-4.4 6.58l2.77-1.15l-.24 3.35zm4.33-2.7l1.15-2.77l2.2 2.54zm1.15-4.96l-1.14-2.78l3.34.24zM9.63 18.93l2.77 1.15l-2.53 2.19z'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1em;height:1em;}
/* layer: typography */
:is([prose=""],.prose) :where(h1,h2,h3,h4,h5,h6):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-headings);font-weight:600;line-height:1.25;}:is([prose=""],.prose) :where(a):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-links);text-decoration:underline;font-weight:500;}:is([prose=""],.prose) :where(a code):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-links);}:is([prose=""],.prose) :where(p,ul,ol,pre):not(:where(.not-prose,.not-prose *)){margin:1em 0;line-height:1.75;}:is([prose=""],.prose) :where(blockquote):not(:where(.not-prose,.not-prose *)){margin:1em 0;padding-left:1em;font-style:italic;border-left:.25em solid var(--un-prose-borders);}:is([prose=""],.prose) :where(h1):not(:where(.not-prose,.not-prose *)){margin:1rem 0;font-size:2.25em;}:is([prose=""],.prose) :where(h2):not(:where(.not-prose,.not-prose *)){margin:1.75em 0 .5em;font-size:1.75em;}:is([prose=""],.prose) :where(h3):not(:where(.not-prose,.not-prose *)){margin:1.5em 0 .5em;font-size:1.375em;}:is([prose=""],.prose) :where(h4):not(:where(.not-prose,.not-prose *)){margin:1em 0;font-size:1.125em;}:is([prose=""],.prose) :where(img,video):not(:where(.not-prose,.not-prose *)){max-width:100%;}:is([prose=""],.prose) :where(figure,picture):not(:where(.not-prose,.not-prose *)){margin:1em 0;}:is([prose=""],.prose) :where(figcaption):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-captions);font-size:.875em;}:is([prose=""],.prose) :where(code):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-code);font-size:.875em;font-weight:600;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;}:is([prose=""],.prose) :where(:not(pre) > code):not(:where(.not-prose,.not-prose *))::before,:is([prose=""],.prose) :where(:not(pre) > code):not(:where(.not-prose,.not-prose *))::after{content:"\`";}:is([prose=""],.prose) :where(pre):not(:where(.not-prose,.not-prose *)){padding:1.25rem 1.5rem;overflow-x:auto;border-radius:.375rem;}:is([prose=""],.prose) :where(pre,code):not(:where(.not-prose,.not-prose *)){white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;hyphens:none;background:transparent;}:is([prose=""],.prose) :where(pre code):not(:where(.not-prose,.not-prose *)){font-weight:inherit;}:is([prose=""],.prose) :where(ol,ul):not(:where(.not-prose,.not-prose *)){padding-left:1.25em;}:is([prose=""],.prose) :where(ol):not(:where(.not-prose,.not-prose *)){list-style-type:decimal;}:is([prose=""],.prose) :where(ol[type="A"]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-alpha;}:is([prose=""],.prose) :where(ol[type="a"]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-alpha;}:is([prose=""],.prose) :where(ol[type="A" s]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-alpha;}:is([prose=""],.prose) :where(ol[type="a" s]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-alpha;}:is([prose=""],.prose) :where(ol[type="I"]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-roman;}:is([prose=""],.prose) :where(ol[type="i"]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-roman;}:is([prose=""],.prose) :where(ol[type="I" s]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-roman;}:is([prose=""],.prose) :where(ol[type="i" s]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-roman;}:is([prose=""],.prose) :where(ol[type="1"]):not(:where(.not-prose,.not-prose *)){list-style-type:decimal;}:is([prose=""],.prose) :where(ul):not(:where(.not-prose,.not-prose *)){list-style-type:disc;}:is([prose=""],.prose) :where(ol > li):not(:where(.not-prose,.not-prose *))::marker,:is([prose=""],.prose) :where(ul > li):not(:where(.not-prose,.not-prose *))::marker,:is([prose=""],.prose) :where(summary):not(:where(.not-prose,.not-prose *))::marker{color:var(--un-prose-lists);}:is([prose=""],.prose) :where(hr):not(:where(.not-prose,.not-prose *)){margin:2em 0;border:1px solid var(--un-prose-hr);}:is([prose=""],.prose) :where(table):not(:where(.not-prose,.not-prose *)){display:block;margin:1em 0;border-collapse:collapse;overflow-x:auto;}:is([prose=""],.prose) :where(tr):not(:where(.not-prose,.not-prose *)):nth-child(2n){background:var(--un-prose-bg-soft);}:is([prose=""],.prose) :where(td,th):not(:where(.not-prose,.not-prose *)){border:1px solid var(--un-prose-borders);padding:.625em 1em;}:is([prose=""],.prose) :where(abbr):not(:where(.not-prose,.not-prose *)){cursor:help;}:is([prose=""],.prose) :where(kbd):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-code);border:1px solid;padding:.25rem .5rem;font-size:.875em;border-radius:.25rem;}:is([prose=""],.prose) :where(details):not(:where(.not-prose,.not-prose *)){margin:1em 0;padding:1.25rem 1.5rem;background:var(--un-prose-bg-soft);}:is([prose=""],.prose) :where(summary):not(:where(.not-prose,.not-prose *)){cursor:pointer;font-weight:600;}
/* layer: default */
.static{position:static;}
.hidden,
[hidden=""]{display:none;}`
];
Ir([
  J("sl-menu")
], wt.prototype, "menu", 2);
Ir([
  J('sl-menu-item[value="all"]')
], wt.prototype, "menuItemAll", 2);
Ir([
  J(".tools__container")
], wt.prototype, "containerElement", 2);
Ir([
  J(".tools__container > clock-it")
], wt.prototype, "clockElement", 2);
Ir([
  J(".tools__container > theme-it")
], wt.prototype, "themeElement", 2);
Ir([
  J(".tools__container > color-it")
], wt.prototype, "colorElement", 2);
Ir([
  y({ type: String, reflect: !0 })
], wt.prototype, "size", 2);
wt = Ir([
  Mr("tools-it")
], wt);
export {
  mt as ClockIt,
  fe as CodeIt,
  Cr as ColorIt,
  li as LoremIpsumIt,
  SZ as SlButton,
  Xr as ThemeIt,
  lt as ToggleIt,
  oi as ToolbarIt,
  wt as ToolsIt
};
